import {
  __commonJS,
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports2);
  }
});

// node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "node_modules/iota-array/iota.js"(exports2, module2) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module2.exports = iota;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports2, module2) {
    module2.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "node_modules/ndarray/ndarray.js"(exports2, module2) {
    var iota = require_iota();
    var isBuffer = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a, b) {
      return a[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("");
      if (dimension < 0) {
        className = "View_Nil" + dtype;
      }
      var useGetters = dtype === "generic";
      if (dimension === -1) {
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
      } else if (dimension === 0) {
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
      }
      var code = ["'use strict'"];
      var indices = iota(dimension);
      var args = indices.map(function(i2) {
        return "i" + i2;
      });
      var index_str = "this.offset+" + indices.map(function(i2) {
        return "this.stride[" + i2 + "]*i" + i2;
      }).join("+");
      var shapeArg = indices.map(function(i2) {
        return "b" + i2;
      }).join(",");
      var strideArg = indices.map(function(i2) {
        return "c" + i2;
      }).join(",");
      code.push(
        "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
        "this.shape=[" + shapeArg + "]",
        "this.stride=[" + strideArg + "]",
        "this.offset=d|0}",
        "var proto=" + className + ".prototype",
        "proto.dtype='" + dtype + "'",
        "proto.dimension=" + dimension
      );
      code.push(
        "Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i2) {
          return "this.shape[" + i2 + "]";
        }).join("*"),
        "}})"
      );
      if (dimension === 1) {
        code.push("proto.order=[0]");
      } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
          code.push("function " + className + "_order(){");
          if (dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
          } else if (dimension === 3) {
            code.push(
              "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
            );
          }
        } else {
          code.push("ORDER})");
        }
      }
      code.push(
        "proto.set=function " + className + "_set(" + args.join(",") + ",v){"
      );
      if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
      } else {
        code.push("return this.data[" + index_str + "]=v}");
      }
      code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
      if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
      } else {
        code.push("return this.data[" + index_str + "]}");
      }
      code.push(
        "proto.index=function " + className + "_index(",
        args.join(),
        "){return " + index_str + "}"
      );
      code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
        return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
      }).join(",") + "," + indices.map(function(i2) {
        return "this.stride[" + i2 + "]";
      }).join(",") + ",this.offset)}");
      var a_vars = indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      });
      var c_vars = indices.map(function(i2) {
        return "c" + i2 + "=this.stride[" + i2 + "]";
      });
      code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "c" + i2;
      }).join(",") + ",b)}");
      code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2 + "=this.stride[" + i2 + "]";
      }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2;
      }).join(",") + ",c)}");
      var tShape = new Array(dimension);
      var tStride = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
      }
      code.push(
        "proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
          return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
        }).join(";"),
        "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"
      );
      code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
      code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
        return "shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "stride[" + i2 + "]";
      }).join(",") + ",offset)}");
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
      return procedure(CACHED_CONSTRUCTORS[dtype], order);
    }
    function arrayDType(data) {
      if (isBuffer(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "array": [],
      "uint8_clamped": [],
      "bigint64": [],
      "biguint64": [],
      "buffer": [],
      "generic": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var dtype = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[dtype];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module2.exports = wrappedNDArrayCtor;
  }
});

// node_modules/onnxruntime-web/dist/ort.min.js
var require_ort_min = __commonJS({
  "node_modules/onnxruntime-web/dist/ort.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.ort = t() : e.ort = t();
    }(self, () => (() => {
      var __webpack_modules__ = { 5716: (e, t, n) => {
        "use strict";
        t.R = void 0;
        const r = n(6027), o = n(1723);
        t.R = new class {
          async init() {
          }
          async createSessionHandler(e2, t2) {
            const n2 = new r.Session(t2);
            return await n2.loadModel(e2), new o.OnnxjsSessionHandler(n2);
          }
        }();
      }, 2818: (e, t, n) => {
        "use strict";
        t.c8 = t.rX = void 0;
        const r = n(2235), o = n(5381), i = n(9544), a = n(6640);
        t.rX = () => {
          if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
            const e2 = "undefined" == typeof navigator ? (0, o.cpus)().length : navigator.hardwareConcurrency;
            r.env.wasm.numThreads = Math.min(4, Math.ceil((e2 || 1) / 2));
          }
        }, t.c8 = new class {
          async init() {
            (0, t.rX)(), await (0, i.initializeWebAssemblyInstance)();
          }
          async createSessionHandler(e2, t2) {
            const n2 = new a.OnnxruntimeWebAssemblySessionHandler();
            return await n2.loadModel(e2, t2), Promise.resolve(n2);
          }
        }();
      }, 1057: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__exportStar || function(e2, t2) {
          for (var n2 in e2)
            "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e2, n2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), o(n(2235), t);
        const i = n(2235), a = n(8408);
        {
          const e2 = n(5716).R;
          (0, i.registerBackend)("webgl", e2, -10);
        }
        {
          const e2 = n(2818).c8;
          (0, i.registerBackend)("cpu", e2, 10), (0, i.registerBackend)("wasm", e2, 10), (0, i.registerBackend)("xnnpack", e2, 9), (0, i.registerBackend)("webnn", e2, 9);
        }
        i.env.versions.web = a.version;
      }, 4910: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createAttributeWithCacheKey = void 0;
        class n {
          constructor(e2) {
            Object.assign(this, e2);
          }
          get cacheKey() {
            return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((e2) => `${this[e2]}`).join(";")), this._cacheKey;
          }
        }
        t.createAttributeWithCacheKey = (e2) => new n(e2);
      }, 6874: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Attribute = void 0;
        const r = n(5127), o = n(2446), i = n(9240), a = n(7273);
        var s = r.onnxruntime.experimental.fbs;
        class u {
          constructor(e2) {
            if (this._attributes = /* @__PURE__ */ new Map(), null != e2) {
              for (const t2 of e2)
                t2 instanceof o.onnx.AttributeProto ? this._attributes.set(t2.name, [u.getValue(t2), u.getType(t2)]) : t2 instanceof s.Attribute && this._attributes.set(t2.name(), [u.getValue(t2), u.getType(t2)]);
              if (this._attributes.size < e2.length)
                throw new Error("duplicated attribute names");
            }
          }
          set(e2, t2, n2) {
            this._attributes.set(e2, [n2, t2]);
          }
          delete(e2) {
            this._attributes.delete(e2);
          }
          getFloat(e2, t2) {
            return this.get(e2, "float", t2);
          }
          getInt(e2, t2) {
            return this.get(e2, "int", t2);
          }
          getString(e2, t2) {
            return this.get(e2, "string", t2);
          }
          getTensor(e2, t2) {
            return this.get(e2, "tensor", t2);
          }
          getFloats(e2, t2) {
            return this.get(e2, "floats", t2);
          }
          getInts(e2, t2) {
            return this.get(e2, "ints", t2);
          }
          getStrings(e2, t2) {
            return this.get(e2, "strings", t2);
          }
          getTensors(e2, t2) {
            return this.get(e2, "tensors", t2);
          }
          get(e2, t2, n2) {
            const r2 = this._attributes.get(e2);
            if (void 0 === r2) {
              if (void 0 !== n2)
                return n2;
              throw new Error(`required attribute not found: ${e2}`);
            }
            if (r2[1] !== t2)
              throw new Error(`type mismatch: expected ${t2} but got ${r2[1]}`);
            return r2[0];
          }
          static getType(e2) {
            const t2 = e2 instanceof o.onnx.AttributeProto ? e2.type : e2.type();
            switch (t2) {
              case o.onnx.AttributeProto.AttributeType.FLOAT:
                return "float";
              case o.onnx.AttributeProto.AttributeType.INT:
                return "int";
              case o.onnx.AttributeProto.AttributeType.STRING:
                return "string";
              case o.onnx.AttributeProto.AttributeType.TENSOR:
                return "tensor";
              case o.onnx.AttributeProto.AttributeType.FLOATS:
                return "floats";
              case o.onnx.AttributeProto.AttributeType.INTS:
                return "ints";
              case o.onnx.AttributeProto.AttributeType.STRINGS:
                return "strings";
              case o.onnx.AttributeProto.AttributeType.TENSORS:
                return "tensors";
              default:
                throw new Error(`attribute type is not supported yet: ${o.onnx.AttributeProto.AttributeType[t2]}`);
            }
          }
          static getValue(e2) {
            const t2 = e2 instanceof o.onnx.AttributeProto ? e2.type : e2.type();
            if (t2 === o.onnx.AttributeProto.AttributeType.GRAPH || t2 === o.onnx.AttributeProto.AttributeType.GRAPHS)
              throw new Error("graph attribute is not supported yet");
            const n2 = this.getValueNoCheck(e2);
            if (t2 === o.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n2))
              return a.LongUtil.longToNumber(n2);
            if (t2 === o.onnx.AttributeProto.AttributeType.INTS) {
              const e3 = n2, t3 = new Array(e3.length);
              for (let n3 = 0; n3 < e3.length; n3++) {
                const r2 = e3[n3];
                t3[n3] = a.LongUtil.longToNumber(r2);
              }
              return t3;
            }
            if (t2 === o.onnx.AttributeProto.AttributeType.TENSOR)
              return e2 instanceof o.onnx.AttributeProto ? i.Tensor.fromProto(n2) : i.Tensor.fromOrtTensor(n2);
            if (t2 === o.onnx.AttributeProto.AttributeType.TENSORS) {
              if (e2 instanceof o.onnx.AttributeProto)
                return n2.map((e3) => i.Tensor.fromProto(e3));
              if (e2 instanceof s.Attribute)
                return n2.map((e3) => i.Tensor.fromOrtTensor(e3));
            }
            if (t2 === o.onnx.AttributeProto.AttributeType.STRING && e2 instanceof o.onnx.AttributeProto) {
              const e3 = n2;
              return (0, a.decodeUtf8String)(e3);
            }
            return t2 === o.onnx.AttributeProto.AttributeType.STRINGS && e2 instanceof o.onnx.AttributeProto ? n2.map(a.decodeUtf8String) : n2;
          }
          static getValueNoCheck(e2) {
            return e2 instanceof o.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e2) : this.getValueNoCheckFromOrtFormat(e2);
          }
          static getValueNoCheckFromOnnxFormat(e2) {
            switch (e2.type) {
              case o.onnx.AttributeProto.AttributeType.FLOAT:
                return e2.f;
              case o.onnx.AttributeProto.AttributeType.INT:
                return e2.i;
              case o.onnx.AttributeProto.AttributeType.STRING:
                return e2.s;
              case o.onnx.AttributeProto.AttributeType.TENSOR:
                return e2.t;
              case o.onnx.AttributeProto.AttributeType.GRAPH:
                return e2.g;
              case o.onnx.AttributeProto.AttributeType.FLOATS:
                return e2.floats;
              case o.onnx.AttributeProto.AttributeType.INTS:
                return e2.ints;
              case o.onnx.AttributeProto.AttributeType.STRINGS:
                return e2.strings;
              case o.onnx.AttributeProto.AttributeType.TENSORS:
                return e2.tensors;
              case o.onnx.AttributeProto.AttributeType.GRAPHS:
                return e2.graphs;
              default:
                throw new Error(`unsupported attribute type: ${o.onnx.AttributeProto.AttributeType[e2.type]}`);
            }
          }
          static getValueNoCheckFromOrtFormat(e2) {
            switch (e2.type()) {
              case s.AttributeType.FLOAT:
                return e2.f();
              case s.AttributeType.INT:
                return e2.i();
              case s.AttributeType.STRING:
                return e2.s();
              case s.AttributeType.TENSOR:
                return e2.t();
              case s.AttributeType.GRAPH:
                return e2.g();
              case s.AttributeType.FLOATS:
                return e2.floatsArray();
              case s.AttributeType.INTS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.intsLength(); n2++)
                  t2.push(e2.ints(n2));
                return t2;
              }
              case s.AttributeType.STRINGS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.stringsLength(); n2++)
                  t2.push(e2.strings(n2));
                return t2;
              }
              case s.AttributeType.TENSORS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.tensorsLength(); n2++)
                  t2.push(e2.tensors(n2));
                return t2;
              }
              default:
                throw new Error(`unsupported attribute type: ${s.AttributeType[e2.type()]}`);
            }
          }
        }
        t.Attribute = u;
      }, 1975: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.backend = void 0;
        const r = n(4418), o = /* @__PURE__ */ new Map();
        async function i(e2) {
          const n2 = t.backend;
          if (void 0 !== n2[e2] && function(e3) {
            const t2 = e3;
            return "initialize" in t2 && "function" == typeof t2.initialize && "createSessionHandler" in t2 && "function" == typeof t2.createSessionHandler && "dispose" in t2 && "function" == typeof t2.dispose;
          }(n2[e2])) {
            const t2 = n2[e2];
            let r2 = t2.initialize();
            if ("object" == typeof r2 && "then" in r2 && (r2 = await r2), r2)
              return o.set(e2, t2), t2;
          }
        }
        t.backend = { webgl: new r.WebGLBackend() }, t.resolveBackend = async function e2(t2) {
          if (!t2)
            return e2(["webgl"]);
          {
            const e3 = "string" == typeof t2 ? [t2] : t2;
            for (const t3 of e3) {
              const e4 = o.get(t3);
              if (e4)
                return e4;
              const n2 = await i(t3);
              if (n2)
                return n2;
            }
          }
          throw new Error("no available backend to use");
        };
      }, 4418: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLBackend = void 0;
        const r = n(2235), o = n(1315), i = n(2171), a = n(3389);
        t.WebGLBackend = class {
          get contextId() {
            return r.env.webgl.contextId;
          }
          set contextId(e2) {
            r.env.webgl.contextId = e2;
          }
          get matmulMaxBatchSize() {
            return r.env.webgl.matmulMaxBatchSize;
          }
          set matmulMaxBatchSize(e2) {
            r.env.webgl.matmulMaxBatchSize = e2;
          }
          get textureCacheMode() {
            return r.env.webgl.textureCacheMode;
          }
          set textureCacheMode(e2) {
            r.env.webgl.textureCacheMode = e2;
          }
          get pack() {
            return r.env.webgl.pack;
          }
          set pack(e2) {
            r.env.webgl.pack = e2;
          }
          get async() {
            return r.env.webgl.async;
          }
          set async(e2) {
            r.env.webgl.async = e2;
          }
          initialize() {
            try {
              return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), o.Logger.setWithEnv(r.env), o.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
            } catch (e2) {
              return o.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e2}`), false;
            }
          }
          createSessionHandler(e2) {
            return new i.WebGLSessionHandler(this, e2);
          }
          dispose() {
            this.glContext.dispose();
          }
        };
      }, 6859: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.CoordsGlslLib = void 0;
        const r = n(7273), o = n(1997), i = n(6757), a = n(7618), s = n(432);
        class u extends o.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
          }
          getCustomTypes() {
            return {};
          }
          offsetToCoords() {
            return { offsetToCoords: new o.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
          }
          coordsToOffset() {
            return { coordsToOffset: new o.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
          }
          getOutputSamplingSnippet() {
            const e2 = this.context.outputTextureLayout;
            return e2.isPacked ? this.getPackedOutputSamplingSnippet(e2) : this.getUnpackedOutputSamplingSnippet(e2);
          }
          getPackedOutputSamplingSnippet(e2) {
            const t2 = e2.unpackedShape, n2 = [e2.width, e2.height], r2 = {}, a2 = "getOutputCoords";
            switch (t2.length) {
              case 0:
                r2[a2] = this.getOutputScalarCoords();
                break;
              case 1:
                r2[a2] = this.getOutputPacked1DCoords(t2, n2);
                break;
              case 2:
                r2[a2] = this.getOutputPacked2DCoords(t2, n2);
                break;
              case 3:
                r2[a2] = this.getOutputPacked3DCoords(t2, n2);
                break;
              default:
                r2[a2] = this.getOutputPackedNDCoords(t2, n2);
            }
            const s2 = `
      void setOutput(vec4 val) {
        ${(0, i.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
            return r2.floatTextureSetRGBA = new o.GlslLibRoutine(s2), r2;
          }
          getUnpackedOutputSamplingSnippet(e2) {
            const t2 = e2.unpackedShape, n2 = [e2.width, e2.height], r2 = {}, a2 = "getOutputCoords";
            switch (t2.length) {
              case 0:
                r2[a2] = this.getOutputScalarCoords();
                break;
              case 1:
                r2[a2] = this.getOutputUnpacked1DCoords(t2, n2);
                break;
              case 2:
                r2[a2] = this.getOutputUnpacked2DCoords(t2, n2);
                break;
              case 3:
                r2[a2] = this.getOutputUnpacked3DCoords(t2, n2);
                break;
              case 4:
                r2[a2] = this.getOutputUnpacked4DCoords(t2, n2);
                break;
              case 5:
                r2[a2] = this.getOutputUnpacked5DCoords(t2, n2);
                break;
              case 6:
                r2[a2] = this.getOutputUnpacked6DCoords(t2, n2);
                break;
              default:
                throw new Error(`Unsupported output dimensionality: ${t2.length}`);
            }
            const s2 = `
        void setOutput(float val) {
          ${(0, i.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
            return r2.floatTextureSetR = new o.GlslLibRoutine(s2), r2;
          }
          getOutputScalarCoords() {
            return new o.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
          }
          getOutputPacked1DCoords(e2, t2) {
            const n2 = t2;
            let r2 = "";
            return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new o.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new o.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new o.GlslLibRoutine(r2));
          }
          getOutputPacked2DCoords(e2, t2) {
            let n2 = "";
            if (r.ArrayUtil.arraysEqual(e2, t2))
              return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t2[0]}, ${t2[1]}));
        }
      `, new o.GlslLibRoutine(n2);
            const i2 = t2, a2 = Math.ceil(e2[1] / 2);
            return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i2[0]}, ${i2[1]}));

          int index = resTexRC.y * ${i2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputPacked3DCoords(e2, t2) {
            const n2 = [t2[0], t2[1]], r2 = Math.ceil(e2[2] / 2), i2 = r2 * Math.ceil(e2[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${i2};
          index -= b * ${i2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
            return new o.GlslLibRoutine(a2);
          }
          getOutputPackedNDCoords(e2, t2) {
            const n2 = [t2[0], t2[1]], r2 = Math.ceil(e2[e2.length - 1] / 2), i2 = r2 * Math.ceil(e2[e2.length - 2] / 2);
            let a2 = i2, s2 = "", u2 = "b, r, c";
            for (let t3 = 2; t3 < e2.length - 1; t3++)
              a2 *= e2[e2.length - t3 - 1], s2 = `
      int b${t3} = index / ${a2};
      index -= b${t3} * ${a2};
    ` + s2, u2 = `b${t3}, ` + u2;
            const l = `
      ivec${e2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${s2}

        int b = index / ${i2};
        index -= b * ${i2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${e2.length}(${u2});
      }
    `;
            return new o.GlslLibRoutine(l);
          }
          getOutputUnpacked1DCoords(e2, t2) {
            const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          return resTexRC.y * ${t2[0]} + resTexRC.x;
        }
      `;
            return new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked2DCoords(e2, t2) {
            const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          int r = index / ${e2[1]};
          int c = index - r * ${e2[1]};
          return ivec2(r, c);
        }
      `;
            return new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked3DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked4DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked5DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2", "d3"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked6DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t2[0]}, ${t2[1]}));
         int index = resTexRC.y * ${t2[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new o.GlslLibRoutine(n2);
          }
          getCommonUtilFuncs() {
            const e2 = {};
            let t2 = "uvFromFlat";
            e2[t2] = new o.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), t2 = "packedUVfrom1D", e2[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom2D", e2[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom3D", e2[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "sampleTexture";
            const n2 = (0, i.getGlsl)(this.context.glContext.version);
            return e2[t2] = new o.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), e2;
          }
          getInputsSamplingSnippets() {
            const e2 = {}, t2 = this.context.outputTextureLayout;
            return this.context.programInfo.inputNames.forEach((n2, r2) => {
              const o2 = this.context.inputTextureLayouts[r2], i2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n2);
              o2.isPacked ? e2[i2] = this.getPackedSamplerFromInput(i2, n2, o2) : e2[i2] = this.getUnpackedSamplerFromInput(i2, n2, o2);
              const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
              o2.unpackedShape.length <= t2.unpackedShape.length && (o2.isPacked ? e2[a2] = this.getPackedSamplerAtOutputCoords(a2, o2, t2, n2) : e2[a2] = this.getUnpackedSamplerAtOutputCoords(a2, o2, t2, n2));
            }), e2;
          }
          getPackedSamplerAtOutputCoords(e2, t2, n2, i2) {
            const a2 = t2.unpackedShape, u2 = n2.unpackedShape, l = i2, c = (0, s.generateShaderFuncNameFromInputSamplerName)(l), p = a2.length, d = u2.length, f = r.BroadcastUtil.getBroadcastDims(a2, u2), h = (0, s.getCoordsDataType)(d), g = d - p;
            let b;
            const m = (0, s.getGlChannels)();
            b = 0 === p ? "" : d < 2 && f.length >= 1 ? "coords = 0;" : f.map((e3) => `coords.${m[e3 + g]} = 0;`).join("\n");
            let y = "";
            y = d < 2 && p > 0 ? "coords" : a2.map((e3, t3) => `coords.${m[t3 + g]}`).join(", ");
            let v = "return outputValue;";
            const _ = 1 === r.ShapeUtil.size(a2), w = 1 === r.ShapeUtil.size(u2);
            if (1 !== p || _ || w) {
              if (_ && !w)
                v = 1 === d ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
              else if (f.length) {
                const e3 = p - 2, t3 = p - 1;
                f.indexOf(e3) > -1 && f.indexOf(t3) > -1 ? v = "return vec4(outputValue.x);" : f.indexOf(e3) > -1 ? v = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : f.indexOf(t3) > -1 && (v = "return vec4(outputValue.xx, outputValue.zz);");
              }
            } else
              v = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
            const T = `
      vec4 ${e2}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${m[d - 1]};
        coords.${m[d - 1]} = coords.${m[d - 2]};
        coords.${m[d - 2]} = lastDim;
      
        ${b}
        vec4 outputValue = ${c}(${y});
        ${v}
      }
    `;
            return new o.GlslLibRoutine(T, ["coordinates.getOutputCoords"]);
          }
          getUnpackedSamplerAtOutputCoords(e2, t2, n2, i2) {
            const a2 = [n2.width, n2.height], u2 = [t2.width, t2.height], l = t2.unpackedShape.length, c = n2.unpackedShape.length, p = t2.unpackedShape, d = n2.unpackedShape, f = (0, s.generateShaderFuncNameFromInputSamplerName)(i2);
            if (l === c && r.ArrayUtil.arraysEqual(u2, a2)) {
              const t3 = `
          float ${e2}() {
            return sampleTexture(${i2}, TexCoords);
          }
        `;
              return new o.GlslLibRoutine(t3, ["coordinates.sampleTexture"]);
            }
            const h = (0, s.getCoordsDataType)(c), g = r.BroadcastUtil.getBroadcastDims(p, d), b = c - l;
            let m;
            const y = (0, s.getGlChannels)();
            m = 0 === l ? "" : c < 2 && g.length >= 1 ? "coords = 0;" : g.map((e3) => `coords.${y[e3 + b]} = 0;`).join("\n");
            let v = "";
            v = c < 2 && l > 0 ? "coords" : t2.unpackedShape.map((e3, t3) => `coords.${y[t3 + b]}`).join(", ");
            const _ = `
        float ${e2}() {
          ${h} coords = getOutputCoords();
          ${m}
          return ${f}(${v});
        }
      `;
            return new o.GlslLibRoutine(_, ["coordinates.getOutputCoords"]);
          }
          getPackedSamplerFromInput(e2, t2, n2) {
            switch (n2.unpackedShape.length) {
              case 0:
                return this.getPackedSamplerScalar(e2, t2);
              case 1:
                return this.getPackedSampler1D(e2, t2, n2);
              case 2:
                return this.getPackedSampler2D(e2, t2, n2);
              case 3:
                return this.getPackedSampler3D(e2, t2, n2);
              default:
                return this.getPackedSamplerND(e2, t2, n2);
            }
          }
          getUnpackedSamplerFromInput(e2, t2, n2) {
            const r2 = n2.unpackedShape;
            switch (r2.length) {
              case 0:
                return this.getUnpackedSamplerScalar(e2, t2, n2);
              case 1:
                return this.getUnpackedSampler1D(e2, t2, n2);
              case 2:
                return this.getUnpackedSampler2D(e2, t2, n2);
              case 3:
                return this.getUnpackedSampler3D(e2, t2, n2);
              case 4:
                return this.getUnpackedSampler4D(e2, t2, n2);
              case 5:
                return this.getUnpackedSampler5D(e2, t2, n2);
              case 6:
                return this.getUnpackedSampler6D(e2, t2, n2);
              default:
                throw new Error(`Unsupported dimension ${r2.length}-D`);
            }
          }
          getPackedSamplerScalar(e2, t2) {
            const n2 = `
          vec4 ${e2}() {
            return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${t2}, halfCR);
          }
        `;
            return new o.GlslLibRoutine(n2);
          }
          getPackedSampler1D(e2, t2, n2) {
            const r2 = [n2.width, n2.height], a2 = [r2[1], r2[0]], s2 = (0, i.getGlsl)(this.context.glContext.version), u2 = `vec4 ${e2}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${t2}, uv);
    }`;
            return new o.GlslLibRoutine(u2, ["coordinates.packedUVfrom1D"]);
          }
          getPackedSampler2D(e2, t2, n2) {
            const a2 = n2.unpackedShape, s2 = [n2.width, n2.height], u2 = (0, i.getGlsl)(this.context.glContext.version), l = s2[0], c = s2[1];
            if (null != s2 && r.ArrayUtil.arraysEqual(a2, s2)) {
              const n3 = `vec4 ${e2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);
        return ${u2.texture2D}(${t2}, uv);
      }`;
              return new o.GlslLibRoutine(n3);
            }
            const p = s2, d = Math.ceil(a2[1] / 2), f = `vec4 ${e2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);
      return ${u2.texture2D}(${t2}, uv);
    }`;
            return new o.GlslLibRoutine(f, ["coordinates.packedUVfrom2D"]);
          }
          getPackedSampler3D(e2, t2, n2) {
            const r2 = n2.unpackedShape, a2 = [n2.width, n2.height], u2 = [a2[0], a2[1]], l = (0, i.getGlsl)(this.context.glContext.version);
            if (1 === r2[0]) {
              const i2 = r2.slice(1), a3 = [1, 2], u3 = (0, s.squeezeInputShape)(r2, i2), l2 = ["b", "row", "col"], c2 = JSON.parse(JSON.stringify(n2));
              c2.unpackedShape = u3;
              const p2 = this.getPackedSamplerFromInput(e2, t2, c2), d2 = `${p2.routineBody}
      vec4 ${e2}(int b, int row, int col) {
        return ${e2}(${(0, s.getSqueezedParams)(l2, a3)});
      } `;
              return new o.GlslLibRoutine(d2, p2.dependencies);
            }
            const c = u2[0], p = u2[1], d = Math.ceil(r2[2] / 2), f = `vec4 ${e2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${c}, ${d * Math.ceil(r2[1] / 2)}, ${d}, b, row, col);
      return ${l.texture2D}(${t2}, uv);}`;
            return new o.GlslLibRoutine(f, ["coordinates.packedUVfrom3D"]);
          }
          getPackedSamplerND(e2, t2, n2) {
            const r2 = n2.unpackedShape, a2 = r2.length, s2 = [n2.width, n2.height], u2 = (0, i.getGlsl)(this.context.glContext.version), l = [s2[0], s2[1]], c = l[1], p = l[0], d = Math.ceil(r2[a2 - 1] / 2);
            let f = d * Math.ceil(r2[a2 - 2] / 2), h = "int b, int row, int col", g = `b * ${f} + (row / 2) * ${d} + (col / 2)`;
            for (let e3 = 2; e3 < a2 - 1; e3++)
              h = `int b${e3}, ` + h, f *= r2[a2 - e3 - 1], g = `b${e3} * ${f} + ` + g;
            const b = `vec4 ${e2}(${h}) {
      int index = ${g};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});
      return ${u2.texture2D}(${t2}, uv);
    }`;
            return new o.GlslLibRoutine(b);
          }
          getUnpackedSamplerScalar(e2, t2, n2) {
            const [r2, i2] = [n2.width, n2.height];
            if (1 === r2 && 1 === i2) {
              const n3 = `
          float ${e2}() {
            return sampleTexture(${t2}, halfCR);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const a2 = `
        float ${e2}() {
          int offset_${t2} = coordsToOffset(TexCoords, ${r2}, ${i2});
          vec2 uv = uvFromFlat(${r2}, ${i2}, offset_${t2});
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler1D(e2, t2, n2) {
            const r2 = n2.width, i2 = n2.height;
            if (1 === i2 && 1 === r2) {
              const n3 = `
        float ${e2}(int index) {
          return sampleTexture(${t2}, halfCR);
        }
      `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            if (1 === i2) {
              const n3 = `
          float ${e2}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            if (1 === r2) {
              const n3 = `
          float ${e2}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i2}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const a2 = `
        float ${e2}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${i2}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler2D(e2, t2, n2) {
            const i2 = n2.unpackedShape, u2 = [n2.height, n2.width];
            if (null != u2 && r.ArrayUtil.arraysEqual(i2, u2)) {
              const n3 = `
          float ${e2}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u2[1]}.0, ${u2[0]}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const { newShape: l, keptDims: c } = (0, a.squeezeShape)(i2), p = l;
            if (p.length < i2.length) {
              const r2 = (0, s.squeezeInputShape)(i2, p), a2 = JSON.parse(JSON.stringify(n2));
              a2.unpackedShape = r2;
              const u3 = ["col", "row"], l2 = `
          ${this.getUnpackedSamplerFromInput(e2, t2, a2).routineBody}
          float ${e2}(int row, int col) {
            return ${e2}(${(0, s.getSqueezedParams)(u3, c)});
          }
        `;
              return new o.GlslLibRoutine(l2, ["coordinates.sampleTexture"]);
            }
            const d = u2[1], f = u2[0];
            if (1 === f) {
              const n3 = `
          float ${e2}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${i2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            if (1 === d) {
              const n3 = `
          float ${e2}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${i2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            const h = `
        float ${e2}(int row, int col) {
          int index = col * ${i2[1]} + row;
          vec2 uv = uvFromFlat(${d}, ${f}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler3D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[1] * r2[2], u2 = r2[2], { newShape: l, keptDims: c } = (0, a.squeezeShape)(r2), p = l;
            if (p.length < r2.length) {
              const i3 = (0, s.squeezeInputShape)(r2, p), a2 = ["batch", "col", "row"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = i3;
              const l2 = this.getUnpackedSamplerFromInput(e2, t2, u3), d2 = c.reverse(), f = `
          ${l2.routineBody}
          float ${e2}(int batch, int row, int col) {
            return ${e2}(${(0, s.getSqueezedParams)(a2, d2)});
          }
        `;
              return new o.GlslLibRoutine(f, l2.dependencies);
            }
            const d = `
          float ${e2}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${i2} + col * ${u2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
      `;
            return new o.GlslLibRoutine(d, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler4D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[3], a2 = r2[2] * i2, s2 = `
        float ${e2}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * a2} + col * ${a2} +
              depth2 * ${i2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler5D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[4], u2 = r2[3] * i2, l = r2[2] * u2, c = r2[1] * l, { newShape: p, keptDims: d } = (0, a.squeezeShape)(r2);
            if (p.length < r2.length) {
              const i3 = (0, s.squeezeInputShape)(r2, p), a2 = ["row", "col", "depth", "depth2", "depth3"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = i3;
              const l2 = `
          ${this.getUnpackedSamplerFromInput(e2, t2, u3).routineBody}
          float ${e2}(int row, int col, int depth, int depth2, int depth3) {
            return ${e2}(${(0, s.getSqueezedParams)(a2, d)});
          }
        `;
              return new o.GlslLibRoutine(l2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            const f = `
        float ${e2}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${c} + col * ${l} + depth * ${u2} +
          depth3 * ${i2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(f, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          getUnpackedSampler6D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[5], u2 = r2[4] * i2, l = r2[3] * u2, c = r2[2] * l, p = r2[1] * c, { newShape: d, keptDims: f } = (0, a.squeezeShape)(r2);
            if (d.length < r2.length) {
              const i3 = (0, s.squeezeInputShape)(r2, d), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = i3;
              const l2 = `
            ${this.getUnpackedSamplerFromInput(e2, t2, u3).routineBody}
            float ${e2}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e2}(${(0, s.getSqueezedParams)(a2, f)});
            }
          `;
              return new o.GlslLibRoutine(l2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            const h = `
          float ${e2}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${c} + depth * ${l} +
            depth2 * ${u2} + depth3 * ${i2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
        `;
            return new o.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          toVec() {
            const e2 = this.context.outputTextureLayout, t2 = e2.shape.length, n2 = e2.strides, r2 = e2.width, i2 = e2.height, a2 = [];
            for (let e3 = 0; e3 < t2 - 1; ++e3)
              a2.push(`
        c[${e3}] = offset / ${n2[e3]};`), a2.push(`
        offset -= c[${e3}] * ${n2[e3]};`);
            a2.push(`
        c[${t2 - 1}] = offset;`);
            const s2 = `
      void toVec(vec2 texCoords, out int c[${t2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${i2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${t2}]) {
        ${a2.join("")}
      }
    `;
            return { toVec: new o.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
          }
          valueFrom() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const r2 = this.context.inputTextureLayouts[n2], i2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
              let a2 = `_${t2}`;
              e2[a2] = new o.GlslLibRoutine(this.getValueFromSingle(t2, i2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", e2[a2] = new o.GlslLibRoutine(this.getValueFromSingle(t2, i2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
            }), e2;
          }
          getValueFromSingle(e2, t2, n2, r2, o2) {
            let a2 = `_${e2}`;
            return o2 && (a2 += "_T"), `
        float ${a2}(int m[${t2}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e2}, coords));
          return value;
        }
        `;
          }
          getPackedValueFrom(e2, t2, n2, r2, o2) {
            let a2 = `_${e2}_Pack`;
            return o2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${t2}]) {
          int offset = indicesToOffset_${e2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e2}, coords);
        }
        `;
          }
        }
        t.CoordsGlslLib = u;
      }, 1997: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.TopologicalSortGlslRoutines = t.GlslLibRoutineNode = t.GlslLibRoutine = t.GlslLib = t.GlslContext = t.FunctionType = void 0, (n = t.FunctionType || (t.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", t.GlslContext = class {
          constructor(e2, t2, n2, r) {
            this.glContext = e2, this.programInfo = t2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
          }
        }, t.GlslLib = class {
          constructor(e2) {
            this.context = e2;
          }
        }, t.GlslLibRoutine = class {
          constructor(e2, t2) {
            this.routineBody = e2, this.dependencies = t2;
          }
        }, t.GlslLibRoutineNode = class {
          constructor(e2, t2, n2) {
            this.name = e2, this.dependencies = n2 || [], t2 && (this.routineBody = t2);
          }
          addDependency(e2) {
            e2 && this.dependencies.push(e2);
          }
        }, t.TopologicalSortGlslRoutines = class {
          static returnOrderedNodes(e2) {
            if (!e2 || 0 === e2.length)
              return [];
            if (1 === e2.length)
              return e2;
            const t2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
            return this.createOrderedNodes(e2, t2, n2, r), r;
          }
          static createOrderedNodes(e2, t2, n2, r) {
            for (let o = 0; o < e2.length; ++o)
              this.dfsTraverse(e2[o], t2, n2, r);
          }
          static dfsTraverse(e2, t2, n2, r) {
            if (!e2 || n2.has(e2.name))
              return;
            if (t2.has(e2.name))
              throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
            t2.add(e2.name);
            const o = e2.dependencies;
            if (o && o.length > 0)
              for (let e3 = 0; e3 < o.length; ++e3)
                this.dfsTraverse(o[e3], t2, n2, r);
            r.push(e2), n2.add(e2.name), t2.delete(e2.name);
          }
        };
      }, 1371: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.EncodingGlslLib = void 0;
        const r = n(1997);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
          }
          getCustomTypes() {
            return {};
          }
          encodeFloat32() {
            return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
          }
          decodeFloat32() {
            return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
          }
          encodeUint8() {
            const e2 = o.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e2}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
          }
          decodeUint8() {
            const e2 = o.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e2}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
          }
          static isLittleEndian() {
            const e2 = new ArrayBuffer(4), t2 = new Uint32Array(e2), n2 = new Uint8Array(e2);
            if (t2[0] = 3735928559, 239 === n2[0])
              return true;
            if (222 === n2[0])
              return false;
            throw new Error("unknown endianness");
          }
        }
        t.EncodingGlslLib = o;
      }, 2691: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FragColorGlslLib = void 0;
        const r = n(1997), o = n(6757);
        class i extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
          }
          getCustomTypes() {
            return {};
          }
          setFragColor() {
            const e2 = (0, o.getGlsl)(this.context.glContext.version);
            return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${e2.output} = encode(value);
        }
        `, ["encoding.encode"]) };
          }
          getColorAsFloat() {
            return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
          }
        }
        t.FragColorGlslLib = i;
      }, 3878: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.replaceInlines = void 0;
        const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
        t.replaceInlines = function(e2) {
          const t2 = {};
          let r;
          for (; null !== (r = n.exec(e2)); ) {
            const e3 = r[3].split(",").map((e4) => {
              const t3 = e4.trim().split(" ");
              return t3 && 2 === t3.length ? { type: t3[0], name: t3[1] } : null;
            }).filter((e4) => null !== e4);
            t2[r[2]] = { params: e3, body: r[4] };
          }
          for (const n2 in t2) {
            const o = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), i = new RegExp(o, "gm");
            for (; null !== (r = i.exec(e2)); ) {
              const o2 = r[1], i2 = r[2], a = r[3].split(","), s = o2 ? `${o2} ${i2};` : "";
              let u = t2[n2].body, l = "";
              t2[n2].params.forEach((e3, t3) => {
                e3 && (l += `${e3.type} ${e3.name} = ${a[t3]};
`);
              }), u = `${l}
 ${u}`, u = u.replace("return", `${i2} = `);
              const c = `
      ${s}
      {
        ${u}
      }
      `;
              e2 = e2.replace(r[0], c);
            }
          }
          return e2.replace(n, "");
        };
      }, 8897: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.GlslPreprocessor = void 0;
        const r = n(1997), o = n(3878), i = n(1248), a = n(6757);
        t.GlslPreprocessor = class {
          constructor(e2, t2, n2, o2) {
            this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(e2, t2, n2, o2), Object.keys(i.glslRegistry).forEach((e3) => {
              const t3 = new i.glslRegistry[e3](this.context);
              this.libs[e3] = t3;
            });
            const a2 = this.glslLibRoutineDependencyGraph;
            for (const e3 in this.libs) {
              const t3 = this.libs[e3].getFunctions();
              for (const n3 in t3) {
                const o3 = e3 + "." + n3;
                let i2;
                a2[o3] ? (i2 = a2[o3], i2.routineBody = t3[n3].routineBody) : (i2 = new r.GlslLibRoutineNode(o3, t3[n3].routineBody), a2[o3] = i2);
                const s = t3[n3].dependencies;
                if (s)
                  for (let e4 = 0; e4 < s.length; ++e4)
                    if (a2[s[e4]])
                      i2.addDependency(a2[s[e4]]);
                    else {
                      const t4 = new r.GlslLibRoutineNode(s[e4]);
                      a2[s[e4]] = t4, i2.addDependency(t4);
                    }
              }
            }
          }
          preprocess() {
            const e2 = this.context.programInfo;
            let t2 = e2.shaderSource;
            return this.context.programInfo.hasMain || (t2 = `${t2}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t2 = (0, o.replaceInlines)(t2), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(e2.inputNames, e2.variables)}
    ${this.getImports(t2)}
    ${t2}`;
          }
          getImports(e2) {
            const t2 = this.selectGlslLibRoutinesToBeIncluded(e2);
            if (0 === t2.length)
              return "";
            let n2 = "";
            for (let e3 = 0; e3 < t2.length; ++e3) {
              if (!t2[e3].routineBody)
                throw new Error(`Missing body for the Glsl Library routine: ${t2[e3].name}`);
              n2 += t2[e3].routineBody + "\n";
            }
            return n2;
          }
          selectGlslLibRoutinesToBeIncluded(e2) {
            const t2 = [];
            return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n2) => {
              const r2 = n2.split(".")[1];
              -1 !== e2.indexOf(r2) && t2.push(this.glslLibRoutineDependencyGraph[n2]);
            }), r.TopologicalSortGlslRoutines.returnOrderedNodes(t2);
          }
          getUniforms(e2, t2) {
            const n2 = [];
            if (e2)
              for (const t3 of e2)
                n2.push(`uniform sampler2D ${t3};`);
            if (t2)
              for (const e3 of t2)
                n2.push(`uniform ${e3.type} ${e3.name}${e3.arrayLength ? `[${e3.arrayLength}]` : ""};`);
            return n2.join("\n");
          }
        };
      }, 1248: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.glslRegistry = void 0;
        const r = n(6859), o = n(1371), i = n(2691), a = n(9183), s = n(9314);
        t.glslRegistry = { encoding: o.EncodingGlslLib, fragcolor: i.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
      }, 9183: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ShapeUtilsGlslLib = void 0;
        const r = n(1997);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
          }
          getCustomTypes() {
            return {};
          }
          bcastIndex() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = {};
            return this.context.programInfo.inputNames.forEach((n2, o2) => {
              const i = this.context.inputTextureLayouts[o2].unpackedShape;
              if (i.length <= e2) {
                const o3 = i.length, a = e2 - o3, s = `bcastIndices_${n2}`;
                let u = "";
                for (let e3 = 0; e3 < o3; ++e3)
                  u += `
          realIndices[${e3}] = int( mod(float(bcastedIndices[${a + e3}]), ${i[e3]}.0) );
          `;
                const l = `
        void ${s} (int bcastedIndices[${e2}], out int realIndices[${o3}]) {
          ${u}
        }
        `;
                t2[s] = new r.GlslLibRoutine(l);
              }
            }), t2;
          }
          bcastMatmulIndex() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = {};
            return this.context.programInfo.inputNames.forEach((n2, o2) => {
              const i = this.context.inputTextureLayouts[o2].shape;
              if (!(i.length < 2 || i.length > e2)) {
                const o3 = i.length, a = e2 - o3, s = `bcastMatmulIndices_${n2}`;
                let u = "";
                for (let e3 = 0; e3 < o3 - 2; ++e3)
                  u += `
          realIndices[${e3}] = int( mod(float(bcastedIndices[${a + e3}]), ${i[e3]}.0) );
          `;
                const l = `
        void ${s}(int bcastedIndices[${e2}], out int realIndices[${o3}]) {
          ${u}
          realIndices[${o3 - 1}] = bcastedIndices[${e2 - 1}];
          realIndices[${o3 - 2}] = bcastedIndices[${e2 - 2}];
        }
        `;
                t2[s] = new r.GlslLibRoutine(l);
              }
            }), t2;
          }
          indicesToOffset() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const i = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = i.length;
              let u = `indicesToOffset_${t2}`;
              e2[u] = new r.GlslLibRoutine(o.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${t2}_T`, e2[u] = new r.GlslLibRoutine(o.indexToOffsetSingle(u, s, a.slice().reverse()));
            }), e2;
          }
          static indexToOffsetSingle(e2, t2, n2) {
            let r2 = "";
            for (let e3 = t2 - 1; e3 >= 0; --e3)
              r2 += `
        offset += indices[${e3}] * ${n2[e3]};
        `;
            return `
      int ${e2}(int indices[${t2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
          }
          offsetToIndices() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const i = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = i.length;
              let u = `offsetToIndices_${t2}`;
              e2[u] = new r.GlslLibRoutine(o.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${t2}_T`, e2[u] = new r.GlslLibRoutine(o.offsetToIndicesSingle(u, s, a.slice().reverse()));
            }), e2;
          }
          static offsetToIndicesSingle(e2, t2, n2) {
            const r2 = [];
            for (let e3 = 0; e3 < t2 - 1; ++e3)
              r2.push(`
      indices[${e3}] = offset / ${n2[e3]};`), r2.push(`
        offset -= indices[${e3}] * ${n2[e3]};`);
            return r2.push(`
      indices[${t2 - 1}] = offset;`), `
      void ${e2}(int offset, out int indices[${t2}]) {
        ${r2.join("")}
      }
      `;
          }
          incrementIndices() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const o2 = this.context.inputTextureLayouts[n2].shape, i = o2.length, a = `incrementIndices_${t2}`;
              let s = "";
              for (let e3 = 0; e3 < i; ++e3)
                s += `
        shape[${e3}] = ${o2[e3]};`;
              const u = `
        void ${a}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${s};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
              e2[a] = new r.GlslLibRoutine(u);
            }), e2;
          }
        }
        t.ShapeUtilsGlslLib = o;
      }, 6757: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getDefaultFragShaderMain = t.getFragShaderPreamble = t.getVertexShaderSource = t.getGlsl = void 0;
        const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
        function o(e2) {
          return 1 === e2 ? n : r;
        }
        t.getGlsl = o, t.getVertexShaderSource = function(e2) {
          const t2 = o(e2);
          return `${t2.version}
      precision highp float;
      ${t2.attribute} vec3 position;
      ${t2.attribute} vec2 textureCoord;

      ${t2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
        }, t.getFragShaderPreamble = function(e2) {
          const t2 = o(e2);
          return `${t2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t2.varyingFrag} vec2 TexCoords;
    ${t2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
        }, t.getDefaultFragShaderMain = function(e2, t2) {
          return `
  void main() {
    int indices[${t2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o(e2).output} = result;
  }
  `;
        };
      }, 9314: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.VecGlslLib = void 0;
        const r = n(1997);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getCustomTypes() {
            return {};
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
          }
          binaryVecFunctions() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
            for (const o2 in t2) {
              const i = `${o2}Vec`;
              let a = "";
              for (let n3 = 0; n3 < e2; ++n3)
                a += `
          dest[${n3}] ${t2[o2]} src[${n3}];
          `;
              const s = `
        void ${i}(int src[${e2}], out int dest[${e2}]) {
          ${a}
        }
        `;
              n2[i] = new r.GlslLibRoutine(s);
            }
            return n2;
          }
          copyVec() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = "";
            for (let n3 = 0; n3 < e2; ++n3)
              t2 += `
        dest[${n3}] = src[${n3}];
        `;
            const n2 = `
      void copyVec(int src[${e2}], out int dest[${e2}]) {
        ${t2}
      }
      `;
            return { copyVec: new r.GlslLibRoutine(n2) };
          }
          setVecItem() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = `
        if(index < 0)
            index =${e2} + index;
        if (index == 0)
            m[0] = value;
        `;
            for (let n3 = 1; n3 < e2 - 1; ++n3)
              t2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
            t2 += `
        else
            m[${e2 - 1}] = value;
        `;
            const n2 = `
      void setVecItem(out int m[${e2}], int index, int value) {
        ${t2}
      }
        `;
            return { setVecItem: new r.GlslLibRoutine(n2) };
          }
          getVecItem() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = `
        if(index < 0)
            index = ${e2} + index;
        if (index == 0)
            return m[0];
      `;
            for (let n3 = 1; n3 < e2 - 1; ++n3)
              t2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
            t2 += `
        else
            return m[${e2 - 1}];
        `;
            const n2 = `
      int getVecItem(int m[${e2}], int index) {
        ${t2}
      }
    `;
            return { getVecItem: new r.GlslLibRoutine(n2) };
          }
        }
        t.VecGlslLib = o;
      }, 7860: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLInferenceHandler = void 0;
        const r = n(1315), o = n(9240), i = n(7273), a = n(9), s = n(7379), u = n(2488), l = n(540), c = n(3314), p = n(5639);
        t.WebGLInferenceHandler = class {
          constructor(e2) {
            this.session = e2, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          calculateTextureWidthAndHeight(e2, t2) {
            return (0, c.calculateTextureWidthAndHeight)(this.session.layoutStrategy, e2, t2);
          }
          executeProgram(e2, t2) {
            if (t2.length < e2.inputNames.length)
              throw new Error(`Input size mustn't be less than ${e2.inputNames.length}.`);
            if (e2.inputNames.length !== e2.inputTypes.length)
              throw new Error("input names size does not match input types");
            const n2 = [];
            for (let r3 = 0; r3 < e2.inputNames.length; ++r3)
              n2[r3] = this.getOrCreateTextureData(t2[r3], e2.inputTypes[r3]);
            const r2 = ((e3, t3) => {
              const n3 = t3.map((e4) => `${e4.unpackedShape.join(",")};${e4.width}x${e4.height}`).join("_");
              let r3 = e3.name;
              return e3.cacheHint && (r3 += "[" + e3.cacheHint + "]"), r3 += ":" + n3, r3;
            })(e2, n2);
            let o2 = this.session.programManager.getArtifact(r2);
            const i2 = o2 ? o2.programInfo : "function" == typeof e2.get ? e2.get() : e2, a2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i2.output.dims, i2.output.textureType), s2 = this.createTextureData(a2, i2.output.type);
            return o2 || (o2 = this.session.programManager.build(i2, n2, s2), this.session.programManager.setArtifact(r2, o2)), this.runProgram(o2, n2, s2), s2;
          }
          run(e2, t2) {
            return this.executeProgram(e2, t2).tensor;
          }
          runProgram(e2, t2, n2) {
            for (let n3 = 0; n3 < t2.length; ++n3)
              if (!!t2[n3].isPacked != (e2.programInfo.inputTypes[n3] === p.TextureType.packed))
                throw new Error(`input[${n3}] property packed inconsistent`);
            if (!!n2.isPacked != (e2.programInfo.output.textureType === p.TextureType.packed))
              throw new Error("output property packed inconsistent");
            this.session.programManager.run(e2, t2, n2);
          }
          getOrCreateTextureData(e2, t2) {
            let n2 = this.getTextureData(e2.dataId, t2 === p.TextureType.packed);
            if (!n2 && (n2 = this.getTextureData(e2.dataId, t2 !== p.TextureType.packed), n2))
              return t2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
            if (!n2) {
              const r2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, e2.dims, t2);
              if (t2 === p.TextureType.packedLastDimension) {
                const n3 = 1, r3 = 4, o2 = e2.dims;
                if (4 === o2.length) {
                  const i2 = [o2[0], Math.ceil(o2[1] * o2[2] * o2[3] / r3)], a2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i2, t2);
                  let s2 = e2.numberData;
                  if (o2[1] * o2[2] * o2[3] % r3 != 0) {
                    const t3 = o2[0], i3 = o2[1] * o2[2] * o2[3], a3 = Math.ceil(i3 * n3 / r3) * r3;
                    s2 = new Float32Array(t3 * a3);
                    for (let r4 = 0; r4 < t3; ++r4) {
                      const t4 = r4 * i3, o3 = r4 * a3 + r4 % n3 * i3;
                      s2.set(e2.numberData.subarray(t4, t4 + i3), o3);
                    }
                  }
                  return this.createTextureData(a2, e2.type, s2, e2, 1);
                }
              }
              if (t2 === p.TextureType.packed) {
                const t3 = (0, c.createTextureLayoutFromShape)(this.session.layoutStrategy, e2.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(t3, e2.type, e2.numberData, e2, 1);
                n2 = this.pack(r3);
              } else
                n2 = this.createTextureData(r2, e2.type, e2.numberData, e2, 1);
            }
            return n2;
          }
          createTextureDataFromLayoutBindTensor(e2, t2, n2, r2) {
            return this.createTextureData(e2, t2, n2, r2, 1);
          }
          createTextureData(e2, t2, n2, o2, i2) {
            r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(e2)}]`);
            const a2 = this.session.textureManager.createTextureFromLayout(t2, e2, n2, i2);
            return this.createTextureDataFromTexture(e2, t2, a2, o2);
          }
          reshapeUnpacked(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: i.ShapeUtil.computeStrides(t2), unpackedShape: t2 };
            return this.createTextureDataFromTexture(r2, e2.type, n2.texture).tensor;
          }
          reshapePacked(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.packed);
            if ((0, s.isReshapeCheap)(e2.dims, t2)) {
              const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: i.ShapeUtil.computeStrides(t2), unpackedShape: t2, isPacked: true };
              return this.createTextureDataFromTexture(r3, e2.type, n2.texture).tensor;
            }
            const r2 = (0, s.processDims3D)(e2.dims), o2 = (0, s.processDims3D)(t2), a2 = this.reshapePacked(e2, r2), u2 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, o2), [a2]);
            return this.reshapePacked(u2, t2);
          }
          cast(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.unpacked);
            return this.createTextureDataFromTexture(n2, t2, n2.texture).tensor;
          }
          createTextureDataFromTexture(e2, t2, n2, r2, i2) {
            const a2 = Object.assign(Object.assign({}, e2), { tensor: r2 || new o.Tensor(e2.unpackedShape, t2, (e3) => this.readTexture(a2), async (e3) => this.readTextureAsync(a2), void 0, i2), texture: n2 });
            return this.setTextureData(a2.tensor.dataId, a2, e2.isPacked), a2;
          }
          getTextureData(e2, t2 = false) {
            return this.session.isInitializer(e2) ? this.session.getTextureData(e2, t2) : t2 ? this.packedTextureDataCache.get(e2) : this.unpackedTextureDataCache.get(e2);
          }
          setTextureData(e2, t2, n2 = false) {
            this.session.isInitializer(e2) ? this.session.setTextureData(e2, t2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e2, t2);
          }
          isTextureLayoutCached(e2, t2 = false) {
            return !!this.getTextureData(e2.dataId, t2);
          }
          dispose() {
            this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e2) => this.session.textureManager.releaseTexture(e2)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((e2) => this.session.textureManager.releaseTexture(e2)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          readTexture(e2) {
            return e2.isPacked ? this.readTexture(this.unpack(e2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e2, e2.tensor.type, e2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e2));
          }
          async readTextureAsync(e2) {
            return e2.isPacked ? this.readTextureAsync(this.unpack(e2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e2, e2.tensor.type, e2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e2));
          }
          pack(e2) {
            return this.executeProgram((0, a.createPackProgramInfoLoader)(this, e2.tensor), [e2.tensor]);
          }
          unpack(e2) {
            return this.executeProgram((0, l.createUnpackProgramInfoLoader)(this, e2.tensor), [e2.tensor]);
          }
        };
      }, 4110: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), i = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WEBGL_OP_RESOLVE_RULES = void 0;
        const a = n(8817), s = i(n(5194)), u = n(4752), l = n(6668), c = n(9754), p = n(5042), d = n(6742), f = n(4125), h = n(6149), g = n(5378), b = n(6981), m = n(7413), y = n(7006), v = n(8276), _ = n(5565), w = n(2834), T = n(1010), x = n(8126), O = n(2801), S = n(565), A = n(2444), P = n(815), I = n(564), E = n(5416), D = n(1240), $ = n(5944), k = n(5707), F = i(n(9087)), N = n(7862), R = n(3980);
        t.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", F.abs], ["Acos", "", "7+", F.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", F.asin], ["Atan", "", "7+", F.atan], ["AveragePool", "", "7+", w.averagePool, w.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u.cast, u.parseCastAttributes], ["Ceil", "", "6+", F.ceil], ["Clip", "", "6-10", F.clip, F.parseClipAttributes], ["Clip", "", "11+", F.clipV11], ["Concat", "", "4+", l.concat, l.parseConcatAttributes], ["Conv", "", "1+", c.conv, c.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", F.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", F.identity], ["DepthToSpace", "", "1+", d.depthToSpace, d.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", F.elu, F.parseEluAttributes], ["Exp", "", "6+", F.exp], ["Flatten", "", "1+", f.flatten, f.parseFlattenAttributes], ["Floor", "", "6+", F.floor], ["FusedConv", "com.microsoft", "1+", c.conv, c.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", g.gemm, g.parseGemmAttributesV7], ["Gemm", "", "11+", g.gemm, g.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", w.globalAveragePool, w.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", w.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", F.identity], ["ImageScaler", "", "1+", b.imageScaler, b.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m.instanceNormalization, m.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", F.leakyRelu, F.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["LRN", "", "1+", y.lrn, y.parseLrnAttributes], ["Log", "", "6+", F.log], ["MatMul", "", "1+", v.matMul, v.parseMatMulAttributes], ["MaxPool", "", "1+", w.maxPool, w.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", F.neg], ["Not", "", "1+", F.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", T.reduceLogSum, T.parseReduceAttributes], ["ReduceMax", "", "1+", T.reduceMax, T.parseReduceAttributes], ["ReduceMean", "", "1+", T.reduceMean, T.parseReduceAttributes], ["ReduceMin", "", "1+", T.reduceMin, T.parseReduceAttributes], ["ReduceProd", "", "1+", T.reduceProd, T.parseReduceAttributes], ["ReduceSum", "", "1-12", T.reduceSum, T.parseReduceAttributes], ["ReduceSumSquare", "", "1+", T.reduceLogSumSquare, T.parseReduceAttributes], ["Relu", "", "6+", F.relu], ["Reshape", "", "5+", x.reshape], ["Resize", "", "10", O.resize, O.parseResizeAttributesV10], ["Resize", "", "11+", O.resize, O.parseResizeAttributesV11], ["Shape", "", "1+", S.shape], ["Sigmoid", "", "6+", F.sigmoid], ["Sin", "", "7+", F.sin], ["Slice", "", "10+", A.sliceV10], ["Slice", "", "1-9", A.slice, A.parseSliceAttributes], ["Softmax", "", "1-12", P.softmax, P.parseSoftmaxAttributes], ["Softmax", "", "13+", P.softmaxV13, P.parseSoftmaxAttributesV13], ["Split", "", "2-12", I.split, I.parseSplitAttributes], ["Sqrt", "", "6+", F.sqrt], ["Squeeze", "", "1-12", E.squeeze, E.parseSqueezeAttributes], ["Squeeze", "", "13+", E.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", D.sum], ["Tan", "", "7+", F.tan], ["Tanh", "", "6+", F.tanh], ["Tile", "", "6+", $.tile], ["Transpose", "", "1+", k.transpose, k.parseTransposeAttributes], ["Upsample", "", "7-8", R.upsample, R.parseUpsampleAttributesV7], ["Upsample", "", "9", R.upsample, R.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", N.unsqueeze, N.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", N.unsqueezeV13], ["Xor", "", "7+", s.xor]];
      }, 8817: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseBatchNormalizationAttributes = t.batchNormalization = void 0;
        const r = n(4910), o = n(6757), i = n(5639), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] };
        t.batchNormalization = (e2, t2, n2) => (u(t2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(e2, t2, n2) }), t2)]), t.parseBatchNormalizationAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("epsilon", 1e-5), n2 = e2.attributes.getFloat("momentum", 0.9), o2 = e2.attributes.getInt("spatial", 1);
          return (0, r.createAttributeWithCacheKey)({ epsilon: t2, momentum: n2, spatial: o2 });
        };
        const s = (e2, t2, n2) => {
          const r2 = (0, o.getGlsl)(e2.session.backend.glContext.version), s2 = t2[0].dims.length, [u2, l] = e2.calculateTextureWidthAndHeight(t2[1].dims, i.TextureType.unpacked), c = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u2}, ${l});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
          return Object.assign(Object.assign({}, a), { output: { dims: t2[0].dims, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: c });
        }, u = (e2) => {
          if (!e2 || 5 !== e2.length)
            throw new Error("BatchNormalization requires 5 inputs.");
          const t2 = e2[0], n2 = e2[1], r2 = e2[2], o2 = e2[3], i2 = e2[4];
          if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== o2.dims.length || 1 !== i2.dims.length)
            throw new Error("invalid input shape.");
          if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1] || o2.dims[0] !== t2.dims[1] || i2.dims[0] !== t2.dims[1])
            throw new Error("invalid input shape.");
          if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== o2.type && "float64" !== o2.type || "float32" !== i2.type && "float64" !== i2.type)
            throw new Error("invalid input tensor types.");
        };
      }, 5194: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.xor = t.sub = t.pRelu = t.pow = t.or = t.mul = t.less = t.greater = t.equal = t.div = t.and = t.add = t.glslPRelu = t.glslPow = t.glslXor = t.glslOr = t.glslAnd = t.glslLess = t.glslGreater = t.glslEqual = t.glslSub = t.glslMul = t.glslDiv = t.glslAdd = void 0;
        const r = n(7273), o = n(1997), i = n(6757), a = n(5639);
        function s() {
          const e2 = "add_";
          return { body: `
  float ${e2}(float a, float b) {
    return a + b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function u() {
          const e2 = "div_";
          return { body: `
  float ${e2}(float a, float b) {
    return a / b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function l() {
          const e2 = "mul_";
          return { body: `
  float ${e2}(float a, float b) {
    return a * b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function c() {
          const e2 = "sub_";
          return { body: `
  float ${e2}(float a, float b) {
    return a - b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function p() {
          const e2 = "equal_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function d() {
          const e2 = "greater_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function f() {
          const e2 = "less_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function h() {
          const e2 = "and_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function g() {
          const e2 = "or_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function b() {
          const e2 = "xor_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function m() {
          return function(e2) {
            const t2 = `${e2}_`;
            return { body: `
  float ${t2}(float a, float b) {
    return ${e2}(a, b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return ${e2}(v1, v2);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }("pow");
        }
        function y() {
          const e2 = "prelu_";
          return { body: `
  float ${e2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        t.glslAdd = s, t.glslDiv = u, t.glslMul = l, t.glslSub = c, t.glslEqual = p, t.glslGreater = d, t.glslLess = f, t.glslAnd = h, t.glslOr = g, t.glslXor = b, t.glslPow = m, t.glslPRelu = y;
        const v = (e2, t2, n2, r2 = t2[0].type, o2) => {
          const i2 = e2.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
          return { name: n2.name, inputNames: ["A", "B"], inputTypes: [i2, i2], cacheHint: o2, get: () => _(e2, t2, n2, r2) };
        }, _ = (e2, t2, n2, o2 = t2[0].type) => {
          const s2 = e2.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u2 = !r.ShapeUtil.areEqual(t2[0].dims, t2[1].dims);
          let l2 = t2[0].dims;
          const c2 = e2.session.pack;
          if (u2) {
            const a2 = r.BroadcastUtil.calcShape(t2[0].dims, t2[1].dims, false);
            if (!a2)
              throw new Error("Can't perform binary op on the given tensors");
            l2 = a2;
            const u3 = l2.length, p3 = 0 !== t2[0].dims.length ? t2[0].dims.length : 1, d3 = 0 !== t2[1].dims.length ? t2[1].dims.length : 1, f2 = 0 !== t2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== t2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g2 = (0, i.getGlsl)(e2.session.backend.glContext.version), b2 = c2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${g2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${u3}]) {
        int aindices[${p3}];
        int bindices[${d3}];
        ${f2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: l2, type: o2, textureType: s2 }, shaderSource: b2, hasMain: c2 };
          }
          const p2 = (0, i.getGlsl)(e2.session.backend.glContext.version), d2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
          return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: t2[0].dims, type: o2, textureType: s2 }, shaderSource: d2, hasMain: true };
        };
        t.add = (e2, t2) => [e2.run(v(e2, t2, s()), t2)], t.and = (e2, t2) => [e2.run(v(e2, t2, h(), "bool"), t2)], t.div = (e2, t2) => [e2.run(v(e2, t2, u()), t2)], t.equal = (e2, t2) => [e2.run(v(e2, t2, p(), "bool"), t2)], t.greater = (e2, t2) => [e2.run(v(e2, t2, d(), "bool"), t2)], t.less = (e2, t2) => [e2.run(v(e2, t2, f(), "bool"), t2)], t.mul = (e2, t2) => [e2.run(v(e2, t2, l()), t2)], t.or = (e2, t2) => [e2.run(v(e2, t2, g(), "bool"), t2)], t.pow = (e2, t2) => [e2.run(v(e2, t2, m()), t2)], t.pRelu = (e2, t2) => [e2.run(v(e2, t2, y()), t2)], t.sub = (e2, t2) => [e2.run(v(e2, t2, c()), t2)], t.xor = (e2, t2) => [e2.run(v(e2, t2, b(), "bool"), t2)];
      }, 4752: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseCastAttributes = t.cast = void 0;
        const r = n(7273);
        t.cast = (e2, t2, n2) => (o(t2), [e2.cast(t2[0], n2)]), t.parseCastAttributes = (e2) => r.ProtoUtil.tensorDataTypeFromProto(e2.attributes.getInt("to"));
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Cast requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 4595: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedConcatProgramInfoLoader = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614);
        t.createPackedConcatProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = t2.length, c = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: l }, (e3, t3) => `X${t3}`), inputTypes: Array(l).fill(o.TextureType.packed), cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = n3[0].dims.slice();
            if (u2 >= l2.length || u2 < -1 * l2.length)
              throw new Error("axis specified for concat doesn't match input dimensionality");
            u2 < 0 && (u2 = l2.length + u2);
            const c2 = l2.slice(0);
            for (let e4 = 1; e4 < n3.length; e4++) {
              const t4 = n3[e4].dims.slice();
              for (let e5 = 0; e5 < l2.length; e5++)
                if (e5 === u2)
                  c2[u2] += t4[e5];
                else if (l2[e5] !== t4[e5])
                  throw new Error("non concat dimensions must match");
            }
            const p = c2.length, d = (0, a.getChannels)("coords", p), f = (0, i.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n3.map((e4) => e4.dims), b = (0, i.getGlChannels)(p), m = new Array(g.length - 1);
            m[0] = g[0][u2];
            for (let e4 = 1; e4 < m.length; e4++)
              m[e4] = m[e4 - 1] + g[e4][u2];
            const y = b[u2], v = b.slice(-2), _ = b.join();
            let w = `if (${y} < ${m[0]}) {
        return getChannel(
            getX0(${_}), vec2(${v.join()}));
        }`;
            for (let e4 = 1; e4 < m.length; e4++) {
              const t4 = m[e4 - 1];
              w += `
            if (${y} < ${m[e4]}  && ${y} >= ${m[e4 - 1]}) {
              return getChannel(
                getX${e4}(${s(b, y, t4)}),
                vec2(${s(v, y, t4)}));
            }`;
            }
            const T = m.length, x = m[m.length - 1];
            w += `
            return getChannel(
              getX${T}(${s(b, y, x)}),
              vec2(${s(v, y, x)}));`;
            const O = (0, r.getGlsl)(e3.session.backend.glContext.version), S = `
          ${h}
          float getValue(${b.map((e4) => "int " + e4)}) {
            ${w}
          }

          void main() {
            ${f} coords = getOutputCoords();
            int lastDim = coords.${b[p - 1]};
            coords.${b[p - 1]} = coords.${b[p - 2]};
            coords.${b[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${d}), 0., 0., 0.);

            ${d[p - 1]} = ${d[p - 1]} + 1;
            if (${d[p - 1]} < ${c2[p - 1]}) {
              result.g = getValue(${d});
            }

            ${d[p - 2]} = ${d[p - 2]} + 1;
            if (${d[p - 2]} < ${c2[p - 2]}) {
              result.a = getValue(${d});
            }

            ${d[p - 1]} = ${d[p - 1]} - 1;
            if (${d[p - 2]} < ${c2[p - 2]} &&
                ${d[p - 1]} < ${c2[p - 1]}) {
              result.b = getValue(${d});
            }
            ${O.output} = result;
          }
        `;
            return Object.assign(Object.assign({}, t3), { output: { dims: c2, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: S, hasMain: true });
          })(e2, u, t2, n2.axis) });
        };
        const s = (e2, t2, n2) => {
          const r2 = e2.indexOf(t2);
          return e2.map((e3, t3) => t3 === r2 ? `${e3} - ${n2}` : e3).join();
        };
      }, 6668: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConcatAttributes = t.concat = void 0;
        const r = n(4910), o = n(5639), i = n(4595);
        t.concat = (e2, t2, n2) => (p(t2), e2.session.pack && t2[0].dims.length > 1 ? [e2.run((0, i.createPackedConcatProgramInfoLoader)(e2, t2, n2), t2)] : [e2.run(a(e2, t2, n2), t2)]);
        const a = (e2, t2, n2) => {
          const r2 = (i2 = t2.length, a2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: i2 }, (e3, t3) => `X${t3}`), inputTypes: Array(i2).fill(o.TextureType.unpacked), cacheHint: a2 });
          var i2, a2;
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const i3 = n3[0].dims.slice();
            if (r3 >= i3.length || r3 < -1 * i3.length)
              throw new Error("axis specified for concat doesn't match input dimensionality");
            r3 < 0 && (r3 = i3.length + r3);
            const a3 = i3.slice(0);
            for (let e4 = 1; e4 < n3.length; e4++) {
              const t4 = n3[e4].dims.slice();
              for (let e5 = 0; e5 < i3.length; e5++)
                if (e5 === r3)
                  a3[r3] += t4[e5];
                else if (i3[e5] !== t4[e5])
                  throw new Error("non concat dimensions must match");
            }
            const p2 = a3.length, d = new Array(n3.length);
            let f = 0;
            for (let e4 = 0; e4 < d.length; ++e4)
              f += n3[e4].dims[r3], d[e4] = f;
            let h = "";
            h = n3.length < 5 ? s(d) : u(d);
            const g = `
        ${l(n3.length, p2)}
        ${c(d)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: a3, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: g });
          })(0, r2, t2, n2.axis) });
        }, s = (e2) => `int getTextureWhereDataResides(int index) {
      ${e2.map((e3, t2) => `if(index<${e3}) {return ${t2};}
`).join("")}
    }`, u = (e2) => s(e2), l = (e2, t2) => {
          const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t2}]) {`];
          for (let t3 = 0; t3 < e2; ++t3)
            0 === t3 ? n2.push(`	if (textureIndex == ${t3}) { return _X${t3}(indices); }`) : t3 === e2 - 1 ? n2.push(`	else { return _X${t3}(indices); }`) : n2.push(`	else if (textureIndex == ${t3}) { return _X${t3}(indices); }`);
          return n2.push("	}"), n2.join("\n");
        }, c = (e2) => {
          const t2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
          for (let n2 = 0; n2 < e2.length; ++n2)
            0 === n2 ? t2.push(`	if (index == ${n2}) { return ${e2[n2]}; }`) : n2 === e2.length - 1 ? t2.push(`	else { return ${e2[n2]}; }`) : t2.push(`	else if (index == ${n2}) { return ${e2[n2]}; }`);
          return t2.push("	}"), t2.join("\n");
        };
        t.parseConcatAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis") });
        const p = (e2) => {
          if (!e2 || e2.length < 1)
            throw new Error("too few inputs");
          const t2 = e2[0].type, n2 = e2[0].dims.length;
          if ("string" === t2)
            throw new Error("string tensor is not supported yet");
          for (const r2 of e2) {
            if (r2.type !== t2)
              throw new Error("input tensors should be one type");
            if (r2.dims.length !== n2)
              throw new Error("input tensors should have the same shape");
          }
        };
      }, 7825: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackedGroupedConvProgramInfoLoader = void 0;
        const r = n(1315), o = n(6757), i = n(5639), a = n(9754), s = n(2150);
        t.createUnpackedGroupedConvProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = t2.length > 2, c = n2.cacheKey, { name: "GroupedConv", inputNames: l ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: l ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = t3.length > 2 ? "value += getBias(output_channel);" : "", c2 = t3[0].dims.slice(), p = t3[1].dims.slice(), d = p[0] / u2.group;
            r.Logger.verbose("GroupedConv", `autpPad:${u2.autoPad}, dilations:${u2.dilations}, group:${u2.group}, kernelShape:${u2.kernelShape}, pads:${u2.pads}, strides:${u2.strides}`);
            const f = (0, a.calculateOutputShape)(c2, p, u2.dilations, u2.pads, u2.strides), h = (0, o.getGlsl)(e3.session.backend.glContext.version), { activationFunction: g, applyActivation: b } = (0, s.getActivationSnippet)(u2), m = `
  const ivec2 strides = ivec2(${u2.strides[0]}, ${u2.strides[1]});
  const ivec2 pads = ivec2(${u2.pads[0]}, ${u2.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${d};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${c2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${c2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${l2}
    ${b}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
            return Object.assign(Object.assign({}, n3), { output: { dims: f, type: t3[0].type, textureType: i.TextureType.unpacked }, shaderSource: m, hasMain: true });
          })(e2, t2, u, n2) });
        };
      }, 7708: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.conv2DPacked = t.conv2DPackedPointwise = void 0;
        const r = n(9754), o = n(5950), i = n(5632);
        t.conv2DPackedPointwise = (e2, t2, n2) => {
          const o2 = t2[0].dims, a = t2[1].dims, s = (0, r.calculateOutputShape)(o2, a, n2.dilations, n2.pads, n2.strides), u = e2.reshapePacked(t2[0], [o2[1], o2[2] * o2[3]]), l = e2.reshapePacked(t2[1], [a[0], a[1]]), c = t2.length > 2 ? [l, u, t2[2]] : [l, u], p = e2.run((0, i.createPackedMatmulProgramInfoLoader)(e2, c, n2), c);
          return e2.reshapePacked(p, s);
        }, t.conv2DPacked = (e2, t2, n2) => {
          const a = t2[0].dims, s = t2[1].dims, u = (0, r.calculateOutputShape)(a, s, n2.dilations, n2.pads, n2.strides), l = e2.run((0, o.createPackedIm2ColProgramInfoLoader)(e2, t2[0], t2[1], u, n2), [t2[0]]), c = e2.reshapePacked(t2[1], [s[0], s[1] * s[2] * s[3]]), p = 3 === t2.length ? [c, l, t2[2]] : [c, l], d = e2.run((0, i.createPackedMatmulProgramInfoLoader)(e2, p, n2), p);
          return e2.reshapePacked(d, u);
        };
      }, 5042: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConvTransposeAttributes = t.convTranspose = void 0;
        const r = n(4910), o = n(6757), i = n(5639), a = n(2150), s = (e2, t2, n2, r2, o2, i2) => (e2 - 1) * t2 + n2 + (r2 - 1) * o2 + 1 - i2, u = (e2, t2, n2, r2, o2) => {
          const i2 = Math.floor(e2 / 2);
          "SAME_UPPER" === t2 ? (n2[r2] = i2, n2[o2] = e2 - i2) : "SAME_LOWER" === t2 && (n2[r2] = e2 - i2, n2[o2] = i2);
        };
        t.convTranspose = (e2, t2, n2) => (d(t2, n2), l(e2, t2, n2));
        const l = (e2, t2, n2) => {
          const r2 = p(n2, t2);
          return [c(e2, t2, r2)];
        }, c = (e2, t2, n2) => e2.run(((e3, t3, n3) => {
          const r2 = (s2 = t3.length > 2, u2 = n3.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u2 });
          var s2, u2;
          return Object.assign(Object.assign({}, r2), { get: () => ((e4, t4, n4, r3) => {
            const s3 = t4.length > 2 ? "getB(output_channel)" : "0.0", u3 = t4[0].dims, l2 = t4[1].dims, c2 = l2[1], p2 = l2[0] / r3.group, d2 = [t4[0].dims[0], t4[1].dims[1] * r3.group, ...r3.outputShape], f = (0, o.getGlsl)(e4.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r3), b = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${c2};
    int wOutChannel = output_channel - group_id * ${c2};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${l2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${l2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${f.output} = vec4(value, .0, .0, .0);
  }
`;
            return Object.assign(Object.assign({}, n4), { output: { dims: d2, type: t4[0].type, textureType: i.TextureType.unpacked }, shaderSource: b, hasMain: true });
          })(e3, t3, r2, n3) });
        })(e2, t2, n2), t2), p = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length)
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          const r2 = e2.pads.slice(), o2 = e2.outputShape.slice();
          ((e3, t3, n3, r3, o3, i3, a2, l2) => {
            const c2 = e3.length - 2, p2 = 0 === l2.length;
            for (let d2 = 0; d2 < c2; ++d2) {
              const f = p2 ? e3[d2 + 2] * i3[d2] : l2[d2], h = s(e3[d2 + 2], i3[d2], o3[d2], t3[d2], n3[d2], f);
              u(h, r3, o3, d2, d2 + c2), p2 && l2.push(i3[d2] * (e3[d2 + 2] - 1) + a2[d2] + (t3[d2] - 1) * n3[d2] + 1 - o3[d2] - o3[d2 + c2]);
            }
          })(t2[0].dims, n2, e2.dilations, e2.autoPad, r2, e2.strides, e2.outputPadding, o2);
          const i2 = Object.assign({}, e2);
          return Object.assign(i2, { kernelShape: n2, pads: r2, outputShape: o2, cacheKey: e2.cacheKey }), i2;
        };
        t.parseConvTransposeAttributes = (e2) => {
          const t2 = e2.attributes, n2 = (0, a.parseInternalActivationAttributes)(t2), o2 = t2.getString("auto_pad", "NOTSET"), i2 = t2.getInts("dilations", [1, 1]), s2 = t2.getInt("group", 1), u2 = t2.getInts("kernel_shape", []), l2 = t2.getInts("output_padding", [0, 0]), c2 = t2.getInts("output_shape", []), p2 = t2.getInts("pads", [0, 0, 0, 0]), d2 = t2.getInts("strides", [1, 1]);
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: o2, dilations: i2, group: s2, kernelShape: u2, outputPadding: l2, outputShape: c2, pads: p2, strides: d2 }, n2));
        };
        const d = (e2, t2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Conv requires 2 or 3 inputs");
          if (4 !== e2[0].dims.length || 4 !== e2[1].dims.length)
            throw new Error("currently only support 2-dimensional conv");
          if (e2[0].dims[1] !== e2[1].dims[0])
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          const n2 = e2[1].dims[1] * t2.group;
          if (3 === e2.length && (1 !== e2[2].dims.length || e2[2].dims[0] !== n2))
            throw new Error("invalid bias");
          const r2 = e2[0].dims.length - 2;
          if (t2.dilations.length !== r2)
            throw new Error(`dilations should be ${r2}D`);
          if (t2.strides.length !== r2)
            throw new Error(`strides should be ${r2}D`);
          if (t2.pads.length !== 2 * r2)
            throw new Error(`pads should be ${2 * r2}D`);
          if (t2.outputPadding.length !== r2)
            throw new Error(`output_padding should be ${r2}D`);
          if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e2[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if (0 !== t2.outputShape.length && t2.outputShape.length !== e2[0].dims.length - 2)
            throw new Error("invalid output shape");
          if ("float32" !== e2[0].type || "float32" !== e2[1].type)
            throw new Error("ConvTranspose input(X,W) should be float tensor");
          if (3 === e2.length && "float32" !== e2[2].type)
            throw new Error("ConvTranspose input(bias) should be float tensor");
        };
      }, 9754: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConvAttributes = t.conv = t.calculateOutputShape = void 0;
        const r = n(4910), o = n(7273), i = n(7825), a = n(7708), s = n(3281), u = n(2150), l = n(1625), c = n(8276);
        t.calculateOutputShape = (e2, t2, n2, r2, o2) => {
          const i2 = e2[0], a2 = e2.slice(2), s2 = a2.length, u2 = t2[0], l2 = t2.slice(2).map((e3, t3) => e3 + (e3 - 1) * (n2[t3] - 1)), c2 = a2.map((e3, t3) => e3 + r2[t3] + r2[t3 + s2]).map((e3, t3) => Math.floor((e3 - l2[t3] + o2[t3]) / o2[t3]));
          return [i2, u2].concat(...c2);
        }, t.conv = (e2, t2, n2) => (g(t2, n2), p(e2, t2, n2));
        const p = (e2, t2, n2) => {
          const r2 = h(n2, t2), o2 = e2.session.pack, s2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
          return r2.group > 1 ? [e2.run((0, i.createUnpackedGroupedConvProgramInfoLoader)(e2, t2, r2), t2)] : s2 && o2 ? [d(e2, t2, r2)] : o2 && 4 === t2[0].dims.length && 1 === t2[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(e2, t2, r2)] : [f(e2, t2, r2)];
        }, d = (e2, n2, r2) => {
          const o2 = n2[0].dims, i2 = n2[1].dims, a2 = (0, t.calculateOutputShape)(o2, i2, r2.dilations, r2.pads, r2.strides), s2 = e2.reshapeUnpacked(n2[0], [o2[1], o2[2] * o2[3]]), u2 = e2.reshapeUnpacked(n2[1], [i2[0], i2[1]]), l2 = n2.length > 2 ? [u2, s2, n2[2]] : [u2, s2], p2 = e2.run((0, c.createMatmulProgramInfoLoader)(l2, r2), l2);
          return e2.reshapeUnpacked(p2, a2);
        }, f = (e2, n2, r2) => {
          const o2 = n2[0].dims, i2 = n2[1].dims, a2 = (0, t.calculateOutputShape)(o2, i2, r2.dilations, r2.pads, r2.strides), u2 = e2.run((0, l.createIm2ColProgramInfoLoader)(e2, n2[0], n2[1], a2, r2), [n2[0]]), c2 = 3 === n2.length ? [u2, n2[1], n2[2]] : [u2, n2[1]];
          return e2.run((0, s.createDotProductProgramInfoLoader)(e2, n2, a2, r2), c2);
        }, h = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length)
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          const r2 = e2.pads.slice();
          o.PoolConvUtil.adjustPadsBasedOnAutoPad(t2[0].dims, e2.strides, e2.dilations, n2, r2, e2.autoPad);
          const i2 = Object.assign({}, e2);
          return Object.assign(i2, { kernelShape: n2, pads: r2, cacheKey: e2.cacheKey }), i2;
        };
        t.parseConvAttributes = (e2) => {
          const t2 = e2.attributes, n2 = (0, u.parseInternalActivationAttributes)(t2), o2 = t2.getString("auto_pad", "NOTSET"), i2 = t2.getInts("dilations", [1, 1]), a2 = t2.getInt("group", 1), s2 = t2.getInts("kernel_shape", []), l2 = t2.getInts("pads", [0, 0, 0, 0]), c2 = t2.getInts("strides", [1, 1]);
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: o2, dilations: i2, group: a2, kernelShape: s2, pads: l2, strides: c2 }, n2));
        };
        const g = (e2, t2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Conv requires 2 or 3 inputs");
          if (4 !== e2[0].dims.length || 4 !== e2[1].dims.length)
            throw new Error("currently only support 2-dimensional conv");
          if (e2[0].dims[1] !== e2[1].dims[1] * t2.group)
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          if (3 === e2.length && (1 !== e2[2].dims.length || e2[1].dims[0] !== e2[2].dims[0]))
            throw new Error("invalid bias");
          const n2 = e2[0].dims.length - 2;
          if (t2.dilations.length !== n2)
            throw new Error(`dilations should be ${n2}D`);
          if (t2.strides.length !== n2)
            throw new Error(`strides should be ${n2}D`);
          if (t2.pads.length !== 2 * n2)
            throw new Error(`pads should be ${2 * n2}D`);
          if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e2[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if ("float32" !== e2[0].type || "float32" !== e2[1].type)
            throw new Error("Conv input(X,W) should be float tensor");
          if (3 === e2.length && "float32" !== e2[2].type)
            throw new Error("Conv input(bias) should be float tensor");
        };
      }, 6742: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseDepthToSpaceAttributes = t.depthToSpace = void 0;
        const r = n(5707);
        t.depthToSpace = (e2, t2, n2) => {
          o(t2);
          const i = n2.blocksize, a = i * i, s = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u = "DCR" === n2.mode ? [t2[0].dims[0], i, i, t2[0].dims[1] / a, t2[0].dims[2], t2[0].dims[3]] : [t2[0].dims[0], t2[0].dims[1] / a, i, i, t2[0].dims[2], t2[0].dims[3]], l = e2.reshapeUnpacked(t2[0], u), c = { perm: s, cacheKey: `${s}` }, [p] = (0, r.transpose)(e2, [l], c), d = [t2[0].dims[0], t2[0].dims[1] / a, t2[0].dims[2] * i, t2[0].dims[3] * i];
          return [e2.reshapeUnpacked(p, d)];
        }, t.parseDepthToSpaceAttributes = (e2) => {
          const t2 = e2.attributes.getInt("blocksize");
          if (t2 < 1)
            throw new Error(`blocksize must be >= 1, but got : ${t2} for DepthToSpace`);
          const n2 = e2.attributes.getString("mode", "DCR");
          if ("DCR" !== n2 && "CRD" !== n2)
            throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
          return { mode: n2, blocksize: t2 };
        };
        const o = (e2) => {
          if (1 !== e2.length)
            throw new Error(`DepthToSpace expect 1 inputs, but got ${e2.length}`);
          if ("string" === e2[0].type || 4 !== e2[0].dims.length)
            throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
        };
      }, 3281: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createDotProductProgramInfoLoader = void 0;
        const r = n(7273), o = n(6757), i = n(5639), a = n(2150), s = n(1625);
        t.createDotProductProgramInfoLoader = (e2, t2, n2, u) => {
          const l = ((e3, t3) => ({ name: "ConvDotProduct", inputNames: e3 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: e3 ? [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.packedLastDimension], cacheKey: t3.activationCacheKey }))(t2.length > 2, u);
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, u2, l2) => {
            const c = n3[0].dims, p = n3[1].dims, d = [p[0], Math.ceil(c[1] * p[2] * p[3] / 4)], f = (0, s.calculateIm2ColDims)(c, p, u2), [h, g] = e3.calculateTextureWidthAndHeight(d, i.TextureType.packedLastDimension), b = r.ShapeUtil.computeStrides(f), [m, y] = e3.calculateTextureWidthAndHeight(f, i.TextureType.packedLastDimension), v = u2.length, _ = n3.length < 3 ? "0.0" : "_B(b)", w = Math.ceil(c[1] * p[2] * p[3] / 4), { activationFunction: T, applyActivation: x } = (0, a.getActivationSnippet)(l2), O = (0, o.getGlsl)(e3.session.backend.glContext.version), S = `
${T}
float process(int indices[${v}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};
  int kernelOffset = indices[1] * ${d[1]};
  float value = ${_};
  for (int i = 0; i < ${w}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});
    value += dot(${O.texture2D}(Im2Col, im2colCoords), ${O.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${x}
  return value;
}`;
            return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: S });
          })(e2, l, t2, n2, u) });
        };
      }, 4125: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseFlattenAttributes = t.flatten = void 0;
        const r = n(7273);
        t.flatten = (e2, t2, n2) => {
          o(t2, n2);
          const i = r.ShapeUtil.flattenShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], i)];
        }, t.parseFlattenAttributes = (e2) => e2.attributes.getInt("axis", 1);
        const o = (e2, t2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Flatten requires 1 input.");
          const n2 = e2[0].dims.length;
          if (0 === n2)
            throw new Error("scalar tensor is not supported.");
          if (t2 < -n2 || t2 > n2)
            throw new Error("Invalid axis");
          if ("string" === e2[0].type)
            throw new Error("string tensor is not supported.");
        };
      }, 2150: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInternalActivationAttributes = t.getActivationSnippet = void 0;
        const r = n(7273), o = n(9087);
        t.getActivationSnippet = function(e2) {
          let t2;
          switch (e2.activation) {
            case "Relu":
              t2 = (0, o.glslRelu)();
              break;
            case "Sigmoid":
              t2 = (0, o.glslSigmoid)();
              break;
            case "Clip":
              t2 = (0, o.glslClip)(e2.clipMin, e2.clipMax);
              break;
            default:
              return { activationFunction: "", applyActivation: "" };
          }
          const n2 = t2.name;
          return { activationFunction: t2.body, applyActivation: `value = ${n2}_(value);` };
        }, t.parseInternalActivationAttributes = (e2) => {
          const t2 = e2.getString("activation", "");
          if ("Clip" === t2) {
            const [n2, o2] = e2.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
            return { activation: t2, clipMax: o2, clipMin: n2, activationCacheKey: `${t2}:${n2},${o2}` };
          }
          return { activation: t2, activationCacheKey: t2 };
        };
      }, 6149: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGatherAttributes = t.gather = void 0;
        const r = n(4910), o = n(6145), i = n(7273), a = n(5639);
        t.gather = (e2, t2, n2) => (l(t2, n2.axis), [e2.run(u(e2, t2, n2), t2)]), t.parseGatherAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", 0) });
        const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u = (e2, t2, n2) => {
          const r2 = Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey });
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const o2 = n3[0].dims.slice(), s2 = n3[1].dims.slice(), u2 = new Array(o2.length + s2.length - 1);
            r3 = i.ShapeUtil.normalizeAxis(r3, o2.length);
            const l2 = [];
            for (let e4 = 0; e4 < u2.length; e4++)
              e4 < r3 ? (u2[e4] = o2[e4], l2.push(`inputIdx[${e4}] = outputIdx[${e4}];`)) : e4 < r3 + s2.length ? (u2[e4] = s2[e4 - r3], l2.push(`indexDataIdx[${e4 - r3}] = outputIdx[${e4}];`)) : (u2[e4] = o2[e4 - s2.length + 1], l2.push(`inputIdx[${e4 - s2.length + 1}] = outputIdx[${e4}];`));
            const c = `
      float process(int outputIdx[${u2.length || 1}]) {
        int inputIdx[${o2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${l2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${o2[r3]} : idx;
        return _A(inputIdx);
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: a.TextureType.unpacked }, shaderSource: c });
          })(0, r2, t2, n2.axis) });
        }, l = (e2, t2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Gather requires 2 inputs.");
          const n2 = e2[0].dims.length;
          if (n2 < 1)
            throw new Error("Invalid input shape.");
          if (t2 < -n2 || t2 > n2 - 1)
            throw new Error("Invalid axis.");
          if (-1 === o.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invaid input type.");
          if ("int32" !== e2[1].type && "int16" !== e2[1].type)
            throw new Error("Invaid input type.");
        };
      }, 5378: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGemmAttributesV11 = t.parseGemmAttributesV7 = t.gemm = void 0;
        const r = n(4910), o = n(7273), i = n(5639);
        t.gemm = (e2, t2, n2) => (l(t2, n2), [e2.run(s(t2, n2), t2)]);
        const a = (e2, t2) => {
          const n2 = 0 !== e2.attributes.getInt("transA", 0), o2 = 0 !== e2.attributes.getInt("transB", 0), i2 = e2.attributes.getFloat("alpha", 1), a2 = e2.attributes.getFloat("beta", 1);
          return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: o2, alpha: i2, beta: a2, isOptionalC: t2 });
        };
        t.parseGemmAttributesV7 = (e2) => a(e2, false), t.parseGemmAttributesV11 = (e2) => a(e2, true);
        const s = (e2, t2) => {
          const n2 = { name: "Gemm", inputNames: 3 === e2.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === e2.length ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], key: t2.cacheKey };
          return Object.assign(Object.assign({}, n2), { get: () => u(n2, e2, t2) });
        }, u = (e2, t2, n2) => {
          const r2 = t2[0].dims.slice(), a2 = t2[1].dims.slice(), [s2, u2] = o.GemmUtil.getShapeOfGemmResult(r2, n2.transA, a2, n2.transB, 3 === t2.length ? t2[2].dims : void 0), l2 = [s2, u2];
          if (!l2)
            throw new Error("Can't use gemm on the given tensors");
          let c = r2[r2.length - 1], p = "";
          n2.transA && (c = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
          const d = l2.length, f = `
      float process(int indices[${d}]) {
          int a[${d}];
          int b[${d}];
          ${3 === t2.length ? `int c[${t2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === t2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${c}; ++k) {
              a[${d - 1}] = k;
              b[${d - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === t2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
          return Object.assign(Object.assign({}, e2), { output: { dims: l2, type: t2[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: f });
        }, l = (e2, t2) => {
          if (!e2)
            throw new Error("Input is missing");
          if (t2.isOptionalC && (e2.length < 2 || e2.length > 3))
            throw new Error("Invaid input shape.");
          if (!t2.isOptionalC && 3 !== e2.length)
            throw new Error("Gemm requires 3 inputs");
          if (3 === e2.length && 1 !== e2[2].dims.length && 2 !== e2[2].dims.length)
            throw new Error("Invalid input shape of C");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type || "float32" !== e2[1].type && "float64" !== e2[1].type || 3 === e2.length && "float32" !== e2[2].type && "float64" !== e2[2].type)
            throw new Error("Invalid input type.");
          if (e2[0].type !== e2[1].type || 3 === e2.length && e2[0].type !== e2[2].type)
            throw new Error("Input types are mismatched");
        };
      }, 5950: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedIm2ColProgramInfoLoader = void 0;
        const r = n(6757), o = n(5639), i = n(5614);
        t.createPackedIm2ColProgramInfoLoader = (e2, t2, n2, a, s) => {
          const u = (l = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [o.TextureType.packed], cacheHint: l });
          var l;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, a2, s2, u2) => {
            const l2 = n3.dims, c = a2.dims, p = s2.length, d = [c[1] * c[2] * c[3], s2[2] * s2[3]], f = c[2] * c[3], h = (0, i.unpackFromChannel)(), g = (0, r.getGlsl)(e3.session.backend.glContext.version);
            let b = "";
            for (let e4 = 0; e4 <= 1; e4++)
              for (let t4 = 0; t4 <= 1; t4++)
                b += `
            blockIndex = rc.x + ${t4};
            pos = rc.y + ${e4};

            if(blockIndex < ${d[1]} && pos < ${d[0]}) {
              offsetY = int(blockIndex / (${s2[p - 1]})) * ${u2.strides[0]} -
                ${u2.pads[0]};
              d0 = offsetY + ${u2.dilations[0]} * (imod(pos, ${f}) / ${c[2]});

              if(d0 < ${l2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p - 1]}) * ${u2.strides[1]} -
                  ${u2.pads[1]};
                d1 = offsetX + ${u2.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});

                if(d1 < ${l2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${f}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * e4 + t4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
            const m = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${g.output} = result;
      }
            `;
            return Object.assign(Object.assign({}, t3), { output: { dims: d, type: n3.type, textureType: o.TextureType.packed }, shaderSource: m, hasMain: true });
          })(e2, u, t2, n2, a, s) });
        };
      }, 1625: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.calculateIm2ColDims = t.createIm2ColProgramInfoLoader = void 0;
        const r = n(5639);
        t.createIm2ColProgramInfoLoader = (e2, n2, o, i, a) => {
          const s = (u = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: u });
          var u;
          return Object.assign(Object.assign({}, s), { get: () => ((e3, n3, o2, i2, a2, s2) => {
            const u2 = o2.dims, l = i2.dims, c = a2.length, p = (0, t.calculateIm2ColDims)(u2, l, a2, 4), d = `
        const int XC = ${u2[1]};
        const int XH = ${u2[2]};
        const int XW = ${u2[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${c}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
            return Object.assign(Object.assign({}, n3), { output: { dims: p, type: o2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: d });
          })(0, s, n2, o, i, a) });
        }, t.calculateIm2ColDims = (e2, t2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(e2[1] * t2[2] * t2[3] / r2)];
      }, 6981: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseImageScalerAttributes = t.imageScaler = void 0;
        const r = n(4910), o = n(5639);
        t.imageScaler = (e2, t2, n2) => (u(t2), [e2.run(a(e2, t2, n2), t2)]), t.parseImageScalerAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("scale"), n2 = e2.attributes.getFloats("bias");
          return (0, r.createAttributeWithCacheKey)({ scale: t2, bias: n2 });
        };
        const i = { name: "ImageScaler", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] }, a = (e2, t2, n2) => {
          const r2 = Object.assign(Object.assign({}, i), { cacheHint: n2.cacheKey });
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const i2 = n3[0].dims.slice(), a2 = i2.length, u2 = `
      ${s(r3.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: i2, type: n3[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: u2 });
          })(0, r2, t2, n2) });
        }, s = (e2) => {
          const t2 = [`float getBias(float bias[${e2}], int channel) {`];
          for (let n2 = 0; n2 < e2; ++n2)
            0 === n2 ? t2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === e2 - 1 ? t2.push(`	else { return bias[${n2}]; }`) : t2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
          return t2.push("	}"), t2.join("\n");
        }, u = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("ImageScaler requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error("Invalid input shape.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 7413: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInstanceNormalizationAttributes = t.instanceNormalization = void 0;
        const r = n(6757), o = n(5639);
        t.instanceNormalization = (e2, t2, n2) => {
          l(t2);
          const r2 = e2.run(a(t2[0]), t2);
          return [e2.run(u(e2, t2[0], n2, r2.dims), [t2[0], r2, t2[1], t2[2]])];
        }, t.parseInstanceNormalizationAttributes = (e2) => e2.attributes.getFloat("epsilon", 1e-5);
        const i = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] }, a = (e2) => Object.assign(Object.assign({}, i), { get: () => ((e3, t2) => {
          const n2 = t2.dims.slice(), r2 = n2[1], i2 = n2[2] * n2[3], a2 = [n2[0], r2], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i2});

        return v;
      }`;
          return Object.assign(Object.assign({}, e3), { output: { dims: a2, type: t2.type, textureType: o.TextureType.packedLastDimension }, shaderSource: s2 });
        })(i, e2) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked, o.TextureType.unpacked] }, u = (e2, t2, n2, i2) => {
          const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n2}` });
          return Object.assign(Object.assign({}, a2), { get: () => ((e3, t3, n3, i3, a3) => {
            const s2 = (0, r.getGlsl)(e3.session.backend.glContext.version), [u2, l2] = e3.calculateTextureWidthAndHeight(a3, o.TextureType.packedLastDimension), [c, p] = [u2 / 4, l2], d = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${c}, ${p});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: o.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: i3 }], shaderSource: d });
          })(e2, a2, t2, n2, i2) });
        }, l = (e2) => {
          if (!e2 || 3 !== e2.length)
            throw new Error("InstanceNormalization requires 3 inputs.");
          const t2 = e2[0], n2 = e2[1], r2 = e2[2];
          if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length)
            throw new Error("Invalid input shape.");
          if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1])
            throw new Error("Input shapes are mismatched.");
          if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type)
            throw new Error("Invalid input type.");
          if (4 !== e2[0].dims.length)
            throw new Error("Only support 4-D input shape.");
        };
      }, 7006: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createLrnProgramInfoLoader = t.parseLrnAttributes = t.lrn = void 0;
        const r = n(4910), o = n(5639);
        t.lrn = (e2, t2, n2) => (s(t2), [e2.run(a(t2, n2), t2)]), t.parseLrnAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("alpha", 1e-4), n2 = e2.attributes.getFloat("beta", 0.75), o2 = e2.attributes.getFloat("bias", 1), i2 = e2.attributes.getInt("size");
          return (0, r.createAttributeWithCacheKey)({ alpha: t2, beta: n2, bias: o2, size: i2 });
        };
        const i = { name: "LRN", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
        function a(e2, t2) {
          return Object.assign(Object.assign({}, i), { cacheHint: t2.cacheKey, get: () => function(e3, t3) {
            const n2 = e3[0].dims[1], r2 = e3[0].dims.length, a2 = -Math.floor((t3.size - 1) / 2), s2 = Math.ceil((t3.size - 1) / 2), u = `float(${t3.alpha}) / float(${t3.size})`, l = `
    float process(int indices[${r2}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${a2}; i <= ${s2}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${n2}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${t3.bias}) + ${u} * square_sum, float(${t3.beta}));
    }`;
            return Object.assign(Object.assign({}, i), { cacheHint: t3.cacheKey, output: { dims: e3[0].dims, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: l });
          }(e2, t2) });
        }
        t.createLrnProgramInfoLoader = a;
        const s = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("LRN requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error('currently only support LRN for input with "NCHW" format');
          if ("float32" !== e2[0].type)
            throw new Error("input should be float type");
        };
      }, 5632: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedMatmulProgramInfoLoader = void 0;
        const r = n(7273), o = n(6757), i = n(5639), a = n(432), s = n(2150), u = n(8276);
        t.createPackedMatmulProgramInfoLoader = (e2, t2, n2) => {
          const l = (c = t2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: c ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: c ? [i.TextureType.packed, i.TextureType.packed, i.TextureType.packed] : [i.TextureType.packed, i.TextureType.packed], cacheHint: p });
          var c, p;
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, l2) => {
            const c2 = n3.length > 2, p2 = c2 ? "value += getBiasForMatmul();" : "", d = n3[0].dims, f = n3[1].dims, h = r.BroadcastUtil.calcShape(d, f, true), g = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
            if (!h)
              throw new Error("Can't use matmul on the given tensors");
            const b = d[d.length - 1], m = Math.ceil(b / 2), y = d.length, v = f.length, _ = (0, o.getGlsl)(e3.session.backend.glContext.version), w = (0, a.getCoordsDataType)(h.length), T = h.length, x = (0, a.getGlChannels)(), { activationFunction: O, applyActivation: S } = (0, s.getActivationSnippet)(l2), A = c2 ? `${(0, u.getBiasForMatmul)(w, x, n3[2].dims, h, true)}` : "", P = g ? `${function(e4, t4, n4, o2) {
              let i2 = [], a2 = [];
              const s2 = n4[0].dims, u2 = n4[1].dims, l3 = s2.length, c3 = u2.length, p3 = o2.length, d2 = p3 - l3, f2 = p3 - c3;
              i2 = s2.map((e5, n5) => `coords.${t4[n5 + d2]}`), i2[l3 - 1] = "i*2", i2.join(", "), a2 = u2.map((e5, n5) => `coords.${t4[n5 + f2]}`), a2[c3 - 2] = "i*2", a2.join(", ");
              const h2 = r.BroadcastUtil.getBroadcastDims(s2, o2), g2 = r.BroadcastUtil.getBroadcastDims(u2, o2), b2 = h2.map((e5) => `coords.${t4[e5 + d2]} = 0;`).join("\n"), m2 = g2.map((e5) => `coords.${t4[e5 + f2]} = 0;`).join("\n"), y2 = `int lastDim = coords.${t4[p3 - 1]};
  coords.${t4[p3 - 1]} = coords.${t4[p3 - 2]};
  coords.${t4[p3 - 2]} = lastDim;`;
              return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${e4} coords = getOutputCoords();
  ${y2}
  ${b2}
  vec4 outputValue = getA(${i2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e4} coords = getOutputCoords();
  ${y2}
  ${m2}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
            }(w, x, n3, h)}` : "", I = g ? "getAAtOutCoordsMatmul(i)" : `getA(${function(e4, t4) {
              let n4 = "";
              for (let r2 = 0; r2 < t4 - 2; r2++)
                n4 += `rc.${e4[r2]}, `;
              return n4 += `rc.${e4[t4 - 2]}, i*2`, n4;
            }(x, y)})`, E = g ? "getBAtOutCoordsMatmul(i)" : `getB(${function(e4, t4) {
              let n4 = "";
              for (let r2 = 0; r2 < t4 - 2; r2++)
                n4 += `rc.${e4[r2]}, `;
              return n4 += `i*2, rc.${e4[t4 - 1]}`, n4;
            }(x, v)})`, D = `
            ${P}
            ${A}
            ${O}
            void main() {
              ${g ? "" : `${w} rc =
          getOutputCoords(); int lastDim = rc.${x[T - 1]}; rc.${x[T - 1]} =
          rc.${x[T - 2]}; rc.${x[T - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m}; i++) {
                vec4 a = ${I};
                vec4 b = ${E};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${S}
              ${_.output} = value;
            }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: h, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: D, hasMain: true });
          })(e2, l, t2, n2) });
        };
      }, 8276: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getBiasForMatmul = t.createMatmulProgramInfoLoader = t.parseMatMulAttributes = t.matMul = void 0;
        const r = n(7273), o = n(5639), i = n(432), a = n(2150), s = n(5632);
        t.matMul = (e2, t2, n2) => (c(t2), e2.session.pack ? [e2.run((0, s.createPackedMatmulProgramInfoLoader)(e2, t2, n2), t2)] : [e2.run(l(t2, n2), t2)]), t.parseMatMulAttributes = (e2) => (0, a.parseInternalActivationAttributes)(e2.attributes);
        const u = (e2, t2) => ({ name: "MatMul", inputNames: e2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: e2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: t2 });
        function l(e2, t2) {
          const n2 = u(e2.length > 2, t2.activationCacheKey);
          return Object.assign(Object.assign({}, n2), { get: () => function(e3, t3, n3) {
            const s2 = t3[0].dims, u2 = t3[1].dims, l2 = r.BroadcastUtil.calcShape(s2, u2, true);
            if (!l2)
              throw new Error("Can't use matmul on the given tensors");
            const c2 = (0, i.getCoordsDataType)(l2.length), d = (0, i.getGlChannels)(), { activationFunction: f, applyActivation: h } = (0, a.getActivationSnippet)(n3), g = t3.length > 2, b = g ? "value += getBiasForMatmul();" : "", m = g ? `${p(c2, d, t3[2].dims, l2, false)}` : "", y = l2.length, v = s2.length, _ = u2.length, w = `
    ${f}
    ${m}
    float process(int indices[${y}]) {
        int a[${v}];
        int b[${_}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s2[s2.length - 1]}; ++k) {
            a[${v - 1}] = k;
            b[${_ - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b}
        ${h}
        return value;
    }`;
            return Object.assign(Object.assign({}, e3), { output: { dims: l2, type: t3[0].type, textureType: o.TextureType.unpacked }, shaderSource: w });
          }(n2, e2, t2) });
        }
        t.createMatmulProgramInfoLoader = l;
        const c = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("MatMul requires 2 inputs.");
          if (e2[0].dims[e2[0].dims.length - 1] !== e2[1].dims[e2[1].dims.length - 2])
            throw new Error("shared dimension does not match.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type || "float32" !== e2[1].type && "float64" !== e2[1].type)
            throw new Error("inputs should be float type");
          if (e2[0].type !== e2[1].type)
            throw new Error("inputs types should match");
        };
        function p(e2, t2, n2, o2, i2) {
          let a2 = "";
          const s2 = n2.length, u2 = o2.length, l2 = u2 - s2;
          a2 = u2 < 2 && s2 > 0 ? "coords" : n2.map((e3, n3) => `coords.${t2[n3 + l2]}`).join(", ");
          const c2 = r.BroadcastUtil.getBroadcastDims(n2, o2).map((e3) => `coords.${t2[e3 + l2]} = 0;`).join("\n");
          let p2 = "vec4(outputValue.xx, outputValue.yy)";
          return 1 === r.ShapeUtil.size(n2) && (p2 = "vec4(outputValue.x)"), i2 ? `
vec4 getBiasForMatmul() {
  ${e2} coords = getOutputCoords();
  ${c2}
  vec4 outputValue = getBias(${a2});
  return ${p2};
}` : `
float getBiasForMatmul() {
  ${e2} coords = getOutputCoords();
  ${c2}
  return getBias(coords.x);
}`;
        }
        t.getBiasForMatmul = p;
      }, 9: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackProgramInfoLoader = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614), s = { name: "pack", inputNames: ["A"], inputTypes: [o.TextureType.unpackedReversed] };
        t.createPackProgramInfoLoader = (e2, t2) => Object.assign(Object.assign({}, s), { get: () => ((e3, t3) => {
          const n2 = (0, r.getGlsl)(e3.session.backend.glContext.version), u = t3.dims, l = u.length, c = t3.dims.length, p = (0, i.getCoordsDataType)(c), d = (0, a.getChannels)("rc", c), f = (h = c, g = d, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${g[h - 2]};
    int c = ${g[h - 1]};
    int rp1 = ${g[h - 2]} + 1;
    int cp1 = ${g[h - 1]} + 1;
    bool rEdge = rp1 >= ${m};
    bool cEdge = cp1 >= ${b};
    `);
          var h, g, b, m;
          let y;
          y = 0 === l ? [1, 1] : 1 === l ? [u[0], 1] : [u[c - 1], u[c - 2]];
          const v = function(e4, t4, n3) {
            if (0 === e4)
              return "false";
            if (1 === e4)
              return `rc > ${t4[0]}`;
            let r2 = "";
            for (let o2 = e4 - 2; o2 < e4; o2++)
              r2 += `${n3[o2]} >= ${t4[o2 - e4 + 2]}`, o2 < e4 - 1 && (r2 += "||");
            return r2;
          }(c, y, d), _ = function(e4, t4) {
            const n3 = e4.length;
            if (0 === n3)
              return "getA(), 0, 0, 0";
            if (1 === n3)
              return `getA(rc),
            rc + 1 >= ${e4[0]} ? 0. : getA(rc + 1),
            0, 0`;
            let r2 = "";
            if (n3 > 2)
              for (let e5 = 0; e5 < n3 - 2; ++e5)
                r2 += `${t4[e5]},`;
            return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
          }(u, d), w = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${v}) {
            ${n2.output} = vec4(0);
          } else {
            ${f}

            ${n2.output} = vec4(${_});
          }
        }
      `;
          return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: t3.dims, type: t3.type, textureType: o.TextureType.packed }, shaderSource: w });
        })(e2, t2) });
      }, 5614: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.unpackFromChannel = t.getChannels = t.getVecChannels = void 0;
        const r = n(432);
        function o(e2, t2) {
          return (0, r.getGlChannels)(t2).map((t3) => `${e2}.${t3}`);
        }
        t.getVecChannels = o, t.getChannels = function(e2, t2) {
          return 1 === t2 ? [e2] : o(e2, t2);
        }, t.unpackFromChannel = function() {
          return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
        };
      }, 5565: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parsePadAttributesV11 = t.padV11 = t.parsePadAttributesV2 = t.padV2 = void 0;
        const r = n(4910), o = n(7273), i = n(6757), a = n(5639), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        t.padV2 = (e2, t2, n2) => (c(t2), [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => l(e2, t2[0], n2) }), t2)]), t.parsePadAttributesV2 = (e2) => {
          const t2 = e2.attributes.getString("mode", "constant"), n2 = e2.attributes.getFloat("value", 0), o2 = e2.attributes.getInts("pads");
          return (0, r.createAttributeWithCacheKey)({ mode: t2, value: n2, pads: o2 });
        }, t.padV11 = (e2, n2, r2) => {
          p(n2);
          const o2 = u(e2, n2, r2);
          return (0, t.padV2)(e2, [n2[0]], o2);
        }, t.parsePadAttributesV11 = (e2) => e2.attributes.getString("mode", "constant");
        const u = (e2, t2, n2) => {
          if (!e2.session.isInitializer(t2[1].dataId) || t2.length >= 3 && !e2.session.isInitializer(t2[2].dataId))
            throw new Error("dynamic pad attributes are not allowed");
          const o2 = Array.from(t2[1].integerData), i2 = t2.length >= 3 ? t2[2].floatData[0] : 0;
          return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: o2, value: i2 });
        }, l = (e2, t2, n2) => {
          const r2 = o.ShapeUtil.padShape(t2.dims.slice(), n2.pads), i2 = r2.length, s2 = `
      ${d(e2, t2, n2)}
      float process(int[${i2}] indices) {
          return padA(indices);
      }`;
          return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
        }, c = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pad requires 1 input");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        }, p = (e2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Pad requires 2 or 3 inputs");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
          if (e2.length >= 3 && "string" === e2[2].type)
            throw new Error("Invalid input type.");
        }, d = (e2, t2, n2) => {
          const r2 = (0, i.getGlsl)(e2.session.backend.glContext.version), [s2, u2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), l2 = o.ShapeUtil.computeStrides(t2.dims);
          switch (n2.mode) {
            case "constant":
              return f(r2, t2.dims, l2, s2, u2, n2.pads, n2.value);
            case "reflect":
              return h(r2, t2.dims, l2, s2, u2, n2.pads);
            case "edge":
              return g(r2, t2.dims, l2, s2, u2, n2.pads);
            default:
              throw new Error("Invalid mode");
          }
        }, f = (e2, t2, n2, r2, o2, i2, a2) => {
          const s2 = t2.length;
          let u2 = "";
          for (let e3 = s2 - 1; e3 >= 0; --e3)
            u2 += `
        k = m[${e3}] - ${i2[e3]};
        if (k < 0)  return constant;
        if (k >= ${t2[e3]}) return constant;
        offset += k * ${n2[e3]};
        `;
          return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        }, h = (e2, t2, n2, r2, o2, i2) => {
          const a2 = t2.length;
          let s2 = "";
          for (let e3 = a2 - 1; e3 >= 0; --e3)
            s2 += `
        k = m[${e3}] - ${i2[e3]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (t2[e3] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${t2[e3]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[e3]};
        `;
          return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        }, g = (e2, t2, n2, r2, o2, i2) => {
          const a2 = t2.length;
          let s2 = "";
          for (let e3 = a2 - 1; e3 >= 0; --e3)
            s2 += `
        k = m[${e3}] - ${i2[e3]};
        if (k < 0)  k = 0;
        if (k >= ${t2[e3]}) k = ${t2[e3] - 1};
        offset += k * ${n2[e3]};
      `;
          return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        };
      }, 2834: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.globalMaxPool = t.parseMaxPoolAttributes = t.maxPool = t.parseGlobalAveragePoolAttributes = t.globalAveragePool = t.parseAveragePoolAttributes = t.averagePool = void 0;
        const r = n(4910), o = n(7273), i = n(5639);
        t.averagePool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: n2.cacheKey };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, false, n2) }), t2)];
        }, t.parseAveragePoolAttributes = (e2) => {
          const t2 = e2.attributes.getString("auto_pad", "NOTSET"), n2 = e2.attributes.getInt("ceil_mode", 0), o2 = 0 !== e2.attributes.getInt("count_include_pad", 0), i2 = e2.attributes.getInts("kernel_shape"), a2 = e2.attributes.getInts("strides", []), s2 = e2.attributes.getInts("pads", []);
          if (0 !== n2)
            throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
          return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: o2, kernelShape: i2, strides: a2, pads: s2 });
        };
        const a = (e2, t2, n2, r2) => {
          const [a2, s2] = u(e2, r2, n2), l2 = o.ShapeUtil.size(a2.kernelShape);
          let c2 = "";
          a2.countIncludePad ? c2 += `value /= float(${l2});` : c2 += `value /= float(${l2} - pad);`;
          const p2 = `
        ${d(e2[0].dims, a2, "value += _X(x);", c2, "0.0")}
      `;
          return Object.assign(Object.assign({}, t2), { output: { dims: s2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: p2 });
        };
        t.globalAveragePool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, true, n2) }), t2)];
        }, t.parseGlobalAveragePoolAttributes = (e2) => {
          const t2 = 0 !== e2.attributes.getInt("count_include_pad", 0);
          return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: t2, kernelShape: [], strides: [], pads: [] });
        }, t.maxPool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: n2.cacheKey };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => s(t2, r2, false, n2) }), t2)];
        }, t.parseMaxPoolAttributes = (e2) => {
          const t2 = e2.attributes.getString("auto_pad", "NOTSET"), n2 = e2.attributes.getInt("ceil_mode", 0), o2 = e2.attributes.getInts("kernel_shape"), i2 = e2.attributes.getInts("strides", []), a2 = e2.attributes.getInts("pads", []), s2 = e2.attributes.getInt("storage_order", 0), u2 = e2.attributes.getInts("dilations", []);
          if (0 !== s2)
            throw new Error("column major storage order is not yet supported for MaxPool");
          if (0 !== n2)
            throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
          return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: false, kernelShape: o2, strides: i2, pads: a2, storageOrder: s2, dilations: u2 });
        };
        const s = (e2, t2, n2, r2) => {
          const [o2, a2] = u(e2, r2, n2), s2 = `
      ${d(e2[0].dims, o2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
          return Object.assign(Object.assign({}, t2), { output: { dims: a2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: s2 });
        }, u = (e2, t2, n2) => {
          const r2 = e2[0].dims.slice(), i2 = Object.hasOwnProperty.call(t2, "dilations"), a2 = t2.kernelShape.slice(), s2 = t2.strides.slice(), u2 = i2 ? t2.dilations.slice() : [], l2 = t2.pads.slice();
          o.PoolConvUtil.adjustPoolAttributes(n2, r2, a2, s2, u2, l2);
          const c2 = o.PoolConvUtil.computePoolOutputShape(n2, r2, s2, u2, a2, l2, t2.autoPad), p2 = Object.assign({}, t2);
          return i2 ? Object.assign(p2, { kernelShape: a2, strides: s2, pads: l2, dilations: u2, cacheKey: t2.cacheKey }) : Object.assign(p2, { kernelShape: a2, strides: s2, pads: l2, cacheKey: t2.cacheKey }), [p2, c2];
        }, l = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, c = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
        t.globalMaxPool = (e2, t2) => (p(t2), [e2.run(Object.assign(Object.assign({}, c), { get: () => s(t2, c, true, l) }), t2)]);
        const p = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pool ops requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        }, d = (e2, t2, n2, r2, i2) => {
          const a2 = e2.length;
          if (t2.kernelShape.length <= 2) {
            const o2 = t2.kernelShape[t2.kernelShape.length - 1], s2 = t2.strides[t2.strides.length - 1], u2 = t2.pads[t2.pads.length / 2 - 1], l2 = t2.pads[t2.pads.length - 1], c2 = e2[a2 - 1];
            let p2 = "", d2 = "", f2 = "";
            if (p2 = u2 + l2 !== 0 ? `
          for (int i = 0; i < ${o2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${c2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${o2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            ${n2}
          }`, 2 === t2.kernelShape.length) {
              const n3 = t2.kernelShape[t2.kernelShape.length - 2], r3 = t2.strides[t2.strides.length - 2], i3 = t2.pads[t2.pads.length / 2 - 2], s3 = t2.pads[t2.pads.length - 2], u3 = e2[a2 - 2];
              d2 = i3 + s3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${i3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u3}) {
                pad+= ${o2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${i3} + j;
            `, f2 = "\n          }\n        ";
            }
            return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${i2};
          int pad = 0;
          ${d2}
          ${p2}
          ${f2}
          ${r2}
          return value;
        }
      `;
          }
          {
            const s2 = o.ShapeUtil.size(t2.kernelShape), u2 = o.ShapeUtil.computeStrides(t2.kernelShape), l2 = u2.length, c2 = t2.pads.length, p2 = h(l2), d2 = f(e2, "inputDims"), g = f(t2.pads, "pads"), b = f(u2, "kernelStrides"), m = f(t2.strides, "strides");
            let y = "";
            return y = t2.pads.reduce((e3, t3) => e3 + t3) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${l2}];
          int pads[${c2}];
          int inputDims[${a2}];
          int kernelStrides[${l2}];
          int strides[${l2}];
          ${g}
          ${d2}
          ${m}
          ${b}

          float value = ${i2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${l2}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${l2}]
                + offset[j - ${a2} + ${l2}] - pads[j - 2];
              ${y}
          }
          ${r2}

          return value;
        }
      `;
          }
        }, f = (e2, t2) => {
          let n2 = "";
          for (let r2 = 0; r2 < e2.length; r2++)
            n2 += `
      ${t2}[${r2}] = ${e2[r2]};
    `;
          return n2;
        }, h = (e2) => `
  void offsetToIndices(int offset, int[${e2}] strides, out int[${e2}] indices) {
    if (${e2} == 0) {
      return;
    }
    for (int i = 0; i < ${e2} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e2} - 1] = offset;
  }`;
      }, 1010: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.reduceLogSumSquare = t.reduceLogSum = t.reduceProd = t.reduceMin = t.reduceMax = t.reduceMean = t.reduceSum = t.parseReduceAttributes = void 0;
        const r = n(4910), o = n(6145), i = n(7273), a = n(5639), s = (e2, t2, n2, r2, o2) => {
          l(t2);
          const i2 = { name: r2, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          return [e2.run(Object.assign(Object.assign({}, i2), { cacheHint: n2.cacheKey, get: () => u(e2, t2, n2, r2, o2, i2) }), t2)];
        };
        t.parseReduceAttributes = (e2) => {
          const t2 = e2.attributes.getInts("axes", []), n2 = 1 === e2.attributes.getInt("keepdims", 1);
          return (0, r.createAttributeWithCacheKey)({ axes: t2, keepDims: n2 });
        };
        const u = (e2, t2, n2, r2, o2, s2) => {
          const u2 = [], l2 = t2[0].dims.length || 1, c = [], p = i.ShapeUtil.normalizeAxes(n2.axes, t2[0].dims.length), d = o2(t2, p);
          let f = d[1];
          for (let e3 = 0; e3 < t2[0].dims.length; e3++)
            p.indexOf(e3) >= 0 || 0 === p.length ? (n2.keepDims && u2.push(1), f = `
          for(int j${e3} = 0; j${e3} < ${t2[0].dims[e3]}; j${e3}++) {
            inputIdx[${e3}] = j${e3};
            ${f}
          }`) : (c.push(`inputIdx[${e3}] = outputIdx[${u2.length}];`), u2.push(t2[0].dims[e3]));
          const h = `
      float process(int outputIdx[${u2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${l2}];      // addressing input data
        ${c.join("\n")}
        ${d[0]}       // init ops for reduce max/min
        ${f}
        ${d[2]}       // final computation for reduce mean
        return value;
      }`;
          return Object.assign(Object.assign({}, s2), { output: { dims: u2, type: t2[0].type, textureType: a.TextureType.unpacked }, shaderSource: h });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Reduce op requires 1 input.");
          if (-1 === o.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
        };
        t.reduceSum = (e2, t2, n2) => s(e2, t2, n2, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), t.reduceMean = (e2, t2, n2) => s(e2, t2, n2, "ReduceMean", (e3, t3) => {
          let n3 = 1;
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && (n3 *= e3[0].dims[r2]);
          return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
        }), t.reduceMax = (e2, t2, n2) => s(e2, t2, n2, "ReduceMax", (e3, t3) => {
          const n3 = [];
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
          return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
        }), t.reduceMin = (e2, t2, n2) => s(e2, t2, n2, "ReduceMin", (e3, t3) => {
          const n3 = [];
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
          return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
        }), t.reduceProd = (e2, t2, n2) => s(e2, t2, n2, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), t.reduceLogSum = (e2, t2, n2) => s(e2, t2, n2, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), t.reduceLogSumSquare = (e2, t2, n2) => s(e2, t2, n2, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
      }, 7379: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.isReshapeCheap = t.processDims3D = t.createPackedReshape3DProgramInfoLoader = void 0;
        const r = n(7273), o = n(6757), i = n(5639), a = n(5614);
        t.createPackedReshape3DProgramInfoLoader = (e2, t2, n2) => {
          const s = ((e3) => ({ name: "Reshape (packed)", inputTypes: [i.TextureType.packed], inputNames: ["A"], cacheHint: `${e3}` }))(n2);
          return Object.assign(Object.assign({}, s), { get: () => ((e3, t3, n3, s2) => {
            const u = t3.dims, l = s2;
            let c = "";
            for (let e4 = 0; e4 < 4; e4++) {
              let t4 = "";
              switch (e4) {
                case 0:
                  t4 = "outputCoords = rc;";
                  break;
                case 1:
                  t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                  break;
                case 2:
                  t4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                  break;
                case 3:
                  t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                  break;
                default:
                  throw new Error();
              }
              c += `
        ${t4}
        ${e4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${e4 > 0 ? "}" : ""}
      `;
            }
            const p = (0, o.getGlsl)(e3.session.backend.glContext.version), d = `
      ${function(e4) {
              const t4 = r.ShapeUtil.computeStrides(e4), n4 = ["b", "r", "c"], o2 = "index";
              return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t4.map((e5, r2) => `int ${n4[r2]} = ${o2} / ${e5}; ${r2 === t4.length - 1 ? `int ${n4[r2 + 1]} = ${o2} - ${n4[r2]} * ${e5}` : `index -= ${n4[r2]} * ${e5}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
            }(u)}
      ${function(e4) {
              const t4 = r.ShapeUtil.computeStrides(e4);
              return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${t4[0]} + coords.z * ${t4[1]} + coords.y;
  }
`;
            }(l)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${c}
        ${p.output} = result;
      }
    `;
            return Object.assign(Object.assign({}, n3), { output: { dims: l, type: t3.type, textureType: i.TextureType.packed }, shaderSource: d, hasMain: true });
          })(e2, t2, s, n2) });
        }, t.processDims3D = function(e2) {
          if (0 === e2.length)
            return [1, 1, 1];
          let t2 = 1;
          for (let n2 = 0; n2 < e2.length - 2; ++n2)
            t2 *= e2[n2];
          return [t2, e2.length > 1 ? e2[e2.length - 2] : 1, e2[e2.length - 1]];
        }, t.isReshapeCheap = function(e2, t2) {
          let n2 = false;
          return n2 = 0 === e2.length || 0 === t2.length || (e2.length < 2 || t2.length < 2 ? e2[e2.length - 1] === t2[t2.length - 1] : e2[e2.length - 1] === t2[t2.length - 1] && e2[e2.length - 2] === t2[t2.length - 2]), n2;
        };
      }, 8126: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.reshape = void 0;
        const r = n(7273);
        t.reshape = (e2, t2) => {
          const n2 = r.ShapeUtil.calculateReshapedDims(t2[0].dims, t2[1].integerData);
          return e2.session.pack ? [e2.reshapePacked(t2[0], n2)] : [e2.reshapeUnpacked(t2[0], n2)];
        };
      }, 2801: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseResizeAttributesV11 = t.parseResizeAttributesV10 = t.resize = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614), s = n(3980), u = { name: "Resize", inputNames: ["A"], inputTypes: [o.TextureType.packed] };
        t.resize = (e2, t2, n2) => ((0, s.validateInputs)(t2, n2), [e2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => l(e2, t2, n2) }), t2)]), t.parseResizeAttributesV10 = (e2) => (0, s.parseUpsampleAttributes)(e2, 10), t.parseResizeAttributesV11 = (e2) => (0, s.parseUpsampleAttributes)(e2, 11);
        const l = (e2, t2, n2) => {
          const s2 = (0, r.getGlsl)(e2.session.backend.glContext.version), [l2, p2] = c(t2, n2);
          if (l2.every((e3) => 1 === e3) && "tf_crop_and_resize" !== n2.coordinateTransformMode)
            return Object.assign(Object.assign({}, u), { output: { dims: p2, type: t2[0].type, textureType: o.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
          const d2 = p2.length;
          if (d2 < 2)
            throw new Error(`output dimension should be at least 2, but got ${d2}`);
          const f = p2[d2 - 2], h = p2[d2 - 1], g = t2[0].dims;
          if (d2 !== g.length)
            throw new Error(`output dimension should match input ${g.length}, but got ${d2}`);
          const b = g[d2 - 2], m = g[d2 - 1], y = l2[d2 - 2], v = l2[d2 - 1];
          let _ = "";
          if ("linear" !== n2.mode)
            throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
          switch (n2.coordinateTransformMode) {
            case "asymmetric":
              _ = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
              break;
            case "half_pixel":
              _ = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
              break;
            case "pytorch_half_pixel":
              _ = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${f}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${f}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
              break;
            case "align_corners":
              _ = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,
                            ${f}.0 - 1.0);
                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,
                            ${b}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
              break;
            default:
              throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
          }
          const w = (0, i.getCoordsDataType)(d2), T = `
            const vec2 inputWH = vec2(${b}.0, ${m}.0);
            const vec4 scaleWHWH = vec4(float(${y}), float(${v}), float(${y}), float(${v}));
            ${(0, a.unpackFromChannel)()}
            ${_}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${f - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
          return Object.assign(Object.assign({}, u), { output: { dims: p2, type: t2[0].type, textureType: o.TextureType.packed }, hasMain: true, shaderSource: T });
        }, c = (e2, t2) => {
          const n2 = e2[0].dims;
          let r2, o2 = t2.scales;
          if (0 === o2.length) {
            const i3 = e2[t2.scalesInputIdx];
            if (i3 && 0 !== i3.size) {
              if (e2[t2.sizesInputIdx])
                throw new Error("Only one of scales or sizes must be provided as input.");
              o2 = p(i3, t2.mode, t2.isResize);
            } else {
              const i4 = e2[t2.sizesInputIdx];
              if (!i4 || 0 === i4.size)
                throw new Error("Either scales or sizes MUST be provided as input.");
              r2 = Array.from(i4.integerData), o2 = d(r2, n2, t2.mode, t2.isResize);
            }
          } else if (e2[t2.sizesInputIdx])
            throw new Error("Only one of scales or sizes must be provided as input.");
          const i2 = r2 || n2.map((e3, t3) => Math.floor(e3 * o2[t3]));
          return [o2, i2];
        }, p = (e2, t2, n2) => {
          const r2 = Array.from(e2.floatData);
          return (0, s.scalesValidation)(r2, t2, n2), r2;
        }, d = (e2, t2, n2, r2) => {
          const o2 = t2.length, i2 = new Array(o2);
          for (let n3 = 0, r3 = o2; n3 < r3; n3++)
            if (0 === t2[n3]) {
              if (0 !== e2[n3])
                throw new Error("Input dim is zero but required output dim is non-zero.");
              i2[n3] = 1;
            } else
              i2[n3] = e2[n3] / t2[n3];
          return (0, s.scalesValidation)(i2, n2, r2), i2;
        };
      }, 565: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.shape = void 0;
        const r = n(9240);
        t.shape = (e2, t2) => (o(t2), [new r.Tensor([t2[0].dims.length], "int32", void 0, void 0, new Int32Array(t2[0].dims))]);
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Shape requires 1 input.");
        };
      }, 2444: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sliceV10 = t.parseSliceAttributes = t.slice = void 0;
        const r = n(4910), o = n(6145), i = n(7273), a = n(5639), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        t.slice = (e2, t2, n2) => (l(t2), [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(e2, t2[0], n2) }), t2)]), t.parseSliceAttributes = (e2) => {
          const t2 = e2.attributes.getInts("starts"), n2 = e2.attributes.getInts("ends"), o2 = e2.attributes.getInts("axes", []);
          return (0, r.createAttributeWithCacheKey)({ starts: t2, ends: n2, axes: o2 });
        };
        const u = (e2, t2, n2) => {
          const r2 = 0 === n2.axes.length ? t2.dims.slice(0).map((e3, t3) => t3) : n2.axes, o2 = i.ShapeUtil.normalizeAxes(r2, t2.dims.length), u2 = n2.starts.map((e3, n3) => e3 > t2.dims[o2[n3]] - 1 ? t2.dims[o2[n3]] : i.ShapeUtil.normalizeAxis(e3, t2.dims[o2[n3]])), l2 = n2.ends.map((e3, n3) => e3 > t2.dims[o2[n3]] - 1 ? t2.dims[o2[n3]] : i.ShapeUtil.normalizeAxis(e3, t2.dims[o2[n3]])), c2 = t2.dims.slice(), p2 = [];
          for (let e3 = 0; e3 < o2.length; e3++)
            c2[o2[e3]] = l2[e3] - u2[e3], u2[e3] > 0 && p2.push(`outputIdx[${o2[e3]}] += ${u2[e3]};`);
          const d = `
      float process(int outputIdx[${c2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
          return Object.assign(Object.assign({}, s), { output: { dims: c2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Slice requires 1 input.");
          if (-1 === o.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
        };
        t.sliceV10 = (e2, t2) => {
          p(t2);
          const n2 = c(e2, t2);
          return [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(e2, t2[0], n2) }), [t2[0]])];
        };
        const c = (e2, t2) => {
          if (!e2.session.isInitializer(t2[1].dataId) || !e2.session.isInitializer(t2[2].dataId) || t2.length >= 4 && !e2.session.isInitializer(t2[3].dataId) || t2.length >= 5 && !e2.session.isInitializer(t2[4].dataId))
            throw new Error("dynamic slice attributes are not allowed");
          if (t2.length >= 5 && t2[4].integerData.some((e3) => 1 !== e3))
            throw new Error("currently non-1 steps is not supported for Slice");
          const n2 = Array.from(t2[1].integerData), r2 = Array.from(t2[2].integerData), o2 = t2.length >= 4 ? Array.from(t2[3].integerData) : [];
          return { starts: n2, ends: r2, axes: o2, cacheKey: `${o2};${n2};${r2}` };
        }, p = (e2) => {
          if (!e2 || e2.length < 3 || e2.length > 5)
            throw new Error("Invalid input number.");
          if ("int32" !== e2[1].type || 1 !== e2[1].dims.length)
            throw new Error("Invalid input type.");
          if ("int32" !== e2[2].type || 1 !== e2[2].dims.length)
            throw new Error("Invalid input type.");
          if (e2.length >= 4 && ("int32" !== e2[3].type || 1 !== e2[3].dims.length))
            throw new Error("Invalid input type.");
          if (e2.length >= 5 && ("int32" !== e2[4].type || 1 !== e2[4].dims.length))
            throw new Error("Invalid input type.");
        };
      }, 815: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.softmaxV13 = t.parseSoftmaxAttributesV13 = t.parseSoftmaxAttributes = t.softmax = void 0;
        const r = n(4910), o = n(7273), i = n(6757), a = n(5639), s = n(5707), u = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, l = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, c = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
        t.softmax = (e2, t2, n2) => {
          g(t2);
          const r2 = t2[0].dims.slice(), i2 = o.ShapeUtil.normalizeAxis(n2.axis, r2.length), a2 = o.ShapeUtil.sizeToDimension(r2, i2), s2 = o.ShapeUtil.sizeFromDimension(r2, i2);
          return p(e2, t2, n2, a2, s2);
        }, t.parseSoftmaxAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", 1) }), t.parseSoftmaxAttributesV13 = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", -1) }), t.softmaxV13 = (e2, t2, n2) => {
          g(t2);
          const i2 = t2[0].dims.slice(), a2 = o.ShapeUtil.normalizeAxis(n2.axis, i2.length), u2 = i2.length, l2 = a2 !== u2 - 1, c2 = [];
          let d2, f2 = [], h2 = [];
          l2 && (f2 = Array.from({ length: u2 }).map((e3, t3) => t3), f2[a2] = u2 - 1, f2[u2 - 1] = a2, f2.map((e3) => c2.push(i2[e3])), d2 = (0, r.createAttributeWithCacheKey)({ perm: f2 }), h2 = (0, s.transpose)(e2, t2, d2));
          const b = l2 ? o.ShapeUtil.sizeToDimension(c2, u2 - 1) : o.ShapeUtil.sizeToDimension(i2, u2 - 1), m = l2 ? o.ShapeUtil.sizeFromDimension(c2, u2 - 1) : o.ShapeUtil.sizeFromDimension(i2, u2 - 1), y = p(e2, l2 ? h2 : t2, n2, b, m);
          return l2 ? (0, s.transpose)(e2, y, d2) : y;
        };
        const p = (e2, t2, n2, r2, o2) => {
          const i2 = d(e2, t2[0], r2, o2, [r2]), a2 = e2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => i2 }), t2), s2 = f(e2, t2[0], r2, o2, i2.output.dims, [r2]), p2 = e2.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => s2 }), [t2[0], a2]), g2 = h(e2, t2[0], r2, o2, i2.output.dims, s2.output.dims);
          return [e2.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => g2 }), [t2[0], a2, p2])];
        }, d = (e2, t2, n2, r2, o2) => {
          const [s2, l2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), c2 = o2.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== o2.length)
            throw new Error("Dimensionality of the output should be 1");
          if (o2[0] !== n2)
            throw new Error("Shape of the output should be equal to logical row count");
          const p2 = (0, i.getGlsl)(e2.session.backend.glContext.version), d2 = `
      float process(int[${c2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${l2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${l2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
          return Object.assign(Object.assign({}, u), { output: { dims: o2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d2 });
        }, f = (e2, t2, n2, r2, o2, s2) => {
          const [u2, c2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), p2 = s2.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== s2.length)
            throw new Error("Dimensionality of the output should be 1");
          if (s2[0] !== n2)
            throw new Error("Shape of the output should be equal to logical row count");
          if (1 !== o2.length)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (o2[0] !== n2)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          const d2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, i.getGlsl)(e2.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u2}, ${c2}))) - max);
        }

        return norm_factor;
      }`;
          return Object.assign(Object.assign({}, l), { output: { dims: s2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d2 });
        }, h = (e2, t2, n2, r2, o2, i2) => {
          const [s2, u2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), l2 = t2.dims.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== o2.length || 1 !== i2.length)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (o2[0] !== n2 || i2[0] !== n2)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          const p2 = `
      float process(int[${l2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
          return Object.assign(Object.assign({}, c), { output: { dims: t2.dims, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: p2 });
        }, g = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Softmax requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type");
        };
      }, 564: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSplitAttributes = t.split = void 0;
        const r = n(4910), o = n(7273), i = n(5639), a = { name: "Split", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
        t.split = (e2, t2, n2) => {
          l(t2);
          const r2 = o.ShapeUtil.normalizeAxis(n2.axis, t2[0].dims.length), i2 = s(e2, t2, r2, n2), c = [];
          for (let o2 = 0; o2 < i2; ++o2)
            c.push(e2.run(Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey};${o2}`, get: () => u(e2, t2[0], n2, r2, o2) }), t2));
          return c;
        }, t.parseSplitAttributes = (e2) => {
          const t2 = e2.attributes.getInt("axis", 0), n2 = e2.attributes.getInts("split", []), o2 = e2.outputs.length;
          return (0, r.createAttributeWithCacheKey)({ axis: t2, split: n2, numOutputs: o2 });
        };
        const s = (e2, t2, n2, r2) => {
          const [, i2] = o.SplitUtil.splitShape(t2[0].dims, n2, r2.split, r2.numOutputs);
          return i2.length;
        }, u = (e2, t2, n2, r2, s2) => {
          const [u2, l2] = o.SplitUtil.splitShape(t2.dims, r2, n2.split, n2.numOutputs), c = l2[s2], p = u2[s2], d = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${c};
        return _A(indices);
      }
    `;
          return Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey}:${s2}`, output: { dims: p, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: d });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Split requires one input.");
          if ("int8" !== e2[0].type && "uint8" !== e2[0].type && "int16" !== e2[0].type && "uint16" !== e2[0].type && "int32" !== e2[0].type && "uint32" !== e2[0].type && "float32" !== e2[0].type && "float64" !== e2[0].type && "bool" !== e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 5416: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSqueezeAttributes = t.squeezeV13 = t.squeeze = void 0;
        const r = n(7273);
        t.squeeze = (e2, t2, n2) => {
          o(t2);
          const i2 = r.ShapeUtil.squeezeShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], i2)];
        }, t.squeezeV13 = (e2, n2) => (i(n2), (0, t.squeeze)(e2, [n2[0]], Array.from(n2[1].integerData))), t.parseSqueezeAttributes = (e2) => e2.attributes.getInts("axes");
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Squeeze requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("invalid input tensor types.");
        }, i = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Squeeze requires 2 inputs.");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
        };
      }, 1240: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sum = void 0;
        const r = n(6757), o = n(5639);
        t.sum = (e2, t2) => {
          a(t2);
          const n2 = { name: "Sum", inputNames: t2.map((e3, t3) => `X${t3}`), inputTypes: new Array(t2.length).fill(o.TextureType.unpacked) };
          return [e2.run(Object.assign(Object.assign({}, n2), { get: () => i(e2, t2, n2) }), t2)];
        };
        const i = (e2, t2, n2) => {
          const i2 = (0, r.getGlsl)(e2.session.backend.glContext.version), a2 = t2[0].dims.slice(), s = `
      void main() {
        vec4 result = ${t2.map((e3, t3) => `${i2.texture2D}(X${t3},TexCoords)`).join(" + ")};
        ${i2.output} = result;
      }
    `;
          return Object.assign(Object.assign({}, n2), { output: { dims: a2, type: t2[0].type, textureType: o.TextureType.unpacked }, hasMain: true, shaderSource: s });
        }, a = (e2) => {
          if (!e2 || 0 === e2.length)
            throw new Error("Sum requires inputs.");
          const t2 = e2[0].dims.length;
          for (let n2 = 1; n2 < e2.length; n2++) {
            if (t2 !== e2[n2].dims.length)
              throw new Error("Input shapes are mismatched.");
            for (let r2 = 0; r2 < t2; r2++)
              if (e2[0].dims[r2] !== e2[n2].dims[r2])
                throw new Error("Input shapes are not matched.");
          }
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
          for (let t3 = 1; t3 < e2.length; t3++)
            if (e2[0].type !== e2[t3].type)
              throw new Error("Input types are not matched.");
        };
      }, 5944: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tile = void 0;
        const r = n(6145), o = n(5639);
        t.tile = (e2, t2) => {
          a(t2);
          const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
          return [e2.run(Object.assign(Object.assign({}, n2), { get: () => i(e2, t2, n2) }), t2)];
        };
        const i = (e2, t2, n2) => {
          const r2 = t2[0].dims.slice(), i2 = new Array(r2.length), a2 = [];
          for (let e3 = 0; e3 < r2.length; e3++)
            i2[e3] = r2[e3] * t2[1].numberData[e3], a2.push(`inputIdx[${e3}] = int(mod(float(outputIdx[${e3}]), ${r2[e3]}.));`);
          const s = i2.length, u = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
          return Object.assign(Object.assign({}, n2), { output: { dims: i2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: u });
        }, a = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Tile requires 2 input.");
          if (1 !== e2[1].dims.length)
            throw new Error("The second input shape must 1 dimension.");
          if (e2[1].dims[0] !== e2[0].dims.length)
            throw new Error("Invalid input shape.");
          if (-1 === r.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
          if ("int32" !== e2[1].type && "int16" !== e2[1].type)
            throw new Error("Invalid repeat type.");
        };
      }, 5707: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseTransposeAttributes = t.transpose = void 0;
        const r = n(4910), o = n(7273), i = n(5639), a = { name: "Transpose", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
        t.transpose = (e2, t2, n2) => (p(t2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(e2, t2[0], n2.perm) }), t2)]), t.parseTransposeAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ perm: e2.attributes.getInts("perm", []) });
        const s = (e2, t2, n2) => {
          const r2 = t2.dims;
          n2 = u(r2, n2);
          const o2 = l(r2, n2), s2 = r2.length, p2 = `
      ${c("perm", n2, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
          return Object.assign(Object.assign({}, a), { output: { dims: o2, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: p2 });
        }, u = (e2, t2) => (t2 && t2.length !== e2.length && (t2 = [...e2.keys()].reverse()), t2), l = (e2, t2) => (t2 = u(e2, t2), o.ShapeUtil.sortBasedOnPerm(e2, t2)), c = (e2, t2, n2) => {
          const r2 = [];
          r2.push(`void ${e2}(out int a[${n2}], int src[${n2}]) {`);
          for (let e3 = 0; e3 < n2; ++e3)
            r2.push(`	a[${t2[e3]}]=src[${e3}];`);
          return r2.push("	}"), r2.join("\n");
        }, p = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Transpose requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("input should be float tensor");
        };
      }, 2488: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.encodeAsUint8 = void 0;
        const r = n(6757), o = n(5639);
        t.encodeAsUint8 = (e2, t2) => {
          const n2 = t2.shape, i = (0, r.getGlsl)(e2.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${i.texture2D}(X,TexCoords).r;
      ${i.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [o.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: t2.tensor.type, textureType: o.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
          return e2.executeProgram(s, [t2.tensor]);
        };
      }, 9087: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tanh = t.tan = t.sqrt = t.sin = t.sigmoid = t.relu = t.not = t.neg = t.log = t.parseLeakyReluAttributes = t.leakyRelu = t.identity = t.floor = t.exp = t.parseEluAttributes = t.elu = t.cos = t.ceil = t.clipV11 = t.parseClipAttributes = t.clip = t.atan = t.asin = t.acos = t.abs = t.glslTanh = t.glslTan = t.glslSqrt = t.glslSigmoid = t.glslRelu = t.glslSin = t.glslNot = t.glslNeg = t.glslLog = t.glslLeakyRelu = t.glslIdentity = t.glslClip = t.glslFloor = t.glslExp = t.glslElu = t.glslCos = t.glslCeil = t.glslAtan = t.glslAsin = t.glslAcos = t.glslAbs = void 0;
        const r = n(4910), o = n(7273), i = n(1997), a = n(6757), s = n(5639);
        function u() {
          return E("abs");
        }
        function l() {
          return E("acos");
        }
        function c() {
          return E("asin");
        }
        function p() {
          return E("atan");
        }
        function d() {
          return E("ceil");
        }
        function f() {
          return E("cos");
        }
        function h(e2) {
          const t2 = "elu";
          return { body: `
  const float alpha = float(${e2});

  float ${t2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
        }
        function g() {
          return E("exp");
        }
        function b() {
          return E("floor");
        }
        function m(e2, t2) {
          const n2 = "clip";
          return { body: `
  const float min = float(${e2});
  const float max = float(${t2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: i.FunctionType.ValueBased };
        }
        function y() {
          const e2 = "indentity";
          return { body: `
  float ${e2}_(float a) {
    return a;
  }
  vec4 ${e2}_(vec4 v) {
    return v;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function v(e2) {
          const t2 = "leakyRelu";
          return { body: `
  const float alpha = float(${e2});

  float ${t2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
        }
        function _() {
          return E("log");
        }
        function w() {
          const e2 = "neg";
          return { body: `
  float ${e2}_(float a) {
    return -a;
  }
  vec4 ${e2}_(vec4 v) {
    return -v;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function T() {
          const e2 = "not";
          return { body: `
  float ${e2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e2}_(bool a) {
    return !a;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function x() {
          return E("sin");
        }
        function O() {
          const e2 = "relu";
          return { body: `
  float ${e2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function S() {
          const e2 = "sigmoid";
          return { body: `
  float ${e2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function A() {
          return E("sqrt");
        }
        function P() {
          return E("tan");
        }
        function I() {
          const e2 = "tanh";
          return { body: `
  float ${e2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function E(e2) {
          return { body: `
  float ${e2}_(float a) {
    return ${e2}(a);
  }
  vec4 ${e2}_(vec4 v) {
    return ${e2}(v);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        t.glslAbs = u, t.glslAcos = l, t.glslAsin = c, t.glslAtan = p, t.glslCeil = d, t.glslCos = f, t.glslElu = h, t.glslExp = g, t.glslFloor = b, t.glslClip = m, t.glslIdentity = y, t.glslLeakyRelu = v, t.glslLog = _, t.glslNeg = w, t.glslNot = T, t.glslSin = x, t.glslRelu = O, t.glslSigmoid = S, t.glslSqrt = A, t.glslTan = P, t.glslTanh = I;
        const D = (e2, t2, n2, r2) => {
          const o2 = e2.session.pack ? s.TextureType.packed : s.TextureType.unpacked, i2 = { name: n2.name, inputTypes: [o2], inputNames: ["A"], cacheHint: r2 };
          return Object.assign(Object.assign({}, i2), { get: () => ((e3, t3, n3, r3) => {
            const o3 = e3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, i3 = (0, a.getGlsl)(e3.session.backend.glContext.version);
            return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: o3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${i3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${i3.output} = v;
     }
     `, hasMain: true });
          })(e2, i2, t2, n2) });
        };
        t.abs = (e2, t2) => [e2.run(D(e2, t2[0], u()), t2)], t.acos = (e2, t2) => [e2.run(D(e2, t2[0], l()), t2)], t.asin = (e2, t2) => [e2.run(D(e2, t2[0], c()), t2)], t.atan = (e2, t2) => [e2.run(D(e2, t2[0], p()), t2)], t.clip = (e2, t2, n2) => [e2.run(D(e2, t2[0], m(n2.min, n2.max), n2.cacheKey), t2)], t.parseClipAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ min: e2.attributes.getFloat("min", o.MIN_CLIP), max: e2.attributes.getFloat("max", o.MAX_CLIP) }), t.clipV11 = (e2, n2) => {
          const r2 = $(e2, n2);
          return (0, t.clip)(e2, [n2[0]], r2);
        };
        const $ = (e2, t2) => {
          if (t2.length >= 3 && (!e2.session.isInitializer(t2[1].dataId) || !e2.session.isInitializer(t2[2].dataId)))
            throw new Error("dynamic clip attributes are not allowed");
          const n2 = t2.length >= 3 ? t2[1].numberData[0] : o.MIN_CLIP, i2 = t2.length >= 3 ? t2[2].numberData[0] : o.MAX_CLIP;
          return (0, r.createAttributeWithCacheKey)({ min: n2, max: i2 });
        };
        t.ceil = (e2, t2) => [e2.run(D(e2, t2[0], d()), t2)], t.cos = (e2, t2) => [e2.run(D(e2, t2[0], f()), t2)], t.elu = (e2, t2, n2) => [e2.run(D(e2, t2[0], h(n2.alpha), n2.cacheKey), t2)], t.parseEluAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ alpha: e2.attributes.getFloat("alpha", 1) }), t.exp = (e2, t2) => [e2.run(D(e2, t2[0], g()), t2)], t.floor = (e2, t2) => [e2.run(D(e2, t2[0], b()), t2)], t.identity = (e2, t2) => [e2.run(D(e2, t2[0], y()), t2)], t.leakyRelu = (e2, t2, n2) => [e2.run(D(e2, t2[0], v(n2.alpha), n2.cacheKey), t2)], t.parseLeakyReluAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ alpha: e2.attributes.getFloat("alpha", 0.01) }), t.log = (e2, t2) => [e2.run(D(e2, t2[0], _()), t2)], t.neg = (e2, t2) => [e2.run(D(e2, t2[0], w()), t2)], t.not = (e2, t2) => [e2.run(D(e2, t2[0], T()), t2)], t.relu = (e2, t2) => [e2.run(D(e2, t2[0], O()), t2)], t.sigmoid = (e2, t2) => [e2.run(D(e2, t2[0], S()), t2)], t.sin = (e2, t2) => [e2.run(D(e2, t2[0], x()), t2)], t.sqrt = (e2, t2) => [e2.run(D(e2, t2[0], A()), t2)], t.tan = (e2, t2) => [e2.run(D(e2, t2[0], P()), t2)], t.tanh = (e2, t2) => [e2.run(D(e2, t2[0], I()), t2)];
      }, 540: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackProgramInfoLoader = t.createUnpackProgramInfo = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614), s = { name: "unpack", inputNames: ["A"], inputTypes: [o.TextureType.packed] };
        t.createUnpackProgramInfo = (e2, t2) => {
          const n2 = t2.dims.length, u = (0, a.getChannels)("rc", n2), l = u.slice(-2), c = (0, i.getCoordsDataType)(n2), p = (0, a.unpackFromChannel)(), d = 0 === t2.dims.length ? "" : function(e3, t3) {
            if (1 === e3)
              return "rc";
            let n3 = "";
            for (let r2 = 0; r2 < e3; r2++)
              n3 += t3[r2], r2 < e3 - 1 && (n3 += ",");
            return n3;
          }(n2, u), f = n2 <= 1 ? "rc" : `vec2(${l.join(",")})`, h = `
    ${p}
    void main() {
      ${c} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${d});

       ${(0, r.getGlsl)(e2.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);
     }
   `;
          return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: t2.dims, type: t2.type, textureType: o.TextureType.unpacked }, shaderSource: h });
        }, t.createUnpackProgramInfoLoader = (e2, n2) => Object.assign(Object.assign({}, s), { get: () => (0, t.createUnpackProgramInfo)(e2, n2) });
      }, 7862: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseUnsqueezeAttributes = t.unsqueezeV13 = t.unsqueeze = void 0;
        const r = n(7273);
        t.unsqueeze = (e2, t2, n2) => {
          o(t2);
          const i2 = r.ShapeUtil.unsqueezeShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], i2)];
        }, t.unsqueezeV13 = (e2, n2) => (i(n2), (0, t.unsqueeze)(e2, [n2[0]], Array.from(n2[1].integerData))), t.parseUnsqueezeAttributes = (e2) => e2.attributes.getInts("axes");
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Unsqueeze requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("invalid input tensor types.");
        }, i = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Unsqueeze requires 2 inputs.");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
        };
      }, 3980: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.scalesValidation = t.validateInputs = t.parseUpsampleAttributes = t.parseUpsampleAttributesV9 = t.parseUpsampleAttributesV7 = t.upsample = void 0;
        const r = n(4910), o = n(6757), i = n(5639), a = { name: "Upsample", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
        t.upsample = (e2, n2, r2) => ((0, t.validateInputs)(n2, r2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: r2.cacheKey, get: () => s(e2, n2, r2) }), n2)]), t.parseUpsampleAttributesV7 = (e2) => (0, t.parseUpsampleAttributes)(e2, 7), t.parseUpsampleAttributesV9 = (e2) => (0, t.parseUpsampleAttributes)(e2, 9), t.parseUpsampleAttributes = (e2, n2) => {
          const o2 = n2 >= 10, i2 = e2.attributes.getString("mode", "nearest");
          if ("nearest" !== i2 && "linear" !== i2 && (n2 < 11 || "cubic" !== i2))
            throw new Error(`unrecognized mode: ${i2}`);
          let a2 = [];
          n2 < 9 && (a2 = e2.attributes.getFloats("scales"), (0, t.scalesValidation)(a2, i2, o2));
          const s2 = e2.attributes.getFloat("extrapolation_value", 0), u = n2 > 10 ? e2.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
          if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u))
            throw new Error(`coordinate_transform_mode '${u}' is not supported`);
          const l = "tf_crop_and_resize" === u, c = l, p = "nearest" === i2 && n2 >= 11 ? e2.attributes.getString("nearest_mode", "round_prefer_floor") : "";
          if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p))
            throw new Error(`nearest_mode '${p}' is not supported`);
          const d = e2.attributes.getFloat("cubic_coeff_a", -0.75), f = 0 !== e2.attributes.getInt("exclude_outside", 0);
          if (f && "cubic" !== i2)
            throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
          const h = n2 < 11 || "nearest" === i2 && "asymmetric" === u && "floor" === p;
          let g = 0, b = 0, m = 0;
          return n2 > 10 ? e2.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n2 && (b = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: o2, mode: i2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u, useExtrapolation: c, needRoiInput: l, nearestMode: p, cubicCoefficientA: d, excludeOutside: f, useNearest2xOptimization: h, roiInputIdx: g, scalesInputIdx: b, sizesInputIdx: m });
        };
        const s = (e2, t2, n2) => {
          const r2 = (0, o.getGlsl)(e2.session.backend.glContext.version), [s2, u] = e2.calculateTextureWidthAndHeight(t2[0].dims, i.TextureType.unpacked), l = t2[0].dims.map((e3, t3) => Math.floor(e3 * n2.scales[t3])), [c, p] = e2.calculateTextureWidthAndHeight(l, i.TextureType.unpacked), d = l.length, f = new Array(d), h = new Array(d);
          let g = `
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;
          for (let e3 = d - 1; e3 >= 0; e3--)
            f[e3] = e3 === d - 1 ? 1 : f[e3 + 1] * l[e3 + 1], h[e3] = e3 === d - 1 ? 1 : h[e3 + 1] * t2[0].dims[e3 + 1], g += `
        output_pitches[${e3}] = ${f[e3]};
        input_pitches[${e3}] = ${h[e3]};
        `;
          const b = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, m = "nearest" === n2.mode ? `
    ${b}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === d ? `
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${t2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${t2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
          return Object.assign(Object.assign({}, a), { output: { dims: l, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: m, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map((e3) => Math.ceil(e3)) }] });
        };
        t.validateInputs = (e2, t2) => {
          if (!e2 || t2.opset < 9 && 1 !== e2.length || t2.opset >= 9 && t2.opset < 11 && 2 !== e2.length || t2.opset >= 11 && e2.length < 2)
            throw new Error("invalid inputs.");
          if (t2.scales.length > 0 && e2[0].dims.length !== t2.scales.length)
            throw new Error("Invalid input shape.");
          if ("string" === e2[0].type)
            throw new Error("Invalid input tensor types.");
        }, t.scalesValidation = (e2, t2, n2) => {
          if (n2) {
            for (const t3 of e2)
              if (t3 <= 0)
                throw new Error("Scale value should be greater than 0.");
          } else
            for (const t3 of e2)
              if (t3 < 1)
                throw new Error("Scale value should be greater than or equal to 1.");
          if (!("linear" !== t2 && "cubic" !== t2 || 2 === e2.length || 4 === e2.length && 1 === e2[0] && 1 === e2[1]))
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
        };
      }, 2757: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ProgramManager = void 0;
        const r = n(2235), o = n(1315), i = n(8897), a = n(6757);
        t.ProgramManager = class {
          constructor(e2, t2, n2) {
            this.profiler = e2, this.glContext = t2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
          }
          getArtifact(e2) {
            return this.repo.get(e2);
          }
          setArtifact(e2, t2) {
            this.repo.set(e2, t2);
          }
          run(e2, t2, n2) {
            var r2;
            this.profiler.event("op", `ProgramManager.run ${null !== (r2 = e2.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, () => {
              var r3;
              const i2 = this.glContext.gl, a2 = e2.program;
              i2.useProgram(a2);
              try {
                this.bindOutput(n2), this.attributesBound || this.bindAttributes(e2.attribLocations), this.bindUniforms(e2.uniformLocations, null !== (r3 = e2.programInfo.variables) && void 0 !== r3 ? r3 : [], t2);
              } catch (t3) {
                throw o.Logger.error("ProgramManager", e2.programInfo.shaderSource), t3;
              }
              this.profiler.event("backend", "GlContext.draw()", () => {
                this.glContext.draw();
              });
            }, this.glContext);
          }
          dispose() {
            this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((e2) => this.glContext.deleteProgram(e2.program));
          }
          build(e2, t2, n2) {
            return this.profiler.event("backend", "ProgramManager.build", () => {
              const r2 = new i.GlslPreprocessor(this.glContext, e2, t2, n2), o2 = r2.preprocess(), a2 = this.compile(o2);
              return { programInfo: e2, program: a2, uniformLocations: this.getUniformLocations(a2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
            });
          }
          compile(e2) {
            if (!this.vertexShader) {
              o.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
              const e3 = (0, a.getVertexShaderSource)(this.glContext.version);
              this.vertexShader = this.glContext.compileShader(e3, this.glContext.gl.VERTEX_SHADER);
            }
            r.env.debug && o.Logger.verbose("ProrgramManager", `FragShader:
${e2}
`);
            const t2 = this.glContext.compileShader(e2, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, t2);
            return this.glContext.deleteShader(t2), n2;
          }
          bindOutput(e2) {
            const t2 = e2.width, n2 = e2.height;
            o.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${t2}/${n2}, shape=${e2.shape}, type=${e2.tensor.type}`), this.glContext.attachFramebuffer(e2.texture, t2, n2);
          }
          bindAttributes(e2) {
            const t2 = e2.position, n2 = e2.textureCoord;
            this.glContext.setVertexAttributes(t2, n2), this.attributesBound = true;
          }
          bindUniforms(e2, t2, n2) {
            var r2;
            const o2 = this.glContext.gl;
            let i2 = 0;
            for (const { name: a2, type: s, location: u, arrayLength: l } of e2) {
              const e3 = null === (r2 = t2.find((e4) => e4.name === a2)) || void 0 === r2 ? void 0 : r2.data;
              if ("sampler2D" !== s && !e3)
                throw new Error(`variable '${a2}' does not have data defined in program info`);
              switch (s) {
                case "sampler2D":
                  this.bindTexture(n2[i2], u, i2), i2++;
                  break;
                case "float":
                  l ? o2.uniform1fv(u, e3) : o2.uniform1f(u, e3);
                  break;
                case "int":
                  l ? o2.uniform1iv(u, e3) : o2.uniform1i(u, e3);
                  break;
                default:
                  throw new Error(`Uniform not implemented: ${s}`);
              }
            }
          }
          bindTexture(e2, t2, n2) {
            this.glContext.bindTextureToUniform(e2.texture, n2, t2);
          }
          getAttribLocations(e2) {
            return { position: this.getAttribLocation(e2, "position"), textureCoord: this.getAttribLocation(e2, "textureCoord") };
          }
          getUniformLocations(e2, t2, n2) {
            const r2 = [];
            if (t2)
              for (const n3 of t2)
                r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(e2, n3) });
            if (n2)
              for (const t3 of n2)
                r2.push(Object.assign(Object.assign({}, t3), { location: this.getUniformLocation(e2, t3.name) }));
            return r2;
          }
          getUniformLocation(e2, t2) {
            const n2 = this.glContext.gl.getUniformLocation(e2, t2);
            if (null === n2)
              throw new Error(`Uniform ${t2} not found.`);
            return n2;
          }
          getAttribLocation(e2, t2) {
            return this.glContext.gl.getAttribLocation(e2, t2);
          }
        };
      }, 2171: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLSessionHandler = void 0;
        const r = n(1315), o = n(5881), i = n(7860), a = n(4110), s = n(2757), u = n(7618), l = n(5243);
        t.WebGLSessionHandler = class {
          constructor(e2, t2) {
            this.backend = e2, this.context = t2, this.layoutStrategy = new u.PreferLogicalStrategy(e2.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, e2.glContext, this.layoutStrategy), this.textureManager = new l.TextureManager(e2.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === e2.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = e2.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
          }
          createInferenceHandler() {
            return new i.WebGLInferenceHandler(this);
          }
          onGraphInitialized(e2) {
            const t2 = e2.getValues().filter((e3) => -1 === e3.from && e3.tensor).map((e3) => e3.tensor.dataId);
            this.initializers = new Set(t2);
          }
          isInitializer(e2) {
            return !!this.initializers && this.initializers.has(e2);
          }
          addInitializer(e2) {
            this.initializers.add(e2);
          }
          getTextureData(e2, t2) {
            return t2 ? this.packedTextureDataCache.get(e2) : this.unpackedTextureDataCache.get(e2);
          }
          setTextureData(e2, t2, n2 = false) {
            r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(e2, t2) : this.unpackedTextureDataCache.set(e2, t2);
          }
          dispose() {
            this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e2) => this.textureManager.releaseTexture(e2, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((e2) => this.textureManager.releaseTexture(e2, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          resolve(e2, t2, n2) {
            const r2 = (0, o.resolveOperator)(e2, t2, a.WEBGL_OP_RESOLVE_RULES);
            return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(e2, n2) : e2 };
          }
        };
      }, 9622: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Uint8DataEncoder = t.RGBAFloatDataEncoder = t.RedFloat32DataEncoder = void 0;
        const r = n(1315);
        t.RedFloat32DataEncoder = class {
          constructor(e2, t2 = 1) {
            if (1 === t2)
              this.internalFormat = e2.R32F, this.format = e2.RED, this.textureType = e2.FLOAT, this.channelSize = t2;
            else {
              if (4 !== t2)
                throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e2.RGBA32F, this.format = e2.RGBA, this.textureType = e2.FLOAT, this.channelSize = t2;
            }
          }
          encode(e2, t2) {
            let n2, o;
            return e2.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), o = new Float32Array(e2)), t2 * this.channelSize > e2.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), o = e2, n2 = this.allocate(t2 * this.channelSize), o.forEach((e3, t3) => n2[t3] = e3)) : (o = e2, n2 = o), n2;
          }
          allocate(e2) {
            return new Float32Array(4 * e2);
          }
          decode(e2, t2) {
            return 1 === this.channelSize ? e2.filter((e3, t3) => t3 % 4 == 0).subarray(0, t2) : e2.subarray(0, t2);
          }
        }, t.RGBAFloatDataEncoder = class {
          constructor(e2, t2 = 1, n2) {
            if (1 !== t2 && 4 !== t2)
              throw new Error(`Invalid number of channels: ${t2}`);
            this.internalFormat = e2.RGBA, this.format = e2.RGBA, this.channelSize = t2, this.textureType = n2 || e2.FLOAT;
          }
          encode(e2, t2) {
            let n2 = e2;
            return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(t2), e2.forEach((e3, t3) => n2[4 * t3] = e3)), n2;
          }
          allocate(e2) {
            return new Float32Array(4 * e2);
          }
          decode(e2, t2) {
            return 1 === this.channelSize ? e2.filter((e3, t3) => t3 % 4 == 0).subarray(0, t2) : e2.subarray(0, t2);
          }
        }, t.Uint8DataEncoder = class {
          constructor(e2, t2 = 1) {
            if (this.channelSize = 4, 1 === t2)
              this.internalFormat = e2.ALPHA, this.format = e2.ALPHA, this.textureType = e2.UNSIGNED_BYTE, this.channelSize = t2;
            else {
              if (4 !== t2)
                throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e2.RGBA, this.format = e2.RGBA, this.textureType = e2.UNSIGNED_BYTE, this.channelSize = t2;
            }
          }
          encode(e2, t2) {
            return new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength);
          }
          allocate(e2) {
            return new Uint8Array(e2 * this.channelSize);
          }
          decode(e2, t2) {
            if (e2 instanceof Uint8Array)
              return e2.subarray(0, t2);
            throw new Error(`Invalid array type: ${e2.constructor}`);
          }
        };
      }, 7618: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getBatchDim = t.sizeToSquarishShape = t.getRowsCols = t.sizeFromShape = t.isInt = t.parseAxisParam = t.squeezeShape = t.PreferLogicalStrategy = t.AlwaysKeepOriginalSizeStrategy = void 0;
        const r = n(1315), o = n(7273);
        function i(e2, t2) {
          const n2 = [], r2 = [], o2 = null != t2 && Array.isArray(t2) && 0 === t2.length, i2 = null == t2 || o2 ? null : a(t2, e2).sort();
          let s2 = 0;
          for (let t3 = 0; t3 < e2.length; ++t3) {
            if (null != i2) {
              if (i2[s2] === t3 && 1 !== e2[t3])
                throw new Error(`Can't squeeze axis ${t3} since its dim '${e2[t3]}' is not 1`);
              (null == i2[s2] || i2[s2] > t3) && 1 === e2[t3] && (n2.push(e2[t3]), r2.push(t3)), i2[s2] <= t3 && s2++;
            }
            1 !== e2[t3] && (n2.push(e2[t3]), r2.push(t3));
          }
          return { newShape: n2, keptDims: r2 };
        }
        function a(e2, t2) {
          const n2 = t2.length;
          return e2 = null == e2 ? t2.map((e3, t3) => t3) : [].concat(e2), (0, o.assert)(e2.every((e3) => e3 >= -n2 && e3 < n2), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${e2}`), (0, o.assert)(e2.every(s), () => `All values in axis param must be integers but got axis ${e2}`), e2.map((e3) => e3 < 0 ? n2 + e3 : e3);
        }
        function s(e2) {
          return e2 % 1 == 0;
        }
        function u(e2) {
          if (0 === e2.length)
            return 1;
          let t2 = e2[0];
          for (let n2 = 1; n2 < e2.length; n2++)
            t2 *= e2[n2];
          return t2;
        }
        function l(e2) {
          const t2 = Math.ceil(Math.sqrt(e2));
          return [t2, Math.ceil(e2 / t2)];
        }
        t.AlwaysKeepOriginalSizeStrategy = class {
          constructor(e2) {
            this.maxTextureSize = e2;
          }
          computeTextureWH(e2, t2) {
            if (0 === e2.length)
              return [1, 1];
            const n2 = this.maxTextureSize;
            if (t2 && void 0 !== t2.breakAxis) {
              const o3 = t2.breakAxis >= e2.length ? 1 : e2.slice(t2.breakAxis).reduce((e3, t3) => e3 * t3), i3 = t2.breakAxis <= 0 ? 1 : e2.slice(0, t2.breakAxis).reduce((e3, t3) => e3 * t3);
              if (!(o3 > n2 || i3 > n2))
                return [o3, i3];
              r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e2}, breakAxis:${t2.breakAxis}`);
            }
            const o2 = e2.reduce((e3, t3) => e3 * t3);
            let i2 = Math.floor(Math.sqrt(o2));
            for (; i2 < n2 && i2 < o2 && o2 % i2 != 0; i2++)
              ;
            if (i2 >= n2 || o2 % i2 != 0)
              throw new Error(`The given dimensions are outside this GPU's boundaries: ${e2}`);
            return [i2, o2 / i2];
          }
        }, t.PreferLogicalStrategy = class {
          constructor(e2) {
            this.maxTextureSize = e2;
          }
          computeTextureWH(e2, t2) {
            const n2 = this.computeTexture(e2, t2);
            return t2 && t2.isPacked && (n2[0] /= 2, n2[1] /= 2), t2 && t2.reverseWH ? [n2[1], n2[0]] : n2;
          }
          computeTexture(e2, t2) {
            const n2 = t2 && t2.isPacked;
            if (0 === e2.length)
              return n2 ? [2, 2] : [1, 1];
            let o2 = this.maxTextureSize;
            if (t2 && void 0 !== t2.breakAxis) {
              const n3 = t2.breakAxis >= e2.length ? 1 : e2.slice(t2.breakAxis).reduce((e3, t3) => e3 * t3), i2 = t2.breakAxis <= 0 ? 1 : e2.slice(0, t2.breakAxis).reduce((e3, t3) => e3 * t3);
              if (!(n3 > o2 || i2 > o2))
                return [n3, i2];
              r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e2}, breakAxis:${t2.breakAxis}`);
            }
            let a2 = e2.slice(0);
            if (n2 && (o2 *= 2, a2 = a2.map((e3, t3) => t3 >= a2.length - 2 ? a2[t3] % 2 == 0 ? a2[t3] : a2[t3] + 1 : a2[t3]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
              const e3 = i(a2);
              a2 = e3.newShape;
            }
            const s2 = u(a2);
            return a2.length <= 1 && s2 <= o2 ? [1, s2] : 2 === a2.length && a2[0] <= o2 && a2[1] <= o2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= o2 && a2[2] <= o2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= o2 && a2[1] * a2[2] <= o2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= o2 && a2[3] <= o2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= o2 && a2[1] * a2[2] * a2[3] <= o2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n2 ? l(s2 / 4).map((e3) => 2 * e3) : l(s2);
          }
        }, t.squeezeShape = i, t.parseAxisParam = a, t.isInt = s, t.sizeFromShape = u, t.getRowsCols = function(e2) {
          if (0 === e2.length)
            throw Error("Cannot get rows and columns of an empty shape array.");
          return [e2.length > 1 ? e2[e2.length - 2] : 1, e2[e2.length - 1]];
        }, t.sizeToSquarishShape = l, t.getBatchDim = function(e2, t2 = 2) {
          return u(e2.slice(0, e2.length - t2));
        };
      }, 3314: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createTextureLayoutFromShape = t.calculateTextureWidthAndHeight = t.createTextureLayoutFromTextureType = void 0;
        const r = n(7273), o = n(5639);
        t.createTextureLayoutFromTextureType = (e2, n2, r2) => {
          const i = r2 === o.TextureType.unpacked || r2 === o.TextureType.unpackedReversed ? 1 : 4, a = r2 === o.TextureType.packed, s = r2 === o.TextureType.unpackedReversed || r2 === o.TextureType.packed, u = r2 === o.TextureType.packedLastDimension ? n2.length - 1 : void 0, l = r2 === o.TextureType.packedLastDimension ? n2.map((e3, t2) => t2 === n2.length - 1 ? 4 * e3 : e3) : void 0;
          return (0, t.createTextureLayoutFromShape)(e2, n2, i, l, { isPacked: a, reverseWH: s, breakAxis: u });
        }, t.calculateTextureWidthAndHeight = (e2, n2, r2) => {
          const o2 = (0, t.createTextureLayoutFromTextureType)(e2, n2, r2);
          return [o2.width, o2.height];
        }, t.createTextureLayoutFromShape = (e2, t2, n2 = 1, o2, i) => {
          const a = !(!i || !i.isPacked), [s, u] = e2.computeTextureWH(a && o2 || t2, i), l = t2.length;
          let c = t2.slice(0);
          if (0 === l && (c = [1]), 1 === n2)
            o2 = t2;
          else if (a) {
            if (4 !== n2)
              throw new Error("a packed texture must be 4-channel");
            o2 = t2, l > 0 && (c[l - 1] = Math.ceil(c[l - 1] / 2)), l > 1 && (c[l - 2] = Math.ceil(c[l - 2] / 2));
          } else if (!o2)
            throw new Error("Unpacked shape is needed when using channels > 1");
          return { width: s, height: u, channels: n2, isPacked: a, shape: c, strides: r.ShapeUtil.computeStrides(c), unpackedShape: o2, reversedWH: i && i.reverseWH };
        };
      }, 5243: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.TextureManager = void 0;
        const r = n(1315);
        t.TextureManager = class {
          constructor(e2, t2, n2, r2) {
            this.glContext = e2, this.layoutStrategy = t2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
          }
          createTextureFromLayout(e2, t2, n2, o) {
            const i = this.toEncoderType(e2), a = this.glContext.getEncoder(i, t2.channels || 1, o);
            if (t2.isPacked && 1 === o)
              throw new Error("not implemented");
            const s = t2.width, u = t2.height;
            let l, c;
            if (this.config.reuseTextures) {
              l = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, c = this.inUseTextures.get(l), c || (c = [], this.inUseTextures.set(l, c));
              const t3 = this.idleTextures.get(l);
              if (t3 && t3.length > 0) {
                const r2 = t3.pop();
                return c.push(r2), 1 === o && this.glContext.updateTexture(r2, s, u, a, this.toTextureData(e2, n2)), r2;
              }
            }
            r.Logger.verbose("TextureManager", `Creating new texture of size ${t2.width}x${t2.height}`);
            const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(e2, n2));
            return this.config.reuseTextures && (c.push(p), this.textureLookup.set(p, l)), p;
          }
          readTexture(e2, t2, n2) {
            return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
              const r2 = e2.shape.reduce((e3, t3) => e3 * t3) * n2, o = this.glContext.readTexture(e2.texture, e2.width, e2.height, r2, this.toEncoderType(t2), n2);
              return this.toTensorData(t2, o);
            });
          }
          async readTextureAsync(e2, t2, n2) {
            const r2 = e2.tensor.dataId;
            if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
              const e3 = this.pendingRead.get(r2);
              return new Promise((t3) => null == e3 ? void 0 : e3.push(t3));
            }
            return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
              this.pendingRead.set(r2, []);
              const o = e2.shape.reduce((e3, t3) => e3 * t3) * n2;
              await this.glContext.createAndWaitForFence();
              const i = this.glContext.readTexture(e2.texture, e2.width, e2.height, o, this.toEncoderType(t2), n2), a = this.toTensorData(t2, i), s = this.pendingRead.get(r2);
              return this.pendingRead.delete(r2), null == s || s.forEach((e3) => e3(a)), a;
            });
          }
          readUint8TextureAsFloat(e2) {
            return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
              const t2 = e2.shape.reduce((e3, t3) => e3 * t3), n2 = this.glContext.readTexture(e2.texture, e2.width, e2.height, 4 * t2, "byte", 4);
              return new Float32Array(n2.buffer, n2.byteOffset, t2);
            });
          }
          releaseTexture(e2, t2) {
            let n2;
            if (this.config.reuseTextures && (n2 = this.textureLookup.get(e2.texture), n2)) {
              t2 && this.textureLookup.delete(n2);
              const r2 = this.inUseTextures.get(n2);
              if (r2) {
                const t3 = r2.indexOf(e2.texture);
                if (-1 !== t3) {
                  r2.splice(t3, 1);
                  let o = this.idleTextures.get(n2);
                  o || (o = [], this.idleTextures.set(n2, o)), o.push(e2.texture);
                }
              }
            }
            n2 && !t2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${e2.width}x${e2.height}`), this.glContext.deleteTexture(e2.texture));
          }
          toTensorData(e2, t2) {
            switch (e2) {
              case "int16":
                return t2 instanceof Int16Array ? t2 : Int16Array.from(t2);
              case "int32":
                return t2 instanceof Int32Array ? t2 : Int32Array.from(t2);
              case "int8":
                return t2 instanceof Int8Array ? t2 : Int8Array.from(t2);
              case "uint16":
                return t2 instanceof Uint16Array ? t2 : Uint16Array.from(t2);
              case "uint32":
                return t2 instanceof Uint32Array ? t2 : Uint32Array.from(t2);
              case "uint8":
              case "bool":
                return t2 instanceof Uint8Array ? t2 : Uint8Array.from(t2);
              case "float32":
                return t2 instanceof Float32Array ? t2 : Float32Array.from(t2);
              case "float64":
                return t2 instanceof Float64Array ? t2 : Float64Array.from(t2);
              default:
                throw new Error(`TensorData type ${e2} is not supported`);
            }
          }
          toTextureData(e2, t2) {
            if (t2)
              return t2 instanceof Float32Array ? t2 : new Float32Array(t2);
          }
          toEncoderType(e2) {
            return "float";
          }
          clearActiveTextures() {
            this.glContext.clearActiveTextures();
          }
        };
      }, 5639: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.TextureType = void 0, (n = t.TextureType || (t.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
      }, 432: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getGlChannels = t.getCoordsDataType = t.getSqueezedParams = t.squeezeInputShape = t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t.generateShaderFuncNameFromInputSamplerName = t.repeatedTry = t.getPackedShape = void 0;
        const r = n(7273);
        t.getPackedShape = function(e2) {
          const t2 = e2.length;
          return e2.slice(0, t2 - 1).concat(e2[t2 - 1] / 4);
        }, t.repeatedTry = async function(e2, t2 = (e3) => 0, n2) {
          return new Promise((r2, o) => {
            let i = 0;
            const a = () => {
              if (e2())
                return void r2();
              i++;
              const s = t2(i);
              null != n2 && i >= n2 ? o() : setTimeout(a, s);
            };
            a();
          });
        }, t.generateShaderFuncNameFromInputSamplerName = function(e2) {
          return (0, r.assert)(void 0 !== e2 && 0 !== e2.length, () => "empty string found for sampler name"), "get" + e2.charAt(0).toUpperCase() + e2.slice(1);
        }, t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(e2) {
          return (0, r.assert)(void 0 !== e2 && 0 !== e2.length, () => "empty string found for sampler name"), "get" + e2.charAt(0).toUpperCase() + e2.slice(1) + "AtOutCoords";
        }, t.squeezeInputShape = function(e2, t2) {
          let n2 = JSON.parse(JSON.stringify(e2));
          return n2 = t2, n2;
        }, t.getSqueezedParams = function(e2, t2) {
          return t2.map((t3) => e2[t3]).join(", ");
        }, t.getCoordsDataType = function(e2) {
          if (e2 <= 1)
            return "int";
          if (2 === e2)
            return "ivec2";
          if (3 === e2)
            return "ivec3";
          if (4 === e2)
            return "ivec4";
          if (5 === e2)
            return "ivec5";
          if (6 === e2)
            return "ivec6";
          throw Error(`GPU for rank ${e2} is not yet supported`);
        }, t.getGlChannels = function(e2 = 6) {
          return ["x", "y", "z", "w", "u", "v"].slice(0, e2);
        };
      }, 3389: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createNewWebGLContext = t.createWebGLContext = void 0;
        const r = n(1315), o = n(3524), i = {};
        function a(e2, t2) {
          let n2;
          const i2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
          if ((!t2 || "webgl2" === t2) && (n2 = e2.getContext("webgl2", i2), n2))
            try {
              return new o.WebGLContext(n2, 2);
            } catch (e3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e3}`);
            }
          if ((!t2 || "webgl" === t2) && (n2 = e2.getContext("webgl", i2) || e2.getContext("experimental-webgl", i2), n2))
            try {
              return new o.WebGLContext(n2, 1);
            } catch (e3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e3}`);
            }
          throw new Error("WebGL is not supported");
        }
        t.createWebGLContext = function e2(t2) {
          let n2;
          if (t2 && "webgl2" !== t2 || !("webgl2" in i) ? t2 && "webgl" !== t2 || !("webgl" in i) || (n2 = i.webgl) : n2 = i.webgl2, !n2)
            try {
              n2 = a(function() {
                if ("undefined" == typeof OffscreenCanvas)
                  throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
                return new OffscreenCanvas(1, 1);
              }(), t2);
            } catch (e3) {
              n2 = a(function() {
                if ("undefined" == typeof document)
                  throw new TypeError("failed to create canvas: document is not supported");
                const e4 = document.createElement("canvas");
                return e4.width = 1, e4.height = 1, e4;
              }(), t2);
            }
          t2 = t2 || 1 === n2.version ? "webgl" : "webgl2";
          const r2 = n2.gl;
          return i[t2] = n2, r2.isContextLost() ? (delete i[t2], e2(t2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
        }, t.createNewWebGLContext = a;
      }, 3524: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), i = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLContext = t.linearSearchLastTrue = void 0;
        const a = n(2235), s = i(n(9622)), u = n(432);
        function l(e2) {
          let t2 = 0;
          for (; t2 < e2.length && e2[t2](); ++t2)
            ;
          return t2 - 1;
        }
        t.linearSearchLastTrue = l, t.WebGLContext = class {
          constructor(e2, t2) {
            this.frameBufferBound = false, this.itemsToPoll = [], this.gl = e2, this.version = t2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
          }
          allocateTexture(e2, t2, n2, r2) {
            const o2 = this.gl, i2 = o2.createTexture();
            o2.bindTexture(o2.TEXTURE_2D, i2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.NEAREST), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.NEAREST), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE);
            const a2 = r2 ? n2.encode(r2, e2 * t2) : null;
            return o2.texImage2D(o2.TEXTURE_2D, 0, n2.internalFormat, e2, t2, 0, n2.format, n2.textureType, a2), this.checkError(), i2;
          }
          updateTexture(e2, t2, n2, r2, o2) {
            const i2 = this.gl;
            i2.bindTexture(i2.TEXTURE_2D, e2);
            const a2 = r2.encode(o2, t2 * n2);
            i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, t2, n2, r2.format, r2.textureType, a2), this.checkError();
          }
          attachFramebuffer(e2, t2, n2) {
            const r2 = this.gl;
            r2.bindTexture(r2.TEXTURE_2D, e2), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, e2, 0), this.checkError(), r2.viewport(0, 0, t2, n2), r2.scissor(0, 0, t2, n2);
          }
          readTexture(e2, t2, n2, r2, o2, i2) {
            const a2 = this.gl;
            i2 || (i2 = 1), this.frameBufferBound || this.attachFramebuffer(e2, t2, n2);
            const s2 = this.getEncoder(o2, i2), u2 = s2.allocate(t2 * n2);
            return a2.bindTexture(a2.TEXTURE_2D, e2), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, e2, 0), a2.readPixels(0, 0, t2, n2, a2.RGBA, s2.textureType, u2), this.checkError(), s2.decode(u2, r2);
          }
          isFramebufferReady() {
            return true;
          }
          getActiveTexture() {
            const e2 = this.gl;
            return "TEXTURE" + (e2.getParameter(this.gl.ACTIVE_TEXTURE) - e2.TEXTURE0);
          }
          getTextureBinding() {
            return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
          }
          getFramebufferBinding() {
            return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
          }
          setVertexAttributes(e2, t2) {
            const n2 = this.gl;
            n2.vertexAttribPointer(e2, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(e2), -1 !== t2 && (n2.vertexAttribPointer(t2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(t2)), this.checkError();
          }
          createProgram(e2, t2) {
            const n2 = this.gl, r2 = n2.createProgram();
            return n2.attachShader(r2, e2), n2.attachShader(r2, t2), n2.linkProgram(r2), r2;
          }
          compileShader(e2, t2) {
            const n2 = this.gl, r2 = n2.createShader(t2);
            if (!r2)
              throw new Error(`createShader() returned null with type ${t2}`);
            if (n2.shaderSource(r2, e2), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS))
              throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${e2}`);
            return r2;
          }
          deleteShader(e2) {
            this.gl.deleteShader(e2);
          }
          bindTextureToUniform(e2, t2, n2) {
            const r2 = this.gl;
            r2.activeTexture(r2.TEXTURE0 + t2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, e2), this.checkError(), r2.uniform1i(n2, t2), this.checkError();
          }
          draw() {
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
          }
          checkError() {
            if (a.env.debug) {
              const e2 = this.gl, t2 = e2.getError();
              let n2 = "";
              switch (t2) {
                case e2.NO_ERROR:
                  return;
                case e2.INVALID_ENUM:
                  n2 = "INVALID_ENUM";
                  break;
                case e2.INVALID_VALUE:
                  n2 = "INVALID_VALUE";
                  break;
                case e2.INVALID_OPERATION:
                  n2 = "INVALID_OPERATION";
                  break;
                case e2.INVALID_FRAMEBUFFER_OPERATION:
                  n2 = "INVALID_FRAMEBUFFER_OPERATION";
                  break;
                case e2.OUT_OF_MEMORY:
                  n2 = "OUT_OF_MEMORY";
                  break;
                case e2.CONTEXT_LOST_WEBGL:
                  n2 = "CONTEXT_LOST_WEBGL";
                  break;
                default:
                  n2 = `Unknown WebGL Error: ${t2.toString(16)}`;
              }
              throw new Error(n2);
            }
          }
          deleteTexture(e2) {
            this.gl.deleteTexture(e2);
          }
          deleteProgram(e2) {
            this.gl.deleteProgram(e2);
          }
          getEncoder(e2, t2, n2 = 0) {
            if (2 === this.version)
              return new s.RedFloat32DataEncoder(this.gl, t2);
            switch (e2) {
              case "float":
                return 1 === n2 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, t2) : new s.RGBAFloatDataEncoder(this.gl, t2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
              case "int":
                throw new Error("not implemented");
              case "byte":
                return new s.Uint8DataEncoder(this.gl, t2);
              default:
                throw new Error(`Invalid dataType: ${e2}`);
            }
          }
          clearActiveTextures() {
            const e2 = this.gl;
            for (let t2 = 0; t2 < this.maxTextureImageUnits; ++t2)
              e2.activeTexture(e2.TEXTURE0 + t2), e2.bindTexture(e2.TEXTURE_2D, null);
          }
          dispose() {
            if (this.disposed)
              return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteFramebuffer(this.framebuffer), e2.bindBuffer(e2.ARRAY_BUFFER, null), e2.deleteBuffer(this.vertexbuffer), e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null), e2.finish(), this.disposed = true;
          }
          createDefaultGeometry() {
            return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
          }
          createVertexbuffer() {
            const e2 = this.gl, t2 = e2.createBuffer();
            if (!t2)
              throw new Error("createBuffer() returned null");
            const n2 = this.createDefaultGeometry();
            return e2.bindBuffer(e2.ARRAY_BUFFER, t2), e2.bufferData(e2.ARRAY_BUFFER, n2, e2.STATIC_DRAW), this.checkError(), t2;
          }
          createFramebuffer() {
            const e2 = this.gl.createFramebuffer();
            if (!e2)
              throw new Error("createFramebuffer returned null");
            return e2;
          }
          queryVitalParameters() {
            const e2 = this.gl;
            if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
              throw new Error("both float32 and float16 TextureType are not supported");
            this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS), this.version;
          }
          getExtensions() {
            2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
          }
          checkFloatTextureAttachableToFrameBuffer() {
            const e2 = this.gl, t2 = e2.createTexture();
            e2.bindTexture(e2.TEXTURE_2D, t2);
            const n2 = 2 === this.version ? e2.RGBA32F : e2.RGBA;
            e2.texImage2D(e2.TEXTURE_2D, 0, n2, 1, 1, 0, e2.RGBA, e2.FLOAT, null);
            const r2 = e2.createFramebuffer();
            e2.bindFramebuffer(e2.FRAMEBUFFER, r2), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0);
            const o2 = e2.checkFramebufferStatus(e2.FRAMEBUFFER) === e2.FRAMEBUFFER_COMPLETE;
            return e2.bindTexture(e2.TEXTURE_2D, null), e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteTexture(t2), e2.deleteFramebuffer(r2), o2;
          }
          checkRenderFloat32() {
            if (2 === this.version) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else if (!this.textureFloatExtension)
              return false;
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Download() {
            if (2 === this.version) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else {
              if (!this.textureFloatExtension)
                return false;
              if (!this.gl.getExtension("WEBGL_color_buffer_float"))
                return false;
            }
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Blend() {
            const e2 = this.gl;
            let t2, n2, r2, o2, i2;
            try {
              t2 = e2.createTexture(), n2 = e2.createFramebuffer(), e2.bindTexture(e2.TEXTURE_2D, t2);
              const a2 = 2 === this.version ? e2.RGBA32F : e2.RGBA;
              return e2.texImage2D(e2.TEXTURE_2D, 0, a2, 1, 1, 0, e2.RGBA, e2.FLOAT, null), e2.bindFramebuffer(e2.FRAMEBUFFER, n2), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), e2.enable(e2.BLEND), r2 = e2.createShader(e2.VERTEX_SHADER), !!r2 && (e2.shaderSource(r2, "void main(){}"), e2.compileShader(r2), o2 = e2.createShader(e2.FRAGMENT_SHADER), !!o2 && (e2.shaderSource(o2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), e2.compileShader(o2), i2 = e2.createProgram(), !!i2 && (e2.attachShader(i2, r2), e2.attachShader(i2, o2), e2.linkProgram(i2), e2.useProgram(i2), e2.drawArrays(e2.POINTS, 0, 1), e2.getError() === e2.NO_ERROR)));
            } finally {
              e2.disable(e2.BLEND), i2 && e2.deleteProgram(i2), r2 && e2.deleteShader(r2), o2 && e2.deleteShader(o2), n2 && (e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteFramebuffer(n2)), t2 && (e2.bindTexture(e2.TEXTURE_2D, null), e2.deleteTexture(t2));
            }
          }
          beginTimer() {
            if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
              const e2 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension, n2 = e2.createQuery();
              return e2.beginQuery(t2.TIME_ELAPSED_EXT, n2), n2;
            }
            throw new Error("WebGL1 profiling currently not supported.");
          }
          endTimer() {
            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const e2 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension;
              e2.endQuery(t2.TIME_ELAPSED_EXT);
            }
          }
          isTimerResultAvailable(e2) {
            let t2 = false, n2 = false;
            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const r2 = this.gl, o2 = this.disjointTimerQueryWebgl2Extension;
              t2 = r2.getQueryParameter(e2, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(o2.GPU_DISJOINT_EXT);
            }
            return t2 && !n2;
          }
          getTimerResult(e2) {
            let t2 = 0;
            if (2 !== this.version)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const n2 = this.gl;
              t2 = n2.getQueryParameter(e2, n2.QUERY_RESULT), n2.deleteQuery(e2);
            }
            return t2 / 1e6;
          }
          async waitForQueryAndGetTime(e2) {
            return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(e2)), this.getTimerResult(e2);
          }
          async createAndWaitForFence() {
            const e2 = this.createFence(this.gl);
            return this.pollFence(e2);
          }
          createFence(e2) {
            let t2;
            const n2 = e2, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return e2.flush(), t2 = null === r2 ? () => true : () => {
              const e3 = n2.clientWaitSync(r2, 0, 0);
              return e3 === n2.ALREADY_SIGNALED || e3 === n2.CONDITION_SATISFIED;
            }, { query: r2, isFencePassed: t2 };
          }
          async pollFence(e2) {
            return new Promise((t2) => {
              this.addItemToPoll(() => e2.isFencePassed(), () => t2());
            });
          }
          pollItems() {
            const e2 = l(this.itemsToPoll.map((e3) => e3.isDoneFn));
            for (let t2 = 0; t2 <= e2; ++t2) {
              const { resolveFn: e3 } = this.itemsToPoll[t2];
              e3();
            }
            this.itemsToPoll = this.itemsToPoll.slice(e2 + 1);
          }
          async addItemToPoll(e2, t2) {
            this.itemsToPoll.push({ isDoneFn: e2, resolveFn: t2 }), this.itemsToPoll.length > 1 || await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
          }
        };
      }, 6496: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ExecutionPlan = void 0;
        const r = n(1315);
        class o {
          constructor(e2, t2) {
            this.op = e2, this.node = t2;
          }
        }
        t.ExecutionPlan = class {
          constructor(e2, t2, n2) {
            this.graph = e2, this.profiler = n2, this.initialize(t2);
          }
          initialize(e2) {
            this.profiler.event("session", "ExecutionPlan.initialize", () => {
              const t2 = this.graph.getNodes();
              if (t2.length !== e2.length)
                throw new Error("The size of nodes and OPs do not match.");
              this._ops = e2.map((e3, n2) => new o(e3, t2[n2])), this.reset(), this._starter = [], this._ops.forEach((e3, t3) => {
                let n2 = true;
                for (const t4 of e3.node.inputs)
                  if (!this._values[t4] && -1 === this.graph.getInputIndices().indexOf(t4)) {
                    n2 = false;
                    break;
                  }
                n2 && this._starter.push(t3);
              });
            });
          }
          reset() {
            this._values = this.graph.getValues().map((e2) => e2.tensor);
          }
          async execute(e2, t2) {
            return this.profiler.event("session", "ExecutionPlan.execute", async () => {
              this.reset();
              const n2 = e2.createInferenceHandler(), o2 = this.graph.getInputIndices();
              if (t2.length !== o2.length)
                throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t2.length} expected: ${o2.length}`);
              t2.forEach((e3, t3) => {
                const n3 = o2[t3];
                this._values[n3] = e3;
              });
              const i = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
              let u = 0;
              for (; u < i.length; ) {
                const e3 = i[u++], t3 = this._ops[e3], o3 = t3.node.inputs.map((e4) => this._values[e4]);
                if (-1 !== o3.indexOf(void 0))
                  throw new Error(`unresolved input detected: op: ${t3.node}`);
                const l2 = o3;
                r.Logger.verbose("ExecPlan", `Runing op:${t3.node.name} (${l2.map((e4, n3) => `'${t3.node.inputs[n3]}': ${e4.type}[${e4.dims.join(",")}]`).join(", ")})`);
                const c = await this.profiler.event("node", t3.node.name, async () => t3.op.impl(n2, l2, t3.op.context));
                if (c.length !== t3.node.outputs.length)
                  throw new Error("the size of output does not match model definition.");
                c.forEach((e4, n3) => {
                  const r2 = t3.node.outputs[n3];
                  if (this._values[r2])
                    throw new Error(`output [${r2}] already has value: op:${t3.node.name}`);
                  this._values[r2] = e4;
                });
                const p = /* @__PURE__ */ new Set();
                c.forEach((e4, n3) => {
                  const r2 = t3.node.outputs[n3];
                  for (const e5 of a[r2].to) {
                    const t4 = s[e5];
                    let n4 = true;
                    for (const e6 of t4.inputs)
                      if (!this._values[e6]) {
                        n4 = false;
                        break;
                      }
                    n4 && p.add(e5);
                  }
                }), i.push(...p);
              }
              const l = [];
              for (let e3 = 0; e3 < this.graph.getOutputIndices().length; e3++) {
                const t3 = this.graph.getOutputIndices()[e3], n3 = this._values[t3];
                if (void 0 === n3)
                  throw new Error(`required output [${t3}] does not have value`);
                0 === t3 ? await n3.getData() : n3.data, l.push(n3);
              }
              return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), l;
            });
          }
        };
      }, 4662: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Graph = void 0;
        const r = n(6874), o = n(5127), i = n(2446), a = n(9240), s = n(7273);
        var u = o.onnxruntime.experimental.fbs;
        t.Graph = { from: (e2, t2) => new p(e2, t2) };
        class l {
          constructor(e2) {
            this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e2 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(e2.type.tensorType));
          }
          get from() {
            return this._from;
          }
          get to() {
            return this._to;
          }
        }
        class c {
          constructor(e2, t2) {
            e2 instanceof i.onnx.NodeProto ? (this.name = e2.name, this.opType = e2.opType, this.attributes = new r.Attribute(e2.attribute)) : e2 instanceof u.Node && (this.name = null != t2 ? t2 : e2.name(), this.opType = e2.opType(), this.attributes = new r.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e2))), this.inputs = [], this.outputs = [], this.executeNode = true;
          }
        }
        class p {
          constructor(e2, t2) {
            if (!e2)
              throw new TypeError("graph is empty");
            this.buildGraph(e2), this.transformGraph(t2), this.checkIsAcyclic();
          }
          getInputIndices() {
            return this._allInputIndices;
          }
          getInputNames() {
            return this._allInputNames;
          }
          getOutputIndices() {
            return this._allOutputIndices;
          }
          getOutputNames() {
            return this._allOutputNames;
          }
          getValues() {
            return this._allData;
          }
          getNodes() {
            return this._nodes;
          }
          buildGraph(e2) {
            if (e2 instanceof i.onnx.GraphProto)
              this.buildGraphFromOnnxFormat(e2);
            else {
              if (!(e2 instanceof u.Graph))
                throw new TypeError("Graph type is not supported.");
              this.buildGraphFromOrtFormat(e2);
            }
          }
          buildGraphFromOnnxFormat(e2) {
            const t2 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            const n2 = /* @__PURE__ */ new Map();
            if (!e2.input)
              throw new Error("missing information in graph: input");
            const r2 = [];
            for (const n3 of e2.input) {
              if (t2.has(n3.name))
                throw new Error(`duplicated input name: ${n3.name}`);
              const e3 = this._allData.push(new l(n3)) - 1;
              t2.set(n3.name, e3), r2.push(n3.name);
            }
            if (!e2.initializer)
              throw new Error("missing information in graph: initializer");
            for (const n3 of e2.initializer) {
              let e3 = t2.get(n3.name);
              if (void 0 === e3) {
                const r3 = new l();
                r3.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, e3 = this._allData.push(r3) - 1, t2.set(n3.name, e3);
              }
              this._allData[e3]._from = -1, this._allData[e3].tensor = a.Tensor.fromProto(n3);
            }
            for (let e3 = 0; e3 < this._allData.length; e3++)
              this._allData[e3].tensor || (this._allInputIndices.push(e3), this._allInputNames.push(r2[e3]));
            if (!e2.output)
              throw new Error("missing information in graph: output");
            for (const n3 of e2.output) {
              if (t2.has(n3.name))
                throw new Error(`duplicated output name: ${n3.name}`);
              const e3 = this._allData.push(new l(n3)) - 1;
              t2.set(n3.name, e3), this._allOutputIndices.push(e3), this._allOutputNames.push(n3.name);
            }
            if (!e2.node)
              throw new Error("missing information in graph: node");
            for (const t3 of e2.node) {
              if (!t3.name)
                for (let e4 = 0; ; e4++) {
                  const r3 = `unnamed_${t3.opType}_${e4}`;
                  if (!n2.has(r3)) {
                    t3.name = r3;
                    break;
                  }
                }
              if (n2.has(t3.name))
                throw new Error(`duplicated node name: ${t3.name}`);
              const e3 = this._nodes.push(new c(t3)) - 1;
              n2.set(t3.name, e3);
            }
            for (let n3 = 0; n3 < this._nodes.length; n3++) {
              const r3 = this._nodes[n3], o2 = e2.node[n3];
              if (!o2.output)
                throw new Error(`missing output for node: ${o2.name}`);
              for (const e3 of o2.output) {
                let i2 = t2.get(e3);
                if (void 0 === i2 && (i2 = this._allData.push(new l()) - 1, t2.set(e3, i2)), r3.outputs.push(i2), void 0 !== this._allData[i2]._from)
                  throw new Error(`multiple nodes output to one data value: ${i2}`);
                if (this._allData[i2]._from = n3, "Constant" === o2.opType) {
                  if (!o2.attribute || 1 !== o2.attribute.length || !o2.attribute[0].t)
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (!o2.output || 1 !== o2.output.length)
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  r3.outputs.pop(), r3.executeNode = false, this._allData[i2]._from = -1, this._allData[i2].tensor = a.Tensor.fromProto(o2.attribute[0].t);
                }
              }
            }
            for (let n3 = 0; n3 < this._nodes.length; n3++) {
              const r3 = this._nodes[n3], o2 = e2.node[n3];
              if (!o2.input)
                throw new Error(`missing input for node: ${o2.name}`);
              for (const e3 of o2.input) {
                const i2 = t2.get(e3);
                if (void 0 === i2) {
                  if ("" === e3 && (3 === o2.input.length || 4 === o2.input.length) && "Resize" === o2.opType)
                    continue;
                  throw new Error(`unrecognized input '${e3}' for node: ${o2.name}`);
                }
                r3.inputs.push(i2), this._allData[i2]._to.push(n3);
              }
            }
            return true;
          }
          buildGraphFromOrtFormat(e2) {
            var t2, n2, r2;
            const o2 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            const i2 = /* @__PURE__ */ new Map(), p2 = [];
            for (let i3 = 0; i3 < e2.inputsLength(); i3++) {
              const a2 = e2.inputs(i3);
              if (o2.has(a2))
                throw new Error(`duplicated input name: ${a2}`);
              for (let i4 = 0; i4 < e2.nodeArgsLength(); i4++)
                if ((null === (t2 = e2.nodeArgs(i4)) || void 0 === t2 ? void 0 : t2.name()) === a2) {
                  const t3 = new l();
                  if ((null === (r2 = null === (n2 = e2.nodeArgs(i4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== u.TypeInfoValue.tensor_type)
                    throw new Error("Unexpected value type for the nodeArg.");
                  const c2 = e2.nodeArgs(i4).type().value(new u.TensorTypeAndShape()), d = s.ProtoUtil.tensorDataTypeFromProto(c2.elemType()), f = c2.shape(), h = [];
                  for (let e3 = 0; e3 < f.dimLength(); e3++)
                    h.push(s.LongUtil.longToNumber(f.dim(e3).value().dimValue()));
                  t3.type = { shape: { dims: h }, tensorType: d };
                  const g = this._allData.push(t3) - 1;
                  o2.set(a2, g), p2.push(a2);
                }
            }
            for (let t3 = 0; t3 < e2.initializersLength(); t3++) {
              const n3 = e2.initializers(t3);
              let r3 = o2.get(n3.name());
              if (void 0 === r3) {
                const e3 = new l(), t4 = s.ProtoUtil.tensorDimsFromORTFormat(n3), i3 = s.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                e3.type = { shape: { dims: t4 }, tensorType: i3 }, r3 = this._allData.push(e3) - 1, o2.set(n3.name(), r3);
              }
              this._allData[r3]._from = -1, this._allData[r3].tensor = a.Tensor.fromOrtTensor(n3);
            }
            for (let e3 = 0; e3 < this._allData.length; e3++)
              this._allData[e3].tensor || (this._allInputIndices.push(e3), this._allInputNames.push(p2[e3]));
            for (let t3 = 0; t3 < e2.outputsLength(); t3++) {
              const n3 = e2.outputs(t3);
              if (o2.has(n3))
                throw new Error(`duplicated output name: ${n3}`);
              const r3 = this._allData.push(new l()) - 1;
              o2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
            }
            if (!e2.nodes)
              throw new Error("missing information in graph: node");
            for (let t3 = 0; t3 < e2.nodesLength(); t3++) {
              const n3 = e2.nodes(t3);
              let r3 = n3.name();
              if (!r3)
                for (let e3 = 0; r3 = `unnamed_${n3.opType()}_${e3}`, i2.has(r3); e3++)
                  ;
              if (i2.has(r3))
                throw new Error(`duplicated node name: ${r3}`);
              const o3 = this._nodes.push(new c(n3, r3)) - 1;
              i2.set(r3, o3);
            }
            for (let t3 = 0; t3 < this._nodes.length; t3++) {
              const n3 = this._nodes[t3], r3 = e2.nodes(t3);
              if (null == r3)
                throw new Error(`No node exists at index ${t3}`);
              if (0 === (null == r3 ? void 0 : r3.outputsLength()))
                throw new Error(`missing output for node: ${r3.name}`);
              for (let e3 = 0; e3 < (null == r3 ? void 0 : r3.outputsLength()); e3++) {
                const i3 = null == r3 ? void 0 : r3.outputs(e3);
                let s2 = o2.get(i3);
                if (void 0 === s2 && (s2 = this._allData.push(new l()) - 1, o2.set(i3, s2)), n3.outputs.push(s2), void 0 !== this._allData[s2]._from)
                  throw new Error(`multiple nodes output to one data value: ${s2}`);
                if (this._allData[s2]._from = t3, "Constant" === r3.opType()) {
                  if (1 !== r3.attributesLength() || !r3.attributes(0).t())
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (1 !== r3.outputsLength())
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  n3.outputs.pop(), n3.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r3.attributes(0).t());
                }
              }
            }
            for (let t3 = 0; t3 < this._nodes.length; t3++) {
              const n3 = this._nodes[t3], r3 = e2.nodes(t3);
              if (0 === r3.inputsLength())
                throw new Error(`missing input for node: ${r3.name}`);
              for (let e3 = 0; e3 < r3.inputsLength(); e3++) {
                const i3 = r3.inputs(e3), a2 = o2.get(i3);
                if (void 0 === a2)
                  throw new Error(`unrecognized input '${i3}' for node: ${r3.name()}`);
                n3.inputs.push(a2), this._allData[a2]._to.push(t3);
              }
            }
          }
          checkIsAcyclic() {
            const e2 = /* @__PURE__ */ new Set();
            this._allInputIndices.forEach((t3) => {
              this._allData[t3]._to.forEach((t4) => {
                e2.add(t4);
              });
            });
            const t2 = Array.from(e2), n2 = new Array(this._nodes.length).fill("white");
            for (; t2.length > 0; ) {
              const e3 = t2.pop();
              "gray" === n2[e3] ? n2[e3] = "black" : (t2.push(e3), n2[e3] = "gray", this._nodes[e3].outputs.forEach((r2) => {
                const o2 = this._allData[r2];
                if (void 0 !== o2.tensor)
                  throw new Error("node outputs should not be initialized");
                if (o2._from !== e3)
                  throw new Error("from property of the Value object doesn't match index of Node being processed");
                o2._to.forEach((e4) => {
                  if ("gray" === n2[e4])
                    throw new Error("model graph is cyclic");
                  "white" === n2[e4] && t2.push(e4);
                });
              }));
            }
          }
          transformGraph(e2) {
            this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e2 && e2.transformGraph(this), this.finalizeGraph();
          }
          finalizeGraph() {
            let e2 = 0;
            const t2 = new Array(this._nodes.length, 0);
            let n2 = 0;
            for (let e3 = 0; e3 < this._nodes.length; e3++)
              t2[e3] = n2, this._nodes[e3].executeNode ? (n2 !== e3 && (this._nodes[n2] = this._nodes[e3]), n2++) : this._nodes[e3].outputs.forEach((e4) => {
                this._allData[e4]._from = -2;
              });
            this._nodes.splice(n2, this._nodes.length - n2);
            for (let e3 = 0; e3 < this._allData.length; e3++) {
              const n3 = this._allData[e3];
              void 0 !== n3._from && -1 !== n3._from && -2 !== n3._from && (n3._from = t2[n3._from]);
              for (let e4 = 0; e4 < n3._to.length; e4++) {
                if (!(n3._to[e4] >= 0))
                  throw new Error("Trying to update a removed node");
                n3._to[e4] = t2[n3._to[e4]];
              }
            }
            e2 = 0;
            for (let t3 = 0; t3 < this._allData.length; t3++)
              if (-2 !== this._allData[t3].from || -1 !== this._allOutputIndices.indexOf(t3 + e2)) {
                if (e2 > 0) {
                  let n3 = -1;
                  void 0 !== this._allData[t3].from && -1 !== this._allData[t3].from ? (n3 = this._nodes[this._allData[t3].from].outputs.indexOf(t3 + e2), -1 !== n3 && (this._nodes[this._allData[t3].from].outputs[n3] = t3)) : (n3 = this._allInputIndices.indexOf(t3 + e2), -1 !== n3 && (this._allInputIndices[n3] = t3)), this._allData[t3].to.forEach((r2) => {
                    n3 = this._nodes[r2].inputs.indexOf(t3 + e2), -1 !== n3 && (this._nodes[r2].inputs[n3] = t3);
                  }), 0 === this._allData[t3].to.length && (n3 = this._allOutputIndices.indexOf(t3 + e2), -1 !== n3 && (this._allOutputIndices[n3] = t3));
                }
              } else
                e2++, this._allData.splice(t3, 1), t3--;
          }
          deleteNode(e2) {
            const t2 = this._nodes[e2];
            if (t2.outputs.length > 1) {
              for (let e3 = 1; e3 < t2.outputs.length; e3++)
                if (this._allData[t2.outputs[e3]].to.length > 0)
                  throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
            }
            t2.executeNode = false;
            const n2 = t2.inputs[0], r2 = t2.outputs[0], o2 = this._allData[r2].to;
            for (let n3 = 0; n3 < t2.inputs.length; n3++) {
              const r3 = this._allData[t2.inputs[n3]].to.indexOf(e2);
              if (-1 === r3)
                throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[t2.inputs[n3]].to.splice(r3, 1);
            }
            this._allData[r2]._to = [];
            const i2 = this._allOutputIndices.indexOf(r2);
            if (-1 !== i2 && (this._allOutputIndices[i2] = n2), o2 && o2.length > 0)
              for (const e3 of o2) {
                const t3 = this._nodes[e3].inputs.indexOf(r2);
                if (-1 === t3)
                  throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                this._nodes[e3].inputs[t3] = n2, this._allData[n2].to.push(e3);
              }
          }
          removeAllDropoutNodes() {
            let e2 = 0;
            for (const t2 of this._nodes) {
              if ("Dropout" === t2.opType) {
                if (1 !== t2.inputs.length)
                  throw new Error("Dropout nodes should only contain one input. ");
                if (1 !== t2.outputs.length && 2 !== t2.outputs.length)
                  throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                if (2 === t2.outputs.length && 0 !== this._allData[t2.outputs[1]]._to.length)
                  throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                this.deleteNode(e2);
              }
              e2++;
            }
          }
          removeAllIdentityNodes() {
            let e2 = 0;
            for (const t2 of this._nodes)
              "Identity" === t2.opType && this.deleteNode(e2), e2++;
          }
          isActivation(e2) {
            switch (e2.opType) {
              case "Relu":
              case "Sigmoid":
              case "Clip":
                return true;
              default:
                return false;
            }
          }
          fuseConvActivationNodes() {
            for (const e2 of this._nodes)
              if ("Conv" === e2.opType) {
                const t2 = this._allData[e2.outputs[0]]._to;
                if (1 === t2.length && this.isActivation(this._nodes[t2[0]])) {
                  const n2 = this._nodes[t2[0]];
                  if ("Clip" === n2.opType)
                    if (1 === n2.inputs.length)
                      try {
                        e2.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                      } catch (t3) {
                        e2.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
                      }
                    else {
                      if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor))
                        continue;
                      e2.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                    }
                  e2.attributes.set("activation", "string", n2.opType), this.deleteNode(t2[0]);
                }
              }
          }
        }
      }, 1315: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.now = t.Profiler = t.Logger = void 0;
        const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
          log(e2, t2, n2) {
          }
        }(), console: new class {
          log(e2, t2, n2) {
            console.log(`${this.color(e2)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${t2}`);
          }
          color(e2) {
            switch (e2) {
              case "verbose":
                return "\x1B[34;40mv\x1B[0m";
              case "info":
                return "\x1B[32mi\x1B[0m";
              case "warning":
                return "\x1B[30;43mw\x1B[0m";
              case "error":
                return "\x1B[31;40me\x1B[0m";
              case "fatal":
                return "\x1B[101mf\x1B[0m";
              default:
                throw new Error(`unsupported severity: ${e2}`);
            }
          }
        }() }, o = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
        let i = { "": o };
        function a(e2, t2, n2, r2) {
          if (void 0 === t2)
            return o2 = e2, { verbose: a.verbose.bind(null, o2), info: a.info.bind(null, o2), warning: a.warning.bind(null, o2), error: a.error.bind(null, o2), fatal: a.fatal.bind(null, o2) };
          if (void 0 === n2)
            s(e2, t2);
          else if ("number" == typeof n2 && void 0 === r2)
            s(e2, t2);
          else if ("string" == typeof n2 && void 0 === r2)
            s(e2, n2, 0, t2);
          else {
            if ("string" != typeof n2 || "number" != typeof r2)
              throw new TypeError("input is valid");
            s(e2, n2, 0, t2);
          }
          var o2;
        }
        function s(e2, t2, o2, a2) {
          const s2 = i[a2 || ""] || i[""];
          n[e2] < n[s2.minimalSeverity] || (s2.logDateTime && (t2 = `${(/* @__PURE__ */ new Date()).toISOString()}|${t2}`), s2.logSourceLocation, r[s2.provider].log(e2, t2, a2));
        }
        !function(e2) {
          function t2(e3) {
            i = {}, n2("", e3 || {});
          }
          function n2(e3, n3) {
            if ("*" === e3)
              t2(n3);
            else {
              const t3 = i[e3] || o;
              i[e3] = { provider: n3.provider || t3.provider, minimalSeverity: n3.minimalSeverity || t3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? t3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? t3.logSourceLocation : n3.logSourceLocation };
            }
          }
          e2.verbose = function(t3, n3) {
            e2("verbose", t3, n3);
          }, e2.info = function(t3, n3) {
            e2("info", t3, n3);
          }, e2.warning = function(t3, n3) {
            e2("warning", t3, n3);
          }, e2.error = function(t3, n3) {
            e2("error", t3, n3);
          }, e2.fatal = function(t3, n3) {
            e2("fatal", t3, n3);
          }, e2.reset = t2, e2.set = n2, e2.setWithEnv = function(e3) {
            const t3 = {};
            e3.logLevel && (t3.minimalSeverity = e3.logLevel), n2("", t3);
          };
        }(a || (a = {})), t.Logger = a;
        class u {
          constructor(e2, t2, n2, r2, o2, i2) {
            this.category = e2, this.name = t2, this.startTime = n2, this.endCallback = r2, this.timer = o2, this.ctx = i2;
          }
          async end() {
            return this.endCallback(this);
          }
          async checkTimer() {
            if (void 0 === this.ctx || void 0 === this.timer)
              throw new Error("No webgl timer found");
            return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
          }
        }
        class l {
          constructor(e2, t2, n2, r2) {
            this.category = e2, this.name = t2, this.startTime = n2, this.endTime = r2;
          }
        }
        t.Profiler = class {
          static create(e2) {
            return void 0 === e2 ? new this() : new this(e2.maxNumberEvents, e2.flushBatchSize, e2.flushIntervalInMilliseconds);
          }
          constructor(e2, t2, n2) {
            this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === e2 ? 1e4 : e2, this._flushBatchSize = void 0 === t2 ? 10 : t2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
          }
          start() {
            this._started = true, this._timingEvents = [], this._flushTime = (0, t.now)(), this._flushPointer = 0;
          }
          stop() {
            for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++)
              this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
          event(e2, t2, n2, r2) {
            const o2 = this._started ? this.begin(e2, t2, r2) : void 0;
            let i2 = false;
            const a2 = n2();
            if (a2 && "function" == typeof a2.then)
              return i2 = true, new Promise((e3, t3) => {
                a2.then(async (t4) => {
                  o2 && await o2.end(), e3(t4);
                }, async (e4) => {
                  o2 && await o2.end(), t3(e4);
                });
              });
            if (!i2 && o2) {
              const e3 = o2.end();
              if (e3 && "function" == typeof e3.then)
                return new Promise((t3, n3) => {
                  e3.then(() => {
                    t3(a2);
                  }, (e4) => {
                    n3(e4);
                  });
                });
            }
            return a2;
          }
          begin(e2, n2, r2) {
            if (!this._started)
              throw new Error("profiler is not started yet");
            if (void 0 === r2) {
              const r3 = (0, t.now)();
              return this.flush(r3), new u(e2, n2, r3, (e3) => this.endSync(e3));
            }
            {
              const t2 = r2.beginTimer();
              return new u(e2, n2, 0, async (e3) => this.end(e3), t2, r2);
            }
          }
          async end(e2) {
            const t2 = await e2.checkTimer();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e2.category, e2.name, e2.startTime, t2)), this.flush(t2));
          }
          endSync(e2) {
            const n2 = (0, t.now)();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e2.category, e2.name, e2.startTime, n2)), this.flush(n2));
          }
          logOneEvent(e2) {
            t.Logger.verbose(`Profiler.${e2.category}`, `${(e2.endTime - e2.startTime).toFixed(2)}ms on event '${e2.name}' at ${e2.endTime.toFixed(2)}`);
          }
          flush(e2) {
            if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e2 - this._flushTime >= this._flushIntervalInMilliseconds) {
              for (const e3 = this._flushPointer; this._flushPointer < e3 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                this.logOneEvent(this._timingEvents[this._flushPointer]);
              this._flushTime = (0, t.now)();
            }
          }
          get started() {
            return this._started;
          }
        }, t.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
      }, 1745: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Model = void 0;
        const r = n(5686), o = n(4662), i = n(5127), a = n(2446), s = n(7273);
        var u = i.onnxruntime.experimental.fbs;
        t.Model = class {
          constructor() {
          }
          load(e2, t2, n2) {
            if (!n2)
              try {
                return void this.loadFromOnnxFormat(e2, t2);
              } catch (e3) {
                if (void 0 !== n2)
                  throw e3;
              }
            this.loadFromOrtFormat(e2, t2);
          }
          loadFromOnnxFormat(e2, t2) {
            const n2 = a.onnx.ModelProto.decode(e2);
            if (s.LongUtil.longToNumber(n2.irVersion) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = n2.opsetImport.map((e3) => ({ domain: e3.domain, version: s.LongUtil.longToNumber(e3.version) })), this._graph = o.Graph.from(n2.graph, t2);
          }
          loadFromOrtFormat(e2, t2) {
            const n2 = new r.flatbuffers.ByteBuffer(e2), i2 = u.InferenceSession.getRootAsInferenceSession(n2).model();
            if (s.LongUtil.longToNumber(i2.irVersion()) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = [];
            for (let e3 = 0; e3 < i2.opsetImportLength(); e3++) {
              const t3 = i2.opsetImport(e3);
              this._opsets.push({ domain: null == t3 ? void 0 : t3.domain(), version: s.LongUtil.longToNumber(t3.version()) });
            }
            this._graph = o.Graph.from(i2.graph(), t2);
          }
          get graph() {
            return this._graph;
          }
          get opsets() {
            return this._opsets;
          }
        };
      }, 6145: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FLOAT_TYPES = t.INT_TYPES = t.NUMBER_TYPES = void 0, t.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], t.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], t.FLOAT_TYPES = ["float32", "float64"];
      }, 5881: (e, t) => {
        "use strict";
        function n(e2, t2) {
          if (t2.endsWith("+")) {
            const n2 = Number.parseInt(t2.substring(0, t2.length - 1), 10);
            return !isNaN(n2) && n2 <= e2;
          }
          if (2 === t2.split("-").length) {
            const n2 = t2.split("-"), r = Number.parseInt(n2[0], 10), o = Number.parseInt(n2[1], 10);
            return !isNaN(r) && !isNaN(o) && r <= e2 && e2 <= o;
          }
          return Number.parseInt(t2, 10) === e2;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveOperator = void 0, t.resolveOperator = function(e2, t2, r) {
          for (const o of r) {
            const r2 = o[0], i = o[1], a = o[2], s = o[3], u = o[4];
            if (e2.opType === r2) {
              for (const e3 of t2)
                if ((e3.domain === i || "ai.onnx" === e3.domain && "" === i) && n(e3.version, a))
                  return { opImpl: s, opInit: u };
            }
          }
          throw new TypeError(`cannot resolve operator '${e2.opType}' with opsets: ${t2.map((e3) => `${e3.domain || "ai.onnx"} v${e3.version}`).join(", ")}`);
        };
      }, 5127: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.onnxruntime = void 0;
        const r = n(5686);
        var o, i;
        o = t.onnxruntime || (t.onnxruntime = {}), function(e2) {
          let t2;
          !function(e3) {
            e3[e3.UNDEFINED = 0] = "UNDEFINED", e3[e3.FLOAT = 1] = "FLOAT", e3[e3.INT = 2] = "INT", e3[e3.STRING = 3] = "STRING", e3[e3.TENSOR = 4] = "TENSOR", e3[e3.GRAPH = 5] = "GRAPH", e3[e3.FLOATS = 6] = "FLOATS", e3[e3.INTS = 7] = "INTS", e3[e3.STRINGS = 8] = "STRINGS", e3[e3.TENSORS = 9] = "TENSORS", e3[e3.GRAPHS = 10] = "GRAPHS", e3[e3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", e3[e3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
          }(t2 = e2.AttributeType || (e2.AttributeType = {}));
        }((i = o.experimental || (o.experimental = {})).fbs || (i.fbs = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.UNKNOWN = 0] = "UNKNOWN", e5[e5.VALUE = 1] = "VALUE", e5[e5.PARAM = 2] = "PARAM";
              }(t2 = e4.DimensionValueType || (e4.DimensionValueType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.UNDEFINED = 0] = "UNDEFINED", e5[e5.FLOAT = 1] = "FLOAT", e5[e5.UINT8 = 2] = "UINT8", e5[e5.INT8 = 3] = "INT8", e5[e5.UINT16 = 4] = "UINT16", e5[e5.INT16 = 5] = "INT16", e5[e5.INT32 = 6] = "INT32", e5[e5.INT64 = 7] = "INT64", e5[e5.STRING = 8] = "STRING", e5[e5.BOOL = 9] = "BOOL", e5[e5.FLOAT16 = 10] = "FLOAT16", e5[e5.DOUBLE = 11] = "DOUBLE", e5[e5.UINT32 = 12] = "UINT32", e5[e5.UINT64 = 13] = "UINT64", e5[e5.COMPLEX64 = 14] = "COMPLEX64", e5[e5.COMPLEX128 = 15] = "COMPLEX128", e5[e5.BFLOAT16 = 16] = "BFLOAT16", e5[e5.FLOAT8E4M3FN = 17] = "FLOAT8E4M3FN", e5[e5.FLOAT8E4M3FNUZ = 18] = "FLOAT8E4M3FNUZ", e5[e5.FLOAT8E5M2 = 19] = "FLOAT8E5M2", e5[e5.FLOAT8E5M2FNUZ = 20] = "FLOAT8E5M2FNUZ";
              }(t2 = e4.TensorDataType || (e4.TensorDataType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.Primitive = 0] = "Primitive", e5[e5.Fused = 1] = "Fused";
              }(t2 = e4.NodeType || (e4.NodeType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.NONE = 0] = "NONE", e5[e5.tensor_type = 1] = "tensor_type", e5[e5.sequence_type = 2] = "sequence_type", e5[e5.map_type = 3] = "map_type";
              }(t2 = e4.TypeInfoValue || (e4.TypeInfoValue = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsShape(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsShape(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                dim(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 4);
                  return r2 ? (n3 || new e2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                dimLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startShape(e3) {
                  e3.startObject(1);
                }
                static addDim(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static createDimVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startDimVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endShape(e3) {
                  return e3.endObject();
                }
                static createShape(e3, t4) {
                  return n2.startShape(e3), n2.addDim(e3, t4), n2.endShape(e3);
                }
              }
              t3.Shape = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsDimension(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsDimension(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                value(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                denotation(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startDimension(e3) {
                  e3.startObject(2);
                }
                static addValue(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDenotation(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endDimension(e3) {
                  return e3.endObject();
                }
                static createDimension(e3, t4, r2) {
                  return n2.startDimension(e3), n2.addValue(e3, t4), n2.addDenotation(e3, r2), n2.endDimension(e3);
                }
              }
              t3.Dimension = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsDimensionValue(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsDimensionValue(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                dimType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt8(this.bb_pos + t4) : e2.experimental.fbs.DimensionValueType.UNKNOWN;
                }
                dimValue() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                dimParam(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startDimensionValue(e3) {
                  e3.startObject(3);
                }
                static addDimType(t4, n3) {
                  t4.addFieldInt8(0, n3, e2.experimental.fbs.DimensionValueType.UNKNOWN);
                }
                static addDimValue(e3, t4) {
                  e3.addFieldInt64(1, t4, e3.createLong(0, 0));
                }
                static addDimParam(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endDimensionValue(e3) {
                  return e3.endObject();
                }
                static createDimensionValue(e3, t4, r2, o2) {
                  return n2.startDimensionValue(e3), n2.addDimType(e3, t4), n2.addDimValue(e3, r2), n2.addDimParam(e3, o2), n2.endDimensionValue(e3);
                }
              }
              t3.DimensionValue = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTensorTypeAndShape(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTensorTypeAndShape(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                elemType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                shape(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startTensorTypeAndShape(e3) {
                  e3.startObject(2);
                }
                static addElemType(t4, n3) {
                  t4.addFieldInt32(0, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addShape(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endTensorTypeAndShape(e3) {
                  return e3.endObject();
                }
                static createTensorTypeAndShape(e3, t4, r2) {
                  return n2.startTensorTypeAndShape(e3), n2.addElemType(e3, t4), n2.addShape(e3, r2), n2.endTensorTypeAndShape(e3);
                }
              }
              t3.TensorTypeAndShape = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsMapType(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsMapType(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                keyType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                valueType(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startMapType(e3) {
                  e3.startObject(2);
                }
                static addKeyType(t4, n3) {
                  t4.addFieldInt32(0, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addValueType(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endMapType(e3) {
                  return e3.endObject();
                }
                static createMapType(e3, t4, r2) {
                  return n2.startMapType(e3), n2.addKeyType(e3, t4), n2.addValueType(e3, r2), n2.endMapType(e3);
                }
              }
              t3.MapType = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSequenceType(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSequenceType(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                elemType(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startSequenceType(e3) {
                  e3.startObject(1);
                }
                static addElemType(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static endSequenceType(e3) {
                  return e3.endObject();
                }
                static createSequenceType(e3, t4) {
                  return n2.startSequenceType(e3), n2.addElemType(e3, t4), n2.endSequenceType(e3);
                }
              }
              t3.SequenceType = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            (e3.fbs || (e3.fbs = {})).EdgeEnd = class {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(e4, t2) {
                return this.bb_pos = e4, this.bb = t2, this;
              }
              nodeIndex() {
                return this.bb.readUint32(this.bb_pos);
              }
              srcArgIndex() {
                return this.bb.readInt32(this.bb_pos + 4);
              }
              dstArgIndex() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              static createEdgeEnd(e4, t2, n2, r2) {
                return e4.prep(4, 12), e4.writeInt32(r2), e4.writeInt32(n2), e4.writeInt32(t2), e4.offset();
              }
            };
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsNodeEdge(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsNodeEdge(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                nodeIndex() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                inputEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                }
                inputEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 8);
                  return r2 ? (n3 || new e2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                }
                outputEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startNodeEdge(e3) {
                  e3.startObject(3);
                }
                static addNodeIndex(e3, t4) {
                  e3.addFieldInt32(0, t4, 0);
                }
                static addInputEdges(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static startInputEdgesVector(e3, t4) {
                  e3.startVector(12, t4, 4);
                }
                static addOutputEdges(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static startOutputEdgesVector(e3, t4) {
                  e3.startVector(12, t4, 4);
                }
                static endNodeEdge(e3) {
                  return e3.endObject();
                }
                static createNodeEdge(e3, t4, r2, o2) {
                  return n2.startNodeEdge(e3), n2.addNodeIndex(e3, t4), n2.addInputEdges(e3, r2), n2.addOutputEdges(e3, o2), n2.endNodeEdge(e3);
                }
              }
              t3.NodeEdge = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsNode(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsNode(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                domain(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                sinceVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readInt32(this.bb_pos + e3) : 0;
                }
                index() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                opType(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 14);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type() {
                  let t4 = this.bb.__offset(this.bb_pos, 16);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.NodeType.Primitive;
                }
                executionProviderType(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 18);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                inputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 20);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                inputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 22);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                outputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 22);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                attributes(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 24);
                  return r2 ? (n3 || new e2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                attributesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 24);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputArgCounts(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 26);
                  return t4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t4) + 4 * e3) : 0;
                }
                inputArgCountsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputArgCountsArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                implicitInputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 28);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                implicitInputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 28);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startNode(e3) {
                  e3.startObject(13);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDomain(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static addSinceVersion(e3, t4) {
                  e3.addFieldInt32(3, t4, 0);
                }
                static addIndex(e3, t4) {
                  e3.addFieldInt32(4, t4, 0);
                }
                static addOpType(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static addType(t4, n3) {
                  t4.addFieldInt32(6, n3, e2.experimental.fbs.NodeType.Primitive);
                }
                static addExecutionProviderType(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addInputs(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static createInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addOutputs(e3, t4) {
                  e3.addFieldOffset(9, t4, 0);
                }
                static createOutputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOutputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addAttributes(e3, t4) {
                  e3.addFieldOffset(10, t4, 0);
                }
                static createAttributesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startAttributesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInputArgCounts(e3, t4) {
                  e3.addFieldOffset(11, t4, 0);
                }
                static createInputArgCountsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt32(t4[n3]);
                  return e3.endVector();
                }
                static startInputArgCountsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addImplicitInputs(e3, t4) {
                  e3.addFieldOffset(12, t4, 0);
                }
                static createImplicitInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startImplicitInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endNode(e3) {
                  return e3.endObject();
                }
                static createNode(e3, t4, r2, o2, i2, a, s, u, l, c, p, d, f, h) {
                  return n2.startNode(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addDomain(e3, o2), n2.addSinceVersion(e3, i2), n2.addIndex(e3, a), n2.addOpType(e3, s), n2.addType(e3, u), n2.addExecutionProviderType(e3, l), n2.addInputs(e3, c), n2.addOutputs(e3, p), n2.addAttributes(e3, d), n2.addInputArgCounts(e3, f), n2.addImplicitInputs(e3, h), n2.endNode(e3);
                }
              }
              t3.Node = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsValueInfo(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsValueInfo(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 8);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startValueInfo(e3) {
                  e3.startObject(3);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addType(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endValueInfo(e3) {
                  return e3.endObject();
                }
                static createValueInfo(e3, t4, r2, o2) {
                  return n2.startValueInfo(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addType(e3, o2), n2.endValueInfo(e3);
                }
              }
              t3.ValueInfo = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTypeInfo(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTypeInfo(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                denotation(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                valueType() {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.readUint8(this.bb_pos + t4) : e2.experimental.fbs.TypeInfoValue.NONE;
                }
                value(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__union(e3, this.bb_pos + t4) : null;
                }
                static startTypeInfo(e3) {
                  e3.startObject(3);
                }
                static addDenotation(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addValueType(t4, n3) {
                  t4.addFieldInt8(1, n3, e2.experimental.fbs.TypeInfoValue.NONE);
                }
                static addValue(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endTypeInfo(e3) {
                  return e3.endObject();
                }
                static createTypeInfo(e3, t4, r2, o2) {
                  return n2.startTypeInfo(e3), n2.addDenotation(e3, t4), n2.addValueType(e3, r2), n2.addValue(e3, o2), n2.endTypeInfo(e3);
                }
              }
              t3.TypeInfo = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              class t2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t3) {
                  return this.bb_pos = e5, this.bb = t3, this;
                }
                static getRootAsOperatorSetId(e5, n2) {
                  return (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                static getSizePrefixedRootAsOperatorSetId(e5, n2) {
                  return e5.setPosition(e5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                domain(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 4);
                  return t3 ? this.bb.__string(this.bb_pos + t3, e5) : null;
                }
                version() {
                  let e5 = this.bb.__offset(this.bb_pos, 6);
                  return e5 ? this.bb.readInt64(this.bb_pos + e5) : this.bb.createLong(0, 0);
                }
                static startOperatorSetId(e5) {
                  e5.startObject(2);
                }
                static addDomain(e5, t3) {
                  e5.addFieldOffset(0, t3, 0);
                }
                static addVersion(e5, t3) {
                  e5.addFieldInt64(1, t3, e5.createLong(0, 0));
                }
                static endOperatorSetId(e5) {
                  return e5.endObject();
                }
                static createOperatorSetId(e5, n2, r2) {
                  return t2.startOperatorSetId(e5), t2.addDomain(e5, n2), t2.addVersion(e5, r2), t2.endOperatorSetId(e5);
                }
              }
              e4.OperatorSetId = t2;
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTensor(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTensor(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                dims(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                dataType() {
                  let t4 = this.bb.__offset(this.bb_pos, 10);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                rawData(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 12);
                  return t4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t4) + e3) : 0;
                }
                rawDataLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                rawDataArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                stringData(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 14);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                stringDataLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startTensor(e3) {
                  e3.startObject(6);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDims(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createDimsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startDimsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static addDataType(t4, n3) {
                  t4.addFieldInt32(3, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addRawData(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static createRawDataVector(e3, t4) {
                  e3.startVector(1, t4.length, 1);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt8(t4[n3]);
                  return e3.endVector();
                }
                static startRawDataVector(e3, t4) {
                  e3.startVector(1, t4, 1);
                }
                static addStringData(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static createStringDataVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startStringDataVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endTensor(e3) {
                  return e3.endObject();
                }
                static createTensor(e3, t4, r2, o2, i2, a, s) {
                  return n2.startTensor(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addDims(e3, o2), n2.addDataType(e3, i2), n2.addRawData(e3, a), n2.addStringData(e3, s), n2.endTensor(e3);
                }
              }
              t3.Tensor = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSparseTensor(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSparseTensor(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                values(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                indices(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                dims(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startSparseTensor(e3) {
                  e3.startObject(3);
                }
                static addValues(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addIndices(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDims(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createDimsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startDimsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static endSparseTensor(e3) {
                  return e3.endObject();
                }
                static createSparseTensor(e3, t4, r2, o2) {
                  return n2.startSparseTensor(e3), n2.addValues(e3, t4), n2.addIndices(e3, r2), n2.addDims(e3, o2), n2.endSparseTensor(e3);
                }
              }
              t3.SparseTensor = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsAttribute(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsAttribute(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type() {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.AttributeType.UNDEFINED;
                }
                f() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readFloat32(this.bb_pos + e3) : 0;
                }
                i() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                s(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 14);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                t(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 16);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                g(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 18);
                  return n3 ? (t4 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                floats(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 20);
                  return t4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t4) + 4 * e3) : 0;
                }
                floatsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                floatsArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                ints(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 22);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                intsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 22);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                strings(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 24);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                stringsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 24);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                tensors(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 26);
                  return r2 ? (n3 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                tensorsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                graphs(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 28);
                  return r2 ? (n3 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                graphsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 28);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startAttribute(e3) {
                  e3.startObject(13);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addType(t4, n3) {
                  t4.addFieldInt32(2, n3, e2.experimental.fbs.AttributeType.UNDEFINED);
                }
                static addF(e3, t4) {
                  e3.addFieldFloat32(3, t4, 0);
                }
                static addI(e3, t4) {
                  e3.addFieldInt64(4, t4, e3.createLong(0, 0));
                }
                static addS(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static addT(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static addG(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addFloats(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static createFloatsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addFloat32(t4[n3]);
                  return e3.endVector();
                }
                static startFloatsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInts(e3, t4) {
                  e3.addFieldOffset(9, t4, 0);
                }
                static createIntsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startIntsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static addStrings(e3, t4) {
                  e3.addFieldOffset(10, t4, 0);
                }
                static createStringsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startStringsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addTensors(e3, t4) {
                  e3.addFieldOffset(11, t4, 0);
                }
                static createTensorsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startTensorsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addGraphs(e3, t4) {
                  e3.addFieldOffset(12, t4, 0);
                }
                static createGraphsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startGraphsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endAttribute(e3) {
                  return e3.endObject();
                }
                static createAttribute(e3, t4, r2, o2, i2, a, s, u, l, c, p, d, f, h) {
                  return n2.startAttribute(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addType(e3, o2), n2.addF(e3, i2), n2.addI(e3, a), n2.addS(e3, s), n2.addT(e3, u), n2.addG(e3, l), n2.addFloats(e3, c), n2.addInts(e3, p), n2.addStrings(e3, d), n2.addTensors(e3, f), n2.addGraphs(e3, h), n2.endAttribute(e3);
                }
              }
              t3.Attribute = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsGraph(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsGraph(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                initializers(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 4);
                  return r2 ? (n3 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                initializersLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                nodeArgs(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodeArgsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                nodes(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 8);
                  return r2 ? (n3 || new e2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                maxNodeIndex() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                nodeEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 12);
                  return r2 ? (n3 || new e2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodeEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 14);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                inputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 16);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                outputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 16);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                sparseInitializers(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 18);
                  return r2 ? (n3 || new e2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                sparseInitializersLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 18);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startGraph(e3) {
                  e3.startObject(8);
                }
                static addInitializers(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static createInitializersVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInitializersVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addNodeArgs(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createNodeArgsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodeArgsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addNodes(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createNodesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addMaxNodeIndex(e3, t4) {
                  e3.addFieldInt32(3, t4, 0);
                }
                static addNodeEdges(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static createNodeEdgesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodeEdgesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInputs(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static createInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addOutputs(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static createOutputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOutputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addSparseInitializers(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static createSparseInitializersVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startSparseInitializersVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endGraph(e3) {
                  return e3.endObject();
                }
                static createGraph(e3, t4, r2, o2, i2, a, s, u, l) {
                  return n2.startGraph(e3), n2.addInitializers(e3, t4), n2.addNodeArgs(e3, r2), n2.addNodes(e3, o2), n2.addMaxNodeIndex(e3, i2), n2.addNodeEdges(e3, a), n2.addInputs(e3, s), n2.addOutputs(e3, u), n2.addSparseInitializers(e3, l), n2.endGraph(e3);
                }
              }
              t3.Graph = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsModel(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsModel(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                irVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                opsetImport(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                opsetImportLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                producerName(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                producerVersion(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 10);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                domain(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 12);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                modelVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 16);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                graph(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 18);
                  return n3 ? (t4 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                graphDocString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 20);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startModel(e3) {
                  e3.startObject(9);
                }
                static addIrVersion(e3, t4) {
                  e3.addFieldInt64(0, t4, e3.createLong(0, 0));
                }
                static addOpsetImport(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createOpsetImportVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOpsetImportVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addProducerName(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static addProducerVersion(e3, t4) {
                  e3.addFieldOffset(3, t4, 0);
                }
                static addDomain(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static addModelVersion(e3, t4) {
                  e3.addFieldInt64(5, t4, e3.createLong(0, 0));
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static addGraph(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addGraphDocString(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static endModel(e3) {
                  return e3.endObject();
                }
                static createModel(e3, t4, r2, o2, i2, a, s, u, l, c) {
                  return n2.startModel(e3), n2.addIrVersion(e3, t4), n2.addOpsetImport(e3, r2), n2.addProducerName(e3, o2), n2.addProducerVersion(e3, i2), n2.addDomain(e3, a), n2.addModelVersion(e3, s), n2.addDocString(e3, u), n2.addGraph(e3, l), n2.addGraphDocString(e3, c), n2.endModel(e3);
                }
              }
              t3.Model = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              class t2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t3) {
                  return this.bb_pos = e5, this.bb = t3, this;
                }
                static getRootAsKernelCreateInfos(e5, n2) {
                  return (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                static getSizePrefixedRootAsKernelCreateInfos(e5, n2) {
                  return e5.setPosition(e5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                nodeIndices(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 4);
                  return t3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t3) + 4 * e5) : 0;
                }
                nodeIndicesLength() {
                  let e5 = this.bb.__offset(this.bb_pos, 4);
                  return e5 ? this.bb.__vector_len(this.bb_pos + e5) : 0;
                }
                nodeIndicesArray() {
                  let e5 = this.bb.__offset(this.bb_pos, 4);
                  return e5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e5), this.bb.__vector_len(this.bb_pos + e5)) : null;
                }
                kernelDefHashes(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 6);
                  return t3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t3) + 8 * e5) : this.bb.createLong(0, 0);
                }
                kernelDefHashesLength() {
                  let e5 = this.bb.__offset(this.bb_pos, 6);
                  return e5 ? this.bb.__vector_len(this.bb_pos + e5) : 0;
                }
                static startKernelCreateInfos(e5) {
                  e5.startObject(2);
                }
                static addNodeIndices(e5, t3) {
                  e5.addFieldOffset(0, t3, 0);
                }
                static createNodeIndicesVector(e5, t3) {
                  e5.startVector(4, t3.length, 4);
                  for (let n2 = t3.length - 1; n2 >= 0; n2--)
                    e5.addInt32(t3[n2]);
                  return e5.endVector();
                }
                static startNodeIndicesVector(e5, t3) {
                  e5.startVector(4, t3, 4);
                }
                static addKernelDefHashes(e5, t3) {
                  e5.addFieldOffset(1, t3, 0);
                }
                static createKernelDefHashesVector(e5, t3) {
                  e5.startVector(8, t3.length, 8);
                  for (let n2 = t3.length - 1; n2 >= 0; n2--)
                    e5.addInt64(t3[n2]);
                  return e5.endVector();
                }
                static startKernelDefHashesVector(e5, t3) {
                  e5.startVector(8, t3, 8);
                }
                static endKernelCreateInfos(e5) {
                  return e5.endObject();
                }
                static createKernelCreateInfos(e5, n2, r2) {
                  return t2.startKernelCreateInfos(e5), t2.addNodeIndices(e5, n2), t2.addKernelDefHashes(e5, r2), t2.endKernelCreateInfos(e5);
                }
              }
              e4.KernelCreateInfos = t2;
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSubGraphSessionState(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSubGraphSessionState(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                graphId(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                sessionState(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startSubGraphSessionState(e3) {
                  e3.startObject(2);
                }
                static addGraphId(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addSessionState(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endSubGraphSessionState(e3) {
                  let t4 = e3.endObject();
                  return e3.requiredField(t4, 4), t4;
                }
                static createSubGraphSessionState(e3, t4, r2) {
                  return n2.startSubGraphSessionState(e3), n2.addGraphId(e3, t4), n2.addSessionState(e3, r2), n2.endSubGraphSessionState(e3);
                }
              }
              t3.SubGraphSessionState = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSessionState(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSessionState(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                kernels(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                subGraphSessionStates(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                subGraphSessionStatesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startSessionState(e3) {
                  e3.startObject(2);
                }
                static addKernels(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addSubGraphSessionStates(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createSubGraphSessionStatesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startSubGraphSessionStatesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endSessionState(e3) {
                  return e3.endObject();
                }
                static createSessionState(e3, t4, r2) {
                  return n2.startSessionState(e3), n2.addKernels(e3, t4), n2.addSubGraphSessionStates(e3, r2), n2.endSessionState(e3);
                }
              }
              t3.SessionState = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsInferenceSession(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsInferenceSession(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static bufferHasIdentifier(e3) {
                  return e3.__has_identifier("ORTM");
                }
                ortVersion(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                model(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                sessionState(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 8);
                  return n3 ? (t4 || new e2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startInferenceSession(e3) {
                  e3.startObject(3);
                }
                static addOrtVersion(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addModel(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addSessionState(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endInferenceSession(e3) {
                  return e3.endObject();
                }
                static finishInferenceSessionBuffer(e3, t4) {
                  e3.finish(t4, "ORTM");
                }
                static finishSizePrefixedInferenceSessionBuffer(e3, t4) {
                  e3.finish(t4, "ORTM", true);
                }
                static createInferenceSession(e3, t4, r2, o2) {
                  return n2.startInferenceSession(e3), n2.addOrtVersion(e3, t4), n2.addModel(e3, r2), n2.addSessionState(e3, o2), n2.endInferenceSession(e3);
                }
              }
              t3.InferenceSession = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {}));
      }, 1723: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OnnxjsSessionHandler = void 0;
        const r = n(2235), o = n(9240);
        t.OnnxjsSessionHandler = class {
          constructor(e2) {
            this.session = e2, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
          }
          async dispose() {
          }
          async run(e2, t2, n2) {
            const i = /* @__PURE__ */ new Map();
            for (const t3 in e2)
              if (Object.hasOwnProperty.call(e2, t3)) {
                const n3 = e2[t3];
                i.set(t3, new o.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
              }
            const a = await this.session.run(i), s = {};
            return a.forEach((e3, t3) => {
              s[t3] = new r.Tensor(e3.type, e3.data, e3.dims);
            }), s;
          }
          startProfiling() {
            this.session.startProfiling();
          }
          endProfiling() {
            this.session.endProfiling();
          }
        };
      }, 6027: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Session = void 0;
        const r = n(7067), o = n(1296), i = n(1975), a = n(6496), s = n(1315), u = n(1745);
        t.Session = class {
          constructor(e2 = {}) {
            this._initialized = false, this.backendHint = e2.backendHint, this.profiler = s.Profiler.create(e2.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
          }
          get inputNames() {
            return this._model.graph.getInputNames();
          }
          get outputNames() {
            return this._model.graph.getOutputNames();
          }
          startProfiling() {
            this.profiler.start();
          }
          endProfiling() {
            this.profiler.stop();
          }
          async loadModel(e2, t2, n2) {
            await this.profiler.event("session", "Session.loadModel", async () => {
              const a2 = await (0, i.resolveBackend)(this.backendHint);
              if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u.Model(), "string" == typeof e2) {
                const t3 = e2.endsWith(".ort");
                if ("undefined" != typeof process && process.versions && process.versions.node) {
                  const n3 = await (0, o.promisify)(r.readFile)(e2);
                  this.initialize(n3, t3);
                } else {
                  const n3 = await fetch(e2), r2 = await n3.arrayBuffer();
                  this.initialize(new Uint8Array(r2), t3);
                }
              } else if (ArrayBuffer.isView(e2))
                this.initialize(e2);
              else {
                const r2 = new Uint8Array(e2, t2 || 0, n2 || e2.byteLength);
                this.initialize(r2);
              }
            });
          }
          initialize(e2, t2) {
            if (this._initialized)
              throw new Error("already initialized");
            this.profiler.event("session", "Session.initialize", () => {
              const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
              this._model.load(e2, n2, t2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
            }), this._initialized = true;
          }
          async run(e2) {
            if (!this._initialized)
              throw new Error("session not initialized yet");
            return this.profiler.event("session", "Session.run", async () => {
              const t2 = this.normalizeAndValidateInputs(e2), n2 = await this._executionPlan.execute(this.sessionHandler, t2);
              return this.createOutput(n2);
            });
          }
          normalizeAndValidateInputs(e2) {
            const t2 = this._model.graph.getInputNames();
            if (Array.isArray(e2)) {
              if (e2.length !== t2.length)
                throw new Error(`incorrect input array length: expected ${t2.length} but got ${e2.length}`);
            } else {
              if (e2.size !== t2.length)
                throw new Error(`incorrect input map size: expected ${t2.length} but got ${e2.size}`);
              const n2 = new Array(e2.size);
              let r2 = 0;
              for (let o2 = 0; o2 < t2.length; ++o2) {
                const i2 = e2.get(t2[o2]);
                if (!i2)
                  throw new Error(`missing input tensor for: '${name}'`);
                n2[r2++] = i2;
              }
              e2 = n2;
            }
            if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length)
              this.validateInputTensorDims(this.context.graphInputDims, e2, false);
            else {
              const t3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(t3.length);
              for (let o2 = 0; o2 < t3.length; ++o2) {
                const i2 = n2[t3[o2]];
                r2[o2] = i2.type.shape.dims, this.context.graphInputTypes.push(i2.type.tensorType), this.context.graphInputDims.push(e2[o2].dims);
              }
              this.validateInputTensorDims(r2, e2, true);
            }
            return this.validateInputTensorTypes(this.context.graphInputTypes, e2), e2;
          }
          validateInputTensorTypes(e2, t2) {
            for (let n2 = 0; n2 < t2.length; n2++) {
              const r2 = e2[n2], o2 = t2[n2].type;
              if (r2 !== o2)
                throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${o2}`);
            }
          }
          validateInputTensorDims(e2, t2, n2) {
            for (let r2 = 0; r2 < t2.length; r2++) {
              const o2 = e2[r2], i2 = t2[r2].dims;
              if (!this.compareTensorDims(o2, i2, n2))
                throw new Error(`input tensor[${r2}] check failed: expected shape '[${o2.join(",")}]' but got [${i2.join(",")}]`);
            }
          }
          compareTensorDims(e2, t2, n2) {
            if (e2.length !== t2.length)
              return false;
            for (let r2 = 0; r2 < e2.length; ++r2)
              if (e2[r2] !== t2[r2] && (!n2 || 0 !== e2[r2]))
                return false;
            return true;
          }
          createOutput(e2) {
            const t2 = this._model.graph.getOutputNames();
            if (e2.length !== t2.length)
              throw new Error("expected number of outputs do not match number of generated outputs");
            const n2 = /* @__PURE__ */ new Map();
            for (let r2 = 0; r2 < t2.length; ++r2)
              n2.set(t2[r2], e2[r2]);
            return n2;
          }
          initializeOps(e2) {
            const t2 = e2.getNodes();
            this._ops = new Array(t2.length);
            for (let n2 = 0; n2 < t2.length; n2++)
              this._ops[n2] = this.sessionHandler.resolve(t2[n2], this._model.opsets, e2);
          }
        };
      }, 9240: function(e, t, n) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const o = n(3442), i = r(n(1583)), a = n(5127), s = n(2446), u = n(7273);
        var l = a.onnxruntime.experimental.fbs;
        class c {
          get data() {
            if (void 0 === this.cache) {
              const e2 = this.dataProvider(this.dataId);
              if (e2.length !== this.size)
                throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
              this.cache = e2;
            }
            return this.cache;
          }
          get stringData() {
            if ("string" !== this.type)
              throw new TypeError("data type is not string");
            return this.data;
          }
          get integerData() {
            switch (this.type) {
              case "uint8":
              case "int8":
              case "uint16":
              case "int16":
              case "int32":
              case "uint32":
              case "bool":
                return this.data;
              default:
                throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
            }
          }
          get floatData() {
            switch (this.type) {
              case "float32":
              case "float64":
                return this.data;
              default:
                throw new TypeError("data type is not float (float32, float64)");
            }
          }
          get numberData() {
            if ("string" !== this.type)
              return this.data;
            throw new TypeError("type cannot be non-number (string)");
          }
          get(e2) {
            return this.data[u.ShapeUtil.indicesToOffset(e2, this.strides)];
          }
          set(e2, t2) {
            this.data[u.ShapeUtil.indicesToOffset(e2, this.strides)] = t2;
          }
          async getData() {
            return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
          }
          get strides() {
            return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
          }
          constructor(e2, t2, n2, r2, i2, a2 = o.Guid.create()) {
            this.dims = e2, this.type = t2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = i2, this.dataId = a2, this.size = u.ShapeUtil.validateDimsAndCalcSize(e2);
            const s2 = this.size, l2 = void 0 === n2 && void 0 === r2 && void 0 === i2;
            if (void 0 !== i2 && i2.length !== s2)
              throw new RangeError("Input dims doesn't match data length.");
            if ("string" === t2) {
              if (!(void 0 === i2 || Array.isArray(i2) && i2.every((e3) => "string" == typeof e3)))
                throw new TypeError("cache should be a string array");
              l2 && (this.cache = new Array(s2));
            } else {
              if (void 0 !== i2) {
                const e3 = d(t2);
                if (!(i2 instanceof e3))
                  throw new TypeError(`cache should be type ${e3.name}`);
              }
              if (l2) {
                const e3 = new ArrayBuffer(s2 * function(e4) {
                  switch (e4) {
                    case "bool":
                    case "int8":
                    case "uint8":
                      return 1;
                    case "int16":
                    case "uint16":
                      return 2;
                    case "int32":
                    case "uint32":
                    case "float32":
                      return 4;
                    case "float64":
                      return 8;
                    default:
                      throw new Error(`cannot calculate sizeof() on type ${e4}`);
                  }
                }(t2));
                this.cache = function(e4, t3) {
                  return new (d(t3))(e4);
                }(e3, t2);
              }
            }
          }
          static fromProto(e2) {
            if (!e2)
              throw new Error("cannot construct Value from an empty tensor");
            const t2 = u.ProtoUtil.tensorDataTypeFromProto(e2.dataType), n2 = u.ProtoUtil.tensorDimsFromProto(e2.dims), r2 = new c(n2, t2);
            if ("string" === t2)
              e2.stringData.forEach((e3, t3) => {
                r2.data[t3] = (0, u.decodeUtf8String)(e3);
              });
            else if (e2.rawData && "number" == typeof e2.rawData.byteLength && e2.rawData.byteLength > 0) {
              const t3 = r2.data, n3 = new DataView(e2.rawData.buffer, e2.rawData.byteOffset, e2.rawData.byteLength), o2 = p(e2.dataType), i2 = e2.rawData.byteLength / o2;
              if (e2.rawData.byteLength % o2 != 0)
                throw new Error("invalid buffer length");
              if (t3.length !== i2)
                throw new Error("buffer length mismatch");
              for (let r3 = 0; r3 < i2; r3++) {
                const i3 = h(n3, e2.dataType, r3 * o2);
                t3[r3] = i3;
              }
            } else {
              let t3;
              switch (e2.dataType) {
                case s.onnx.TensorProto.DataType.FLOAT:
                  t3 = e2.floatData;
                  break;
                case s.onnx.TensorProto.DataType.INT32:
                case s.onnx.TensorProto.DataType.INT16:
                case s.onnx.TensorProto.DataType.UINT16:
                case s.onnx.TensorProto.DataType.INT8:
                case s.onnx.TensorProto.DataType.UINT8:
                case s.onnx.TensorProto.DataType.BOOL:
                  t3 = e2.int32Data;
                  break;
                case s.onnx.TensorProto.DataType.INT64:
                  t3 = e2.int64Data;
                  break;
                case s.onnx.TensorProto.DataType.DOUBLE:
                  t3 = e2.doubleData;
                  break;
                case s.onnx.TensorProto.DataType.UINT32:
                case s.onnx.TensorProto.DataType.UINT64:
                  t3 = e2.uint64Data;
                  break;
                default:
                  throw new Error("unspecific error");
              }
              if (null == t3)
                throw new Error("failed to populate data from a tensorproto value");
              const n3 = r2.data;
              if (n3.length !== t3.length)
                throw new Error("array length mismatch");
              for (let r3 = 0; r3 < t3.length; r3++) {
                const o2 = t3[r3];
                i.default.isLong(o2) ? n3[r3] = f(o2, e2.dataType) : n3[r3] = o2;
              }
            }
            return r2;
          }
          static fromData(e2, t2, n2) {
            return new c(t2, n2, void 0, void 0, e2);
          }
          static fromOrtTensor(e2) {
            if (!e2)
              throw new Error("cannot construct Value from an empty tensor");
            const t2 = u.ProtoUtil.tensorDimsFromORTFormat(e2), n2 = u.ProtoUtil.tensorDataTypeFromProto(e2.dataType()), r2 = new c(t2, n2);
            if ("string" === n2)
              for (let t3 = 0; t3 < e2.stringDataLength(); t3++)
                r2.data[t3] = e2.stringData(t3);
            else if (e2.rawDataArray() && "number" == typeof e2.rawDataLength() && e2.rawDataLength() > 0) {
              const t3 = r2.data, n3 = new DataView(e2.rawDataArray().buffer, e2.rawDataArray().byteOffset, e2.rawDataLength()), o2 = p(e2.dataType()), i2 = e2.rawDataLength() / o2;
              if (e2.rawDataLength() % o2 != 0)
                throw new Error("invalid buffer length");
              if (t3.length !== i2)
                throw new Error("buffer length mismatch");
              for (let r3 = 0; r3 < i2; r3++) {
                const i3 = h(n3, e2.dataType(), r3 * o2);
                t3[r3] = i3;
              }
            }
            return r2;
          }
        }
        function p(e2) {
          switch (e2) {
            case s.onnx.TensorProto.DataType.UINT8:
            case s.onnx.TensorProto.DataType.INT8:
            case s.onnx.TensorProto.DataType.BOOL:
              return 1;
            case s.onnx.TensorProto.DataType.UINT16:
            case s.onnx.TensorProto.DataType.INT16:
              return 2;
            case s.onnx.TensorProto.DataType.FLOAT:
            case s.onnx.TensorProto.DataType.INT32:
            case s.onnx.TensorProto.DataType.UINT32:
              return 4;
            case s.onnx.TensorProto.DataType.INT64:
            case s.onnx.TensorProto.DataType.DOUBLE:
            case s.onnx.TensorProto.DataType.UINT64:
              return 8;
            default:
              throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[e2]}`);
          }
        }
        function d(e2) {
          switch (e2) {
            case "bool":
            case "uint8":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "int16":
              return Int16Array;
            case "uint16":
              return Uint16Array;
            case "int32":
              return Int32Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "float32":
              return Float32Array;
            case "float64":
              return Float64Array;
            default:
              throw new Error("unspecified error");
          }
        }
        function f(e2, t2) {
          if (t2 === s.onnx.TensorProto.DataType.INT64 || t2 === l.TensorDataType.INT64) {
            if (e2.greaterThanOrEqual(2147483648) || e2.lessThan(-2147483648))
              throw new TypeError("int64 is not supported");
          } else {
            if (t2 !== s.onnx.TensorProto.DataType.UINT32 && t2 !== l.TensorDataType.UINT32 && t2 !== s.onnx.TensorProto.DataType.UINT64 && t2 !== l.TensorDataType.UINT64)
              throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[t2]}`);
            if (e2.greaterThanOrEqual(4294967296) || e2.lessThan(0))
              throw new TypeError("uint64 is not supported");
          }
          return e2.toNumber();
        }
        function h(e2, t2, n2) {
          switch (t2) {
            case s.onnx.TensorProto.DataType.BOOL:
            case s.onnx.TensorProto.DataType.UINT8:
              return e2.getUint8(n2);
            case s.onnx.TensorProto.DataType.INT8:
              return e2.getInt8(n2);
            case s.onnx.TensorProto.DataType.UINT16:
              return e2.getUint16(n2, true);
            case s.onnx.TensorProto.DataType.INT16:
              return e2.getInt16(n2, true);
            case s.onnx.TensorProto.DataType.FLOAT:
              return e2.getFloat32(n2, true);
            case s.onnx.TensorProto.DataType.INT32:
              return e2.getInt32(n2, true);
            case s.onnx.TensorProto.DataType.UINT32:
              return e2.getUint32(n2, true);
            case s.onnx.TensorProto.DataType.INT64:
              return f(i.default.fromBits(e2.getUint32(n2, true), e2.getUint32(n2 + 4, true), false), t2);
            case s.onnx.TensorProto.DataType.DOUBLE:
              return e2.getFloat64(n2, true);
            case s.onnx.TensorProto.DataType.UINT64:
              return f(i.default.fromBits(e2.getUint32(n2, true), e2.getUint32(n2 + 4, true), true), t2);
            default:
              throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[t2]}`);
          }
        }
        t.Tensor = c;
      }, 7273: function(e, t, n) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.decodeUtf8String = t.MAX_CLIP = t.MIN_CLIP = t.PoolConvUtil = t.ReduceUtil = t.SplitUtil = t.MathUtil = t.ShapeUtil = t.LongUtil = t.ProtoUtil = t.GemmUtil = t.arrayCopyHelper = t.BroadcastUtil = t.MatMulUtil = t.ArrayUtil = t.assert = t.checkInputsShape = void 0;
        const o = n(5686), i = r(n(1583)), a = n(2446), s = n(9240);
        t.checkInputsShape = function(e2, ...t2) {
          if (!e2 || e2.length !== t2.length)
            return false;
          for (let n2 = 0; n2 < e2.length; n2++)
            if (!e2[n2].dims || e2[n2].dims.length !== t2[n2])
              return false;
          return true;
        }, t.assert = function(e2, t2) {
          if (!e2)
            throw new Error("string" == typeof t2 ? t2 : t2());
        }, t.ArrayUtil = class {
          static arraysEqual(e2, t2) {
            if (e2.length !== t2.length)
              return false;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (e2[n2] !== t2[n2])
                return false;
            return true;
          }
        };
        class u {
          static preprocessInputShapes(e2, t2) {
            return [1 === e2.length ? [1, e2[0]] : e2, 1 === t2.length ? [t2[0], 1] : t2];
          }
          static postprocessOutputShape(e2, t2, n2) {
            1 === t2 && e2.splice(e2.length - 2, 1), 1 === n2 && e2.pop();
          }
          static calcMatMulShape(e2, t2) {
            return e2[1] !== t2[0] ? void 0 : [e2[0], t2[1]];
          }
        }
        t.MatMulUtil = u;
        class l {
          static calcShape(e2, t2, n2 = false) {
            const r2 = e2.length, o2 = t2.length;
            if (0 === r2)
              return t2;
            if (0 === o2)
              return e2;
            const i2 = Math.max(e2.length, t2.length), a2 = new Array(i2);
            if (n2) {
              if (r2 < 2 || o2 < 2)
                return;
              const n3 = u.calcMatMulShape([e2[r2 - 2], e2[r2 - 1]], [t2[o2 - 2], t2[o2 - 1]]);
              if (void 0 === n3)
                return;
              [a2[i2 - 2], a2[i2 - 1]] = n3;
            }
            for (let s2 = n2 ? 3 : 1; s2 <= i2; s2++) {
              const n3 = r2 - s2 < 0 ? 1 : e2[r2 - s2], u2 = o2 - s2 < 0 ? 1 : t2[o2 - s2];
              if (n3 !== u2 && n3 > 1 && u2 > 1)
                return;
              a2[i2 - s2] = Math.max(n3, u2);
            }
            return a2;
          }
          static index(e2, t2) {
            const n2 = new Array(t2.length);
            return l.fillIndex(e2, t2, n2), n2;
          }
          static fillIndex(e2, t2, n2) {
            const r2 = e2.length - t2.length;
            for (let o2 = 0; o2 < t2.length; o2++)
              n2[o2] = e2[r2 + o2] % t2[o2];
          }
          static calc(e2, t2, n2, r2, o2) {
            const i2 = l.calcShape(e2.dims, t2.dims);
            if (i2) {
              if (r2 && !d.areEqual(i2, e2.dims))
                return;
              const a2 = d.size(i2), u2 = r2 ? e2 : new s.Tensor(i2, o2 || e2.type);
              if (0 === i2.length)
                u2.set([], n2(e2.get([]), t2.get([])));
              else {
                const r3 = new Array(i2.length), o3 = new Array(e2.dims.length), s2 = new Array(t2.dims.length);
                let c2, p2 = 0, d2 = 0, f2 = false, h2 = false;
                0 === e2.dims.length && (p2 = e2.get([]), f2 = true), 0 === t2.dims.length && (d2 = t2.get([]), h2 = true);
                for (let g2 = 0; g2 < a2; g2++) {
                  c2 = g2;
                  for (let e3 = i2.length - 1; e3 >= 0; e3--)
                    r3[e3] = c2 % i2[e3], c2 = Math.floor(c2 / i2[e3]);
                  f2 || (l.fillIndex(r3, e2.dims, o3), p2 = e2.get(o3)), h2 || (l.fillIndex(r3, t2.dims, s2), d2 = t2.get(s2)), u2.set(r3, n2(p2, d2));
                }
              }
              return u2;
            }
          }
          static isValidBroadcast(e2, t2) {
            const n2 = e2.length, r2 = t2.length;
            if (n2 > r2)
              return false;
            for (let o2 = 1; o2 <= n2; o2++)
              if (1 !== e2[n2 - o2] && e2[n2 - o2] !== t2[r2 - o2])
                return false;
            return true;
          }
          static getBroadcastDims(e2, t2) {
            const n2 = e2.length, r2 = [];
            for (let o2 = 0; o2 < n2; o2++) {
              const i2 = n2 - 1 - o2, a2 = e2[i2] || 1;
              (t2[t2.length - 1 - o2] || 1) > 1 && 1 === a2 && r2.unshift(i2);
            }
            return r2;
          }
        }
        t.BroadcastUtil = l, t.arrayCopyHelper = function(e2, t2, n2, r2, o2) {
          if (r2 < 0 || r2 >= t2.length)
            throw new Error("sourceIndex out of bounds");
          if (n2 < 0 || n2 >= e2.length)
            throw new Error("targetIndex out of bounds");
          if (r2 + o2 > t2.length)
            throw new Error("source indices to be copied are outside bounds");
          if (n2 + o2 > e2.length)
            throw new Error("target array is too small to hold result");
          for (let i2 = 0; i2 < o2; i2++)
            e2[n2 + i2] = t2[r2 + i2];
        }, t.GemmUtil = class {
          static getShapeOfGemmResult(e2, t2, n2, r2, o2) {
            if (2 !== e2.length || 2 !== n2.length)
              throw new Error("shape need to be of size 2");
            let i2, a2, s2;
            t2 ? (i2 = e2[1], a2 = e2[0]) : (i2 = e2[0], a2 = e2[1]);
            let u2 = -1;
            if (r2 ? (s2 = n2[0], u2 = 1) : (s2 = n2[1], u2 = 0), n2[u2] !== a2)
              throw new Error("dimension mismatch");
            if (i2 <= 0 || s2 <= 0 || a2 <= 0)
              throw new Error("invalid shape specified");
            if (o2 && !l.isValidBroadcast(o2, [i2, s2]))
              throw new Error("gemm: invalid bias shape for broadcast");
            return [i2, s2, a2];
          }
        };
        class c {
          static tensorDataTypeFromProto(e2) {
            switch (e2) {
              case a.onnx.TensorProto.DataType.INT8:
                return "int8";
              case a.onnx.TensorProto.DataType.UINT8:
                return "uint8";
              case a.onnx.TensorProto.DataType.BOOL:
                return "bool";
              case a.onnx.TensorProto.DataType.INT16:
                return "int16";
              case a.onnx.TensorProto.DataType.UINT16:
                return "uint16";
              case a.onnx.TensorProto.DataType.INT32:
                return "int32";
              case a.onnx.TensorProto.DataType.UINT32:
                return "uint32";
              case a.onnx.TensorProto.DataType.FLOAT:
                return "float32";
              case a.onnx.TensorProto.DataType.DOUBLE:
                return "float64";
              case a.onnx.TensorProto.DataType.STRING:
                return "string";
              case a.onnx.TensorProto.DataType.INT64:
                return "int32";
              case a.onnx.TensorProto.DataType.UINT64:
                return "uint32";
              default:
                throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[e2]}`);
            }
          }
          static tensorDataTypeStringToEnum(e2) {
            switch (e2) {
              case "int8":
                return a.onnx.TensorProto.DataType.INT8;
              case "uint8":
                return a.onnx.TensorProto.DataType.UINT8;
              case "bool":
                return a.onnx.TensorProto.DataType.BOOL;
              case "int16":
                return a.onnx.TensorProto.DataType.INT16;
              case "uint16":
                return a.onnx.TensorProto.DataType.UINT16;
              case "int32":
                return a.onnx.TensorProto.DataType.INT32;
              case "uint32":
                return a.onnx.TensorProto.DataType.UINT32;
              case "float32":
                return a.onnx.TensorProto.DataType.FLOAT;
              case "float64":
                return a.onnx.TensorProto.DataType.DOUBLE;
              case "string":
                return a.onnx.TensorProto.DataType.STRING;
              case "int64":
                return a.onnx.TensorProto.DataType.INT64;
              case "uint64":
                return a.onnx.TensorProto.DataType.UINT64;
              default:
                throw new Error(`unsupported data type: ${e2}`);
            }
          }
          static tensorDimsFromProto(e2) {
            return e2.map((e3) => i.default.isLong(e3) ? e3.toNumber() : e3);
          }
          static tensorValueTypeFromProto(e2) {
            return { tensorType: c.tensorDataTypeFromProto(e2.elemType), shape: { dims: c.tensorDimsFromProto(e2.shape.dim.map((e3) => e3.dimValue)) } };
          }
          static tensorDimsFromORTFormat(e2) {
            const t2 = [];
            for (let n2 = 0; n2 < e2.dimsLength(); n2++)
              t2.push(p.longToNumber(e2.dims(n2)));
            return t2;
          }
          static tensorAttributesFromORTFormat(e2) {
            const t2 = [];
            for (let n2 = 0; n2 < e2.attributesLength(); n2++)
              t2.push(e2.attributes(n2));
            return t2;
          }
        }
        t.ProtoUtil = c;
        class p {
          static longToNumber(e2, t2) {
            return i.default.isLong(e2) ? e2.toNumber() : e2 instanceof o.flatbuffers.Long ? i.default.fromValue({ low: e2.low, high: e2.high, unsigned: null != t2 && t2 }).toNumber() : e2;
          }
          static isLong(e2) {
            return i.default.isLong(e2) || e2 instanceof o.flatbuffers.Long;
          }
        }
        t.LongUtil = p;
        class d {
          static size(e2) {
            return d.getSizeFromDimensionRange(e2, 0, e2.length);
          }
          static sizeFromDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeFromDimension as Tensor has ${e2.length} dimensions.`);
            return d.getSizeFromDimensionRange(e2, t2, e2.length);
          }
          static sizeToDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeToDimension as Tensor has ${e2.length} dimensions.`);
            return d.getSizeFromDimensionRange(e2, 0, t2);
          }
          static getSizeFromDimensionRange(e2, t2, n2) {
            let r2 = 1;
            for (let o2 = t2; o2 < n2; o2++) {
              if (e2[o2] <= 0)
                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
              r2 *= e2[o2];
            }
            return r2;
          }
          static computeStrides(e2) {
            const t2 = e2.length;
            if (0 === t2)
              return [];
            if (1 === t2)
              return [1];
            const n2 = new Array(t2);
            n2[t2 - 1] = 1, n2[t2 - 2] = e2[t2 - 1];
            for (let r2 = t2 - 3; r2 >= 0; --r2)
              n2[r2] = n2[r2 + 1] * e2[r2 + 1];
            return n2;
          }
          static transpose(e2) {
            return e2.slice().reverse();
          }
          static indicesToOffset(e2, t2, n2) {
            void 0 === n2 && (n2 = e2.length);
            let r2 = 0;
            for (let o2 = 0; o2 < n2; ++o2)
              r2 += t2[o2] * e2[o2];
            return r2;
          }
          static offsetToIndices(e2, t2) {
            const n2 = t2.length;
            if (0 === n2)
              return [];
            if (1 === n2)
              return [e2 * t2[0]];
            const r2 = new Array(t2.length);
            for (let n3 = 0; n3 < r2.length - 1; ++n3)
              r2[n3] = Math.floor(e2 / t2[n3]), e2 -= r2[n3] * t2[n3];
            return r2[r2.length - 1] = e2, r2;
          }
          static normalizeAxis(e2, t2) {
            if (e2 < -t2 && e2 >= t2)
              throw new Error("unsupported axis for this operation.");
            return e2 < 0 ? e2 + t2 : e2;
          }
          static normalizeAxes(e2, t2) {
            return e2.map((e3) => this.normalizeAxis(e3, t2));
          }
          static incrementIndex(e2, t2, n2) {
            if (0 === t2.length || 0 === e2.length)
              throw new Error("Index incrementing unsupported for scalar Tensor");
            if (void 0 === n2)
              n2 = t2.length;
            else if (n2 <= 0 || n2 > t2.length)
              throw new Error("Incorrect axis to increment on");
            for (let r2 = n2 - 1; r2 >= 0 && (e2[r2]++, !(e2[r2] < t2[r2])); --r2)
              e2[r2] = 0;
          }
          static calculateReshapedDims(e2, t2) {
            if (0 === t2.length) {
              if (0 === e2.length || 1 === d.size(e2))
                return [];
              throw new Error("cannot reshape to a scalar Tensor");
            }
            const n2 = t2.length, r2 = new Array(n2);
            let o2 = -1, i2 = 1;
            for (let a3 = 0; a3 < n2; a3++) {
              if (t2[a3] < -1)
                throw new Error("a dimension in shape hints cannot be less than -1");
              if (-1 === t2[a3]) {
                if (-1 !== o2)
                  throw new Error("at most one dimension in shape hints can be -1");
                o2 = a3;
              } else {
                if (0 === t2[a3]) {
                  if (a3 >= e2.length)
                    throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                  r2[a3] = e2[a3];
                } else
                  r2[a3] = t2[a3];
                i2 *= r2[a3];
              }
            }
            const a2 = d.size(e2);
            if (-1 !== o2) {
              if (a2 % i2 != 0)
                throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e2}] Output shape: [${t2}]`);
              r2[o2] = a2 / i2;
            } else if (i2 !== a2)
              throw new Error("reshapedDims and originalDims don't have matching sizes");
            return r2;
          }
          static sortBasedOnPerm(e2, t2) {
            return t2 ? t2.map((t3) => e2[t3]) : e2.slice().reverse();
          }
          static padShape(e2, t2) {
            const n2 = e2.length;
            return e2.map((e3, r2) => e3 + t2[r2] + t2[r2 + n2]);
          }
          static areEqual(e2, t2) {
            return e2.length === t2.length && e2.every((e3, n2) => e3 === t2[n2]);
          }
          static validateDimsAndCalcSize(e2) {
            if (e2.length > 6)
              throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
            let t2 = 1;
            for (const n2 of e2) {
              if (!Number.isInteger(n2))
                throw new TypeError(`Invalid shape: ${n2} is not an integer`);
              if (n2 < 0 || n2 > 2147483647)
                throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
              t2 *= n2;
            }
            return t2;
          }
          static flattenShape(e2, t2) {
            t2 < 0 && (t2 += e2.length);
            const n2 = e2.reduce((e3, t3) => e3 * t3, 1), r2 = e2.slice(t2).reduce((e3, t3) => e3 * t3, 1);
            return [n2 / r2, r2];
          }
          static squeezeShape(e2, t2) {
            const n2 = new Array();
            t2 = d.normalizeAxes(t2, e2.length);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const o2 = t2.indexOf(r2) >= 0;
              if (o2 && 1 !== e2[r2])
                throw new Error("squeeze an axis of size different than 1");
              (0 === t2.length && e2[r2] > 1 || t2.length > 0 && !o2) && n2.push(e2[r2]);
            }
            return n2;
          }
          static unsqueezeShape(e2, t2) {
            const n2 = new Array(e2.length + t2.length);
            n2.fill(0);
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r3 = d.normalizeAxis(t2[e3], n2.length);
              if (r3 >= n2.length)
                throw new Error("'axes' has an out of range axis");
              if (0 !== n2[r3])
                throw new Error("'axes' has a duplicate axis");
              n2[r3] = 1;
            }
            let r2 = 0;
            for (let t3 = 0; t3 < n2.length; t3++)
              0 === n2[t3] && (n2[t3] = e2[r2++]);
            if (r2 !== e2.length)
              throw new Error("the unsqueezed dimension could not be established");
            return n2;
          }
        }
        t.ShapeUtil = d, t.MathUtil = class {
          static sqr(e2, t2, n2, r2, o2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let i2 = 0; i2 < o2; i2++)
              e2[n2 + i2] += Math.pow(t2[r2 + i2], 2);
          }
          static axpy(e2, t2, n2, r2, o2, i2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let a2 = 0; a2 < o2; a2++)
              e2[n2 + a2] += i2 * t2[r2 + a2];
          }
          static powx(e2, t2, n2, r2, o2, i2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let a2 = 0; a2 < o2; a2++)
              e2[n2 + a2] = Math.pow(t2[r2 + a2], i2);
          }
          static mul(e2, t2, n2, r2, o2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let i2 = 0; i2 < o2; i2++)
              e2[n2 + i2] = t2[r2 + i2] * e2[n2 + i2];
          }
        };
        class f {
          static splitShape(e2, t2, n2, r2) {
            if (0 === n2.length) {
              if (!r2)
                throw new Error("need to know number of outputs when the 'split' attribute is not specified");
              f.determineSplit(e2[t2], r2, n2);
            }
            const o2 = [], i2 = [0];
            for (let r3 = 0; r3 < n2.length; ++r3) {
              0 !== r3 && i2.push(i2[r3 - 1] + n2[r3 - 1]);
              const a2 = e2.slice();
              a2[t2] = n2[r3], o2.push(a2);
            }
            return [o2, i2];
          }
          static determineSplit(e2, t2, n2) {
            if (e2 % t2 != 0)
              throw new Error("cannot split tensor to equal sized parts");
            for (let r2 = 0; r2 < t2; ++r2)
              n2.push(e2 / t2);
          }
        }
        t.SplitUtil = f;
        class h {
          static calcReduce(e2, t2, n2, r2, o2) {
            const i2 = e2.dims.slice(0);
            0 === t2.length && i2.forEach((e3, n3) => t2.push(n3));
            const a2 = h.calcReduceShape(i2, t2, true), u2 = d.size(a2), c2 = new s.Tensor(a2, e2.type), p2 = d.computeStrides(a2), f2 = d.computeStrides(i2), g2 = new Array(i2.length);
            for (let n3 = 0; n3 < u2; n3++) {
              const a3 = d.offsetToIndices(n3, p2);
              l.fillIndex(a3, i2, g2), c2.set(a3, h.calcReduceByAxis(e2.numberData, t2, i2, 0, d.indicesToOffset(g2, f2), r2, o2));
            }
            return n2 ? c2 : new s.Tensor(h.calcReduceShape(i2, t2, n2), c2.type, void 0, void 0, c2.data, c2.dataId);
          }
          static calcReduceByAxis(e2, t2, n2, r2, o2, i2, a2) {
            let s2 = 0;
            if (r2 >= t2.length)
              return i2(e2[o2]);
            const u2 = t2[r2], l2 = u2 >= n2.length ? 1 : d.size(n2.slice(u2 + 1));
            for (let c2 = 0; c2 < n2[u2]; c2++)
              s2 = 0 === c2 ? h.calcReduceByAxis(e2, t2, n2, r2 + 1, o2, i2, a2) : a2(s2, h.calcReduceByAxis(e2, t2, n2, r2 + 1, o2, i2, a2)), o2 += l2;
            return s2;
          }
          static calcReduceShape(e2, t2, n2) {
            const r2 = e2.slice();
            for (let e3 = 0; e3 < t2.length; e3++)
              r2[t2[e3]] = n2 ? 1 : 0;
            return r2.filter((e3) => 0 !== e3);
          }
        }
        t.ReduceUtil = h;
        class g {
          static adjustPoolAttributes(e2, t2, n2, r2, o2, i2) {
            if (!e2 && n2.length !== t2.length - 2)
              throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                e3 >= n2.length ? n2.push(t2[e3 + 2]) : n2[e3] = t2[e3 + 2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < r2.length) {
                if (r2[e3] < 0)
                  throw new Error("strides should be greater than or equal to 1");
              } else
                r2.push(1);
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < o2.length) {
                if (o2[e3] < 0)
                  throw new Error("dilations should be greater than or equal to 1");
              } else
                o2.push(1);
            for (let e3 = 0; e3 < 2 * n2.length; e3++)
              if (e3 < i2.length) {
                if (i2[e3] < 0)
                  throw new Error("pad should be greater than or equal to 1");
              } else
                i2.push(0);
            for (let e3 = 0; e3 < n2.length; e3++) {
              if (n2[e3] <= 0)
                throw new Error("kernel shapes need to be greater than 0");
              if (i2[e3] >= n2[e3] || i2[e3 + n2.length] >= n2[e3])
                throw new Error("pads should be smaller than kernel");
            }
          }
          static adjustPadsBasedOnAutoPad(e2, t2, n2, r2, o2, i2) {
            if (i2) {
              if (o2.length !== 2 * (e2.length - 2))
                throw new Error("length of pads should be twice the length of data dimensions");
              if (t2.length !== e2.length - 2)
                throw new Error("length of strides should be the length of data dimensions");
              if (r2.length !== e2.length - 2)
                throw new Error("length of kernel shapes should be the length of data dimensions");
              for (let a2 = 0; a2 < e2.length - 2; a2++)
                g.adjustPadAndReturnShape(e2[a2 + 2], t2[a2], n2[a2], r2[a2], o2, a2, a2 + e2.length - 2, i2);
            }
          }
          static computePoolOutputShape(e2, t2, n2, r2, o2, i2, a2) {
            if (t2.length <= 0)
              throw new Error("input shape must be of size greater than 0");
            const s2 = [t2[0], t2[1]];
            return g.computeShapeHelper(e2, t2, s2, n2, r2, o2, i2, a2), s2;
          }
          static computeConvOutputShape(e2, t2, n2, r2, o2, i2, a2) {
            if (e2.length <= 0 || t2.length <= 0)
              throw new Error("invalid input tensor dims or invalid filter tensor dims");
            const s2 = [e2[0], t2[0]];
            return g.computeShapeHelper(false, e2, s2, n2, r2, o2, i2, a2), s2;
          }
          static computeShapeHelper(e2, t2, n2, r2, o2, i2, a2, s2) {
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(1);
            else
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(g.adjustPadAndReturnShape(t2[e3 + 2], r2[e3], o2[e3], i2[e3], a2, e3, e3 + t2.length - 2, s2));
          }
          static adjustPadAndReturnShape(e2, t2, n2, r2, o2, i2, a2, s2) {
            const u2 = n2 * (r2 - 1) + 1;
            if (!s2 || "NOTSET" === s2)
              return Math.floor((e2 + o2[i2] + o2[a2] - u2) / t2 + 1);
            switch (s2) {
              case "VALID":
                return o2[i2] = 0, o2[a2] = 0, Math.floor((e2 - u2) / t2 + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (1 !== n2)
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                {
                  const n3 = ((e2 + t2 - 1) / t2 - 1) * t2 + r2 - e2;
                  return o2[i2] = "SAME_LOWER" === s2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), o2[a2] = n3 - o2[i2], Math.floor((e2 + n3 - r2) / t2 + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          }
        }
        t.PoolConvUtil = g, t.MIN_CLIP = -34028234663852886e22, t.MAX_CLIP = 34028234663852886e22, t.decodeUtf8String = function(e2) {
          return new TextDecoder().decode(e2);
        };
      }, 8408: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.version = void 0, t.version = "1.16.3";
      }, 9544: function(e, t, n) {
        "use strict";
        var r, o = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && o(t2, e2, n2);
          return i(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initializeRuntime = t.initializeWebAssemblyInstance = void 0;
        const s = n(2235), u = a(n(1259)), l = n(263), c = () => !!s.env.wasm.proxy && "undefined" != typeof document;
        let p, d, f, h = false, g = false, b = false;
        const m = [], y = [], v = [], _ = [], w = [], T = [], x = () => {
          if (h || !g || b || !p)
            throw new Error("worker not ready");
        }, O = (e2) => {
          switch (e2.data.type) {
            case "init-wasm":
              h = false, e2.data.err ? (b = true, d[1](e2.data.err)) : (g = true, d[0]());
              break;
            case "init-ort":
              e2.data.err ? f[1](e2.data.err) : f[0]();
              break;
            case "create_allocate":
              e2.data.err ? m.shift()[1](e2.data.err) : m.shift()[0](e2.data.out);
              break;
            case "create_finalize":
              e2.data.err ? y.shift()[1](e2.data.err) : y.shift()[0](e2.data.out);
              break;
            case "create":
              e2.data.err ? v.shift()[1](e2.data.err) : v.shift()[0](e2.data.out);
              break;
            case "release":
              e2.data.err ? _.shift()[1](e2.data.err) : _.shift()[0]();
              break;
            case "run":
              e2.data.err ? w.shift()[1](e2.data.err) : w.shift()[0](e2.data.out);
              break;
            case "end-profiling":
              e2.data.err ? T.shift()[1](e2.data.err) : T.shift()[0]();
          }
        }, S = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
        t.initializeWebAssemblyInstance = async () => {
          if (c()) {
            if (g)
              return;
            if (h)
              throw new Error("multiple calls to 'initWasm()' detected.");
            if (b)
              throw new Error("previous call to 'initWasm()' failed.");
            return h = true, void 0 === s.env.wasm.wasmPaths && S && 0 !== S.indexOf("blob:") && (s.env.wasm.wasmPaths = S.substr(0, +S.lastIndexOf("/") + 1)), new Promise((e2, t2) => {
              null == p || p.terminate(), p = n(8050).Z(), p.onmessage = O, d = [e2, t2];
              const r2 = { type: "init-wasm", in: s.env.wasm };
              p.postMessage(r2);
            });
          }
          return (0, l.initializeWebAssembly)(s.env.wasm);
        }, t.initializeRuntime = async (e2) => {
          if (c())
            return x(), new Promise((t2, n2) => {
              f = [t2, n2];
              const r2 = { type: "init-ort", in: e2 };
              p.postMessage(r2);
            });
          await u.initRuntime(e2);
        }, t.createSessionAllocate = async (e2) => c() ? (x(), new Promise((t2, n2) => {
          m.push([t2, n2]);
          const r2 = { type: "create_allocate", in: { model: e2 } };
          p.postMessage(r2, [e2.buffer]);
        })) : u.createSessionAllocate(e2), t.createSessionFinalize = async (e2, t2) => c() ? (x(), new Promise((n2, r2) => {
          y.push([n2, r2]);
          const o2 = { type: "create_finalize", in: { modeldata: e2, options: t2 } };
          p.postMessage(o2);
        })) : u.createSessionFinalize(e2, t2), t.createSession = async (e2, t2) => c() ? (x(), new Promise((n2, r2) => {
          v.push([n2, r2]);
          const o2 = { type: "create", in: { model: e2, options: t2 } };
          p.postMessage(o2, [e2.buffer]);
        })) : u.createSession(e2, t2), t.releaseSession = async (e2) => {
          if (c())
            return x(), new Promise((t2, n2) => {
              _.push([t2, n2]);
              const r2 = { type: "release", in: e2 };
              p.postMessage(r2);
            });
          u.releaseSession(e2);
        }, t.run = async (e2, t2, n2, r2, o2) => c() ? (x(), new Promise((i2, a2) => {
          w.push([i2, a2]);
          const s2 = { type: "run", in: { sessionId: e2, inputIndices: t2, inputs: n2, outputIndices: r2, options: o2 } };
          p.postMessage(s2, u.extractTransferableBuffers(n2));
        })) : u.run(e2, t2, n2, r2, o2), t.endProfiling = async (e2) => {
          if (c())
            return x(), new Promise((t2, n2) => {
              T.push([t2, n2]);
              const r2 = { type: "end-profiling", in: e2 };
              p.postMessage(r2);
            });
          u.endProfiling(e2);
        };
      }, 7918: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.setRunOptions = void 0;
        const r = n(263), o = n(1497);
        t.setRunOptions = (e2) => {
          const t2 = (0, r.getInstance)();
          let n2 = 0;
          const i = [], a = e2 || {};
          try {
            if (void 0 === (null == e2 ? void 0 : e2.logSeverityLevel))
              a.logSeverityLevel = 2;
            else if ("number" != typeof e2.logSeverityLevel || !Number.isInteger(e2.logSeverityLevel) || e2.logSeverityLevel < 0 || e2.logSeverityLevel > 4)
              throw new Error(`log serverity level is not valid: ${e2.logSeverityLevel}`);
            if (void 0 === (null == e2 ? void 0 : e2.logVerbosityLevel))
              a.logVerbosityLevel = 0;
            else if ("number" != typeof e2.logVerbosityLevel || !Number.isInteger(e2.logVerbosityLevel))
              throw new Error(`log verbosity level is not valid: ${e2.logVerbosityLevel}`);
            void 0 === (null == e2 ? void 0 : e2.terminate) && (a.terminate = false);
            let r2 = 0;
            return void 0 !== (null == e2 ? void 0 : e2.tag) && (r2 = (0, o.allocWasmString)(e2.tag, i)), n2 = t2._OrtCreateRunOptions(a.logSeverityLevel, a.logVerbosityLevel, !!a.terminate, r2), 0 === n2 && (0, o.checkLastError)("Can't create run options."), void 0 !== (null == e2 ? void 0 : e2.extra) && (0, o.iterateExtraOptions)(e2.extra, "", /* @__PURE__ */ new WeakSet(), (e3, r3) => {
              const a2 = (0, o.allocWasmString)(e3, i), s = (0, o.allocWasmString)(r3, i);
              0 !== t2._OrtAddRunConfigEntry(n2, a2, s) && (0, o.checkLastError)(`Can't set a run config entry: ${e3} - ${r3}.`);
            }), [n2, i];
          } catch (e3) {
            throw 0 !== n2 && t2._OrtReleaseRunOptions(n2), i.forEach((e4) => t2._free(e4)), e3;
          }
        };
      }, 6640: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OnnxruntimeWebAssemblySessionHandler = void 0;
        const r = n(2806), o = n(2235), i = n(2850), a = n(9544);
        let s;
        t.OnnxruntimeWebAssemblySessionHandler = class {
          async createSessionAllocate(e2) {
            const t2 = await fetch(e2);
            if (200 !== t2.status)
              throw new Error(`failed to load model: ${e2}`);
            const n2 = await t2.arrayBuffer();
            return (0, a.createSessionAllocate)(new Uint8Array(n2));
          }
          async loadModel(e2, t2) {
            if (s || (await (0, a.initializeRuntime)(o.env), s = true), "string" == typeof e2)
              if ("undefined" != typeof process && process.versions && process.versions.node) {
                const n2 = await (0, i.promisify)(r.readFile)(e2);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n2, t2);
              } else {
                const n2 = await this.createSessionAllocate(e2);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n2, t2);
              }
            else
              [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(e2, t2);
          }
          async dispose() {
            return (0, a.releaseSession)(this.sessionId);
          }
          async run(e2, t2, n2) {
            const r2 = [], i2 = [];
            Object.entries(e2).forEach((e3) => {
              const t3 = e3[0], n3 = e3[1], o2 = this.inputNames.indexOf(t3);
              if (-1 === o2)
                throw new Error(`invalid input '${t3}'`);
              r2.push(n3), i2.push(o2);
            });
            const s2 = [];
            Object.entries(t2).forEach((e3) => {
              const t3 = e3[0], n3 = this.outputNames.indexOf(t3);
              if (-1 === n3)
                throw new Error(`invalid output '${t3}'`);
              s2.push(n3);
            });
            const u = await (0, a.run)(this.sessionId, i2, r2.map((e3) => [e3.type, e3.dims, e3.data]), s2, n2), l = {};
            for (let e3 = 0; e3 < u.length; e3++)
              l[this.outputNames[s2[e3]]] = new o.Tensor(u[e3][0], u[e3][2], u[e3][1]);
            return l;
          }
          startProfiling() {
          }
          endProfiling() {
            (0, a.endProfiling)(this.sessionId);
          }
        };
      }, 7622: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.setSessionOptions = void 0;
        const r = n(263), o = n(1497);
        t.setSessionOptions = (e2) => {
          var t2, n2, i, a;
          const s = (0, r.getInstance)();
          let u = 0;
          const l = [], c = e2 || {};
          ((e3) => {
            e3.extra || (e3.extra = {}), e3.extra.session || (e3.extra.session = {});
            const t3 = e3.extra.session;
            t3.use_ort_model_bytes_directly || (t3.use_ort_model_bytes_directly = "1"), e3.executionProviders && e3.executionProviders.some((e4) => "webgpu" === ("string" == typeof e4 ? e4 : e4.name)) && (e3.enableMemPattern = false);
          })(c);
          try {
            const e3 = ((e4) => {
              switch (e4) {
                case "disabled":
                  return 0;
                case "basic":
                  return 1;
                case "extended":
                  return 2;
                case "all":
                  return 99;
                default:
                  throw new Error(`unsupported graph optimization level: ${e4}`);
              }
            })(null !== (t2 = c.graphOptimizationLevel) && void 0 !== t2 ? t2 : "all"), p = ((e4) => {
              switch (e4) {
                case "sequential":
                  return 0;
                case "parallel":
                  return 1;
                default:
                  throw new Error(`unsupported execution mode: ${e4}`);
              }
            })(null !== (n2 = c.executionMode) && void 0 !== n2 ? n2 : "sequential"), d = "string" == typeof c.logId ? (0, o.allocWasmString)(c.logId, l) : 0, f = null !== (i = c.logSeverityLevel) && void 0 !== i ? i : 2;
            if (!Number.isInteger(f) || f < 0 || f > 4)
              throw new Error(`log serverity level is not valid: ${f}`);
            const h = null !== (a = c.logVerbosityLevel) && void 0 !== a ? a : 0;
            if (!Number.isInteger(h) || h < 0 || h > 4)
              throw new Error(`log verbosity level is not valid: ${h}`);
            const g = "string" == typeof c.optimizedModelFilePath ? (0, o.allocWasmString)(c.optimizedModelFilePath, l) : 0;
            return u = s._OrtCreateSessionOptions(e3, !!c.enableCpuMemArena, !!c.enableMemPattern, p, !!c.enableProfiling, 0, d, f, h, g), 0 === u && (0, o.checkLastError)("Can't create session options."), c.executionProviders && ((e4, t3, n3) => {
              for (const i2 of t3) {
                let t4 = "string" == typeof i2 ? i2 : i2.name;
                switch (t4) {
                  case "xnnpack":
                    t4 = "XNNPACK";
                    break;
                  case "webnn":
                    if (t4 = "WEBNN", "string" != typeof i2) {
                      const t5 = i2;
                      if (null == t5 ? void 0 : t5.deviceType) {
                        const i3 = (0, o.allocWasmString)("deviceType", n3), a3 = (0, o.allocWasmString)(t5.deviceType, n3);
                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e4, i3, a3) && (0, o.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t5.deviceType}.`);
                      }
                      if (null == t5 ? void 0 : t5.powerPreference) {
                        const i3 = (0, o.allocWasmString)("powerPreference", n3), a3 = (0, o.allocWasmString)(t5.powerPreference, n3);
                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e4, i3, a3) && (0, o.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t5.powerPreference}.`);
                      }
                    }
                    break;
                  case "webgpu":
                    t4 = "JS";
                    break;
                  case "wasm":
                  case "cpu":
                    continue;
                  default:
                    throw new Error(`not supported execution provider: ${t4}`);
                }
                const a2 = (0, o.allocWasmString)(t4, n3);
                0 !== (0, r.getInstance)()._OrtAppendExecutionProvider(e4, a2) && (0, o.checkLastError)(`Can't append execution provider: ${t4}.`);
              }
            })(u, c.executionProviders, l), void 0 !== c.extra && (0, o.iterateExtraOptions)(c.extra, "", /* @__PURE__ */ new WeakSet(), (e4, t3) => {
              const n3 = (0, o.allocWasmString)(e4, l), r2 = (0, o.allocWasmString)(t3, l);
              0 !== s._OrtAddSessionConfigEntry(u, n3, r2) && (0, o.checkLastError)(`Can't set a session config entry: ${e4} - ${t3}.`);
            }), [u, l];
          } catch (e3) {
            throw 0 !== u && s._OrtReleaseSessionOptions(u), l.forEach((e4) => s._free(e4)), e3;
          }
        };
      }, 7917: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.logLevelStringToEnum = t.tensorTypeToTypedArrayConstructor = t.getTensorElementSize = t.tensorDataTypeEnumToString = t.tensorDataTypeStringToEnum = void 0, t.tensorDataTypeStringToEnum = (e2) => {
          switch (e2) {
            case "int8":
              return 3;
            case "uint8":
              return 2;
            case "bool":
              return 9;
            case "int16":
              return 5;
            case "uint16":
              return 4;
            case "int32":
              return 6;
            case "uint32":
              return 12;
            case "float16":
              return 10;
            case "float32":
              return 1;
            case "float64":
              return 11;
            case "string":
              return 8;
            case "int64":
              return 7;
            case "uint64":
              return 13;
            default:
              throw new Error(`unsupported data type: ${e2}`);
          }
        }, t.tensorDataTypeEnumToString = (e2) => {
          switch (e2) {
            case 3:
              return "int8";
            case 2:
              return "uint8";
            case 9:
              return "bool";
            case 5:
              return "int16";
            case 4:
              return "uint16";
            case 6:
              return "int32";
            case 12:
              return "uint32";
            case 10:
              return "float16";
            case 1:
              return "float32";
            case 11:
              return "float64";
            case 8:
              return "string";
            case 7:
              return "int64";
            case 13:
              return "uint64";
            default:
              throw new Error(`unsupported data type: ${e2}`);
          }
        }, t.getTensorElementSize = (e2) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][e2], t.tensorTypeToTypedArrayConstructor = (e2) => {
          switch (e2) {
            case "float16":
            case "uint16":
              return Uint16Array;
            case "float32":
              return Float32Array;
            case "uint8":
            case "bool":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "int16":
              return Int16Array;
            case "int32":
              return Int32Array;
            case "float64":
              return Float64Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "uint64":
              return BigUint64Array;
            default:
              throw new Error(`unsupported type: ${e2}`);
          }
        }, t.logLevelStringToEnum = (e2) => {
          switch (e2) {
            case "verbose":
              return 0;
            case "info":
              return 1;
            case "warning":
              return 2;
            case "error":
              return 3;
            case "fatal":
              return 4;
            default:
              throw new Error(`unsupported logging level: ${e2}`);
          }
        };
      }, 1259: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.extractTransferableBuffers = t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initRuntime = void 0;
        const r = n(7918), o = n(7622), i = n(7917), a = n(263), s = n(1497);
        t.initRuntime = async (e2) => {
          var t2, n2;
          t2 = e2.wasm.numThreads, n2 = (0, i.logLevelStringToEnum)(e2.logLevel), 0 !== (0, a.getInstance)()._OrtInit(t2, n2) && (0, s.checkLastError)("Can't initialize onnxruntime.");
        };
        const u = /* @__PURE__ */ new Map();
        t.createSessionAllocate = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = t2._malloc(e2.byteLength);
          if (0 === n2)
            throw new Error(`Can't create a session. failed to allocate a buffer of size ${e2.byteLength}.`);
          return t2.HEAPU8.set(e2, n2), [n2, e2.byteLength];
        }, t.createSessionFinalize = (e2, t2) => {
          const n2 = (0, a.getInstance)();
          let r2 = 0, i2 = 0, l = [];
          const c = [], p = [];
          try {
            [i2, l] = (0, o.setSessionOptions)(t2), r2 = n2._OrtCreateSession(e2[0], e2[1], i2), 0 === r2 && (0, s.checkLastError)("Can't create a session.");
            const [d, f] = ((e3) => {
              const t3 = (0, a.getInstance)(), n3 = t3.stackSave();
              try {
                const n4 = t3.stackAlloc(8);
                return 0 !== t3._OrtGetInputOutputCount(e3, n4, n4 + 4) && (0, s.checkLastError)("Can't get session input/output count."), [t3.HEAP32[n4 / 4], t3.HEAP32[n4 / 4 + 1]];
              } finally {
                t3.stackRestore(n3);
              }
            })(r2), h = [], g = [];
            for (let e3 = 0; e3 < d; e3++) {
              const t3 = n2._OrtGetInputName(r2, e3);
              0 === t3 && (0, s.checkLastError)("Can't get an input name."), c.push(t3), h.push(n2.UTF8ToString(t3));
            }
            for (let e3 = 0; e3 < f; e3++) {
              const t3 = n2._OrtGetOutputName(r2, e3);
              0 === t3 && (0, s.checkLastError)("Can't get an output name."), p.push(t3), g.push(n2.UTF8ToString(t3));
            }
            return u.set(r2, [r2, c, p]), [r2, h, g];
          } catch (e3) {
            throw c.forEach((e4) => n2._OrtFree(e4)), p.forEach((e4) => n2._OrtFree(e4)), 0 !== r2 && n2._OrtReleaseSession(r2), e3;
          } finally {
            n2._free(e2[0]), 0 !== i2 && n2._OrtReleaseSessionOptions(i2), l.forEach((e3) => n2._free(e3));
          }
        }, t.createSession = (e2, n2) => {
          const r2 = (0, t.createSessionAllocate)(e2);
          return (0, t.createSessionFinalize)(r2, n2);
        }, t.releaseSession = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = u.get(e2);
          if (!n2)
            throw new Error(`cannot release session. invalid session id: ${e2}`);
          const [r2, o2, i2] = n2;
          o2.forEach((e3) => t2._OrtFree(e3)), i2.forEach((e3) => t2._OrtFree(e3)), t2._OrtReleaseSession(r2), u.delete(e2);
        }, t.run = async (e2, t2, n2, o2, l) => {
          const c = (0, a.getInstance)(), p = u.get(e2);
          if (!p)
            throw new Error(`cannot run inference. invalid session id: ${e2}`);
          const [d, f, h] = p, g = t2.length, b = o2.length;
          let m = 0, y = [];
          const v = [], _ = [];
          try {
            [m, y] = (0, r.setRunOptions)(l);
            for (let e4 = 0; e4 < g; e4++) {
              const t3 = n2[e4][0], r2 = n2[e4][1], o3 = n2[e4][2];
              let a3, u3;
              if (Array.isArray(o3)) {
                u3 = 4 * o3.length, a3 = c._malloc(u3), _.push(a3);
                let e5 = a3 / 4;
                for (let t4 = 0; t4 < o3.length; t4++) {
                  if ("string" != typeof o3[t4])
                    throw new TypeError(`tensor data at index ${t4} is not a string`);
                  c.HEAPU32[e5++] = (0, s.allocWasmString)(o3[t4], _);
                }
              } else
                u3 = o3.byteLength, a3 = c._malloc(u3), _.push(a3), c.HEAPU8.set(new Uint8Array(o3.buffer, o3.byteOffset, u3), a3);
              const l2 = c.stackSave(), p3 = c.stackAlloc(4 * r2.length);
              try {
                let n3 = p3 / 4;
                r2.forEach((e5) => c.HEAP32[n3++] = e5);
                const o4 = c._OrtCreateTensor((0, i.tensorDataTypeStringToEnum)(t3), a3, u3, p3, r2.length);
                0 === o4 && (0, s.checkLastError)(`Can't create tensor for input[${e4}].`), v.push(o4);
              } finally {
                c.stackRestore(l2);
              }
            }
            const e3 = c.stackSave(), a2 = c.stackAlloc(4 * g), u2 = c.stackAlloc(4 * g), p2 = c.stackAlloc(4 * b), w = c.stackAlloc(4 * b);
            try {
              let e4 = a2 / 4, n3 = u2 / 4, r2 = p2 / 4, l2 = w / 4;
              for (let r3 = 0; r3 < g; r3++)
                c.HEAPU32[e4++] = v[r3], c.HEAPU32[n3++] = f[t2[r3]];
              for (let e5 = 0; e5 < b; e5++)
                c.HEAPU32[r2++] = 0, c.HEAPU32[l2++] = h[o2[e5]];
              let y2 = c._OrtRun(d, u2, a2, g, w, b, p2, m);
              const _2 = c.jsepRunPromise;
              _2 && void 0 !== _2.then && (y2 = await _2);
              const T = [];
              0 !== y2 && (0, s.checkLastError)("failed to call OrtRun().");
              for (let e5 = 0; e5 < b; e5++) {
                const t3 = c.HEAPU32[p2 / 4 + e5], n4 = c.stackSave(), r3 = c.stackAlloc(16);
                let o3, a3 = 0;
                try {
                  y2 = c._OrtGetTensorData(t3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== y2 && (0, s.checkLastError)(`Can't access output tensor data on index ${e5}.`);
                  let n5 = r3 / 4;
                  const u3 = c.HEAPU32[n5++];
                  a3 = c.HEAPU32[n5++];
                  const l3 = c.HEAPU32[n5++], p3 = c.HEAPU32[n5++], d2 = [];
                  for (let e6 = 0; e6 < p3; e6++)
                    d2.push(c.HEAPU32[l3 / 4 + e6]);
                  c._OrtFree(l3);
                  const f2 = 0 === d2.length ? 1 : d2.reduce((e6, t4) => e6 * t4);
                  if (o3 = (0, i.tensorDataTypeEnumToString)(u3), "string" === o3) {
                    const e6 = [];
                    let t4 = a3 / 4;
                    for (let n6 = 0; n6 < f2; n6++) {
                      const r4 = c.HEAPU32[t4++], o4 = n6 === f2 - 1 ? void 0 : c.HEAPU32[t4] - r4;
                      e6.push(c.UTF8ToString(r4, o4));
                    }
                    T.push([o3, d2, e6]);
                  } else {
                    const e6 = new ((0, i.tensorTypeToTypedArrayConstructor)(o3))(f2);
                    new Uint8Array(e6.buffer, e6.byteOffset, e6.byteLength).set(c.HEAPU8.subarray(a3, a3 + e6.byteLength)), T.push([o3, d2, e6]);
                  }
                } finally {
                  c.stackRestore(n4), "string" === o3 && a3 && c._free(a3), c._OrtReleaseTensor(t3);
                }
              }
              return T;
            } finally {
              c.stackRestore(e3);
            }
          } finally {
            v.forEach((e3) => c._OrtReleaseTensor(e3)), _.forEach((e3) => c._free(e3)), 0 !== m && c._OrtReleaseRunOptions(m), y.forEach((e3) => c._free(e3));
          }
        }, t.endProfiling = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = u.get(e2);
          if (!n2)
            throw new Error("invalid session id");
          const r2 = n2[0], o2 = t2._OrtEndProfiling(r2);
          0 === o2 && (0, s.checkLastError)("Can't get an profile file name."), t2._OrtFree(o2);
        }, t.extractTransferableBuffers = (e2) => {
          const t2 = [];
          for (const n2 of e2) {
            const e3 = n2[2];
            !Array.isArray(e3) && e3.buffer && t2.push(e3.buffer);
          }
          return t2;
        };
      }, 263: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), i = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.dispose = t.getInstance = t.initializeWebAssembly = void 0;
        const a = i(n(6449)), s = n(932), u = n(3474);
        let l, c = false, p = false, d = false;
        t.initializeWebAssembly = async (e2) => {
          if (c)
            return Promise.resolve();
          if (p)
            throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
          if (d)
            throw new Error("previous call to 'initializeWebAssembly()' failed.");
          p = true;
          const t2 = e2.initTimeout, r2 = e2.numThreads, o2 = e2.simd, i2 = r2 > 1 && (() => {
            try {
              return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
            } catch (e3) {
              return false;
            }
          })(), f = o2 && (() => {
            try {
              return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
            } catch (e3) {
              return false;
            }
          })(), h = e2.wasmPaths, g = "string" == typeof h ? h : void 0, b = /* @__PURE__ */ ((e3, t3) => t3 ? e3 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : e3 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm")(f, i2), m = "object" == typeof h ? h[b] : void 0;
          let y = false;
          const v = [];
          if (t2 > 0 && v.push(new Promise((e3) => {
            setTimeout(() => {
              y = true, e3();
            }, t2);
          })), v.push(new Promise((e3, t3) => {
            const r3 = i2 ? u : s, o3 = { locateFile: (e4, t4) => i2 && e4.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" })) : e4.endsWith(".wasm") ? m || (null != g ? g : t4) + b : t4 + e4 };
            if (i2)
              if ("undefined" == typeof Blob)
                o3.mainScriptUrlOrBlob = a.join(__dirname, "ort-wasm-threaded.js");
              else {
                const e4 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                o3.mainScriptUrlOrBlob = new Blob([e4], { type: "text/javascript" });
              }
            r3(o3).then((t4) => {
              p = false, c = true, l = t4, e3();
            }, (e4) => {
              p = false, d = true, t3(e4);
            });
          })), await Promise.race(v), y)
            throw new Error(`WebAssembly backend initializing failed due to timeout: ${t2}ms`);
        }, t.getInstance = () => {
          if (c && l)
            return l;
          throw new Error("WebAssembly is not initialized yet.");
        }, t.dispose = () => {
          var e2;
          !c || p || d || (p = true, null === (e2 = l.PThread) || void 0 === e2 || e2.terminateAllThreads(), l = void 0, p = false, c = false, d = true);
        };
      }, 1497: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.checkLastError = t.iterateExtraOptions = t.allocWasmString = void 0;
        const r = n(263);
        t.allocWasmString = (e2, t2) => {
          const n2 = (0, r.getInstance)(), o = n2.lengthBytesUTF8(e2) + 1, i = n2._malloc(o);
          return n2.stringToUTF8(e2, i, o), t2.push(i), i;
        }, t.iterateExtraOptions = (e2, n2, r2, o) => {
          if ("object" == typeof e2 && null !== e2) {
            if (r2.has(e2))
              throw new Error("Circular reference in options");
            r2.add(e2);
          }
          Object.entries(e2).forEach(([e3, i]) => {
            const a = n2 ? n2 + e3 : e3;
            if ("object" == typeof i)
              (0, t.iterateExtraOptions)(i, a + ".", r2, o);
            else if ("string" == typeof i || "number" == typeof i)
              o(a, i.toString());
            else {
              if ("boolean" != typeof i)
                throw new Error("Can't handle extra config type: " + typeof i);
              o(a, i ? "1" : "0");
            }
          });
        }, t.checkLastError = (e2) => {
          const t2 = (0, r.getInstance)(), n2 = t2.stackSave();
          try {
            const n3 = t2.stackAlloc(8);
            t2._OrtGetLastError(n3, n3 + 4);
            const r2 = t2.HEAP32[n3 / 4], o = t2.HEAPU32[n3 / 4 + 1], i = o ? t2.UTF8ToString(o) : "";
            throw new Error(`${e2} ERROR_CODE: ${r2}, ERROR_MESSAGE: ${i}`);
          } finally {
            t2.stackRestore(n2);
          }
        };
      }, 8050: (e, t, n) => {
        "use strict";
        n.d(t, { Z: () => i });
        var r = n(6614), o = n.n(r);
        function i() {
          return o()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:"all"),f=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:"sequential"),d="string"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)("Can\'t create session options."),l.executionProviders&&((e,t,r)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,"",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)("Can\'t create a session.");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),"string"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h="string"==typeof g?g:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(p,o),y="object"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g="./this.program",h=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:"utf8")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{t=r(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&"undefined"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>O.writeSync(2,e.join(" ")+"\\n"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&te("no native wasm support detected");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te("INITIAL_MEMORY should be larger than STACK_SIZE, was "+j+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R("failed to asynchronously prepare wasm: "+e),te(e)}))}function oe(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:"run",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V="ort-wasm-threaded.wasm")||(V=_(V));var ce="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):"";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),"unwind";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:["$terminateWorker"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\'Internal error! Worker sent a message "\'+n+\'" to target pthread \'+r.targetThread+", but that thread no longer exists!")}else"checkMailbox"===n?He():"spawnThread"===n?ue(r):"cleanupThread"===n?se(r.thread):"killThread"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):"cancelThread"===n?ge.Fa[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t(e)):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===n?c[r.handler](...r.args):n&&R("worker sent an unknown command "+n)},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var r,n=[];for(r of["onExit","onAbort","print","printErr"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:"load",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_("ort-wasm-threaded.worker.js");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,"undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob="spawnThread",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||"unwind"==e||h(1,e)}}catch(e){e instanceof oe||"unwind"==e||h(1,e)}};function We(e){e>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te("initRandomDevice")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,"0")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):""},r=fe(r),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),l[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(f in l={"%a":e=>d[e.Ga].substring(0,3),"%A":e=>d[e.Ga],"%b":e=>p[e.Na].substring(0,3),"%B":e=>p[e.Na],"%C":e=>i((e.Ka+1900)/100|0,2),"%d":e=>i(e.Qa,2),"%e":e=>o(e.Qa,2," "),"%g":e=>c(e).toString().substring(2),"%G":e=>c(e),"%H":e=>i(e.Ma,2),"%I":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},"%m":e=>i(e.Na+1,2),"%M":e=>i(e.jb,2),"%n":()=>"\\n","%p":e=>0<=e.Ma&&12>e.Ma?"AM":"PM","%S":e=>i(e.kb,2),"%t":()=>"\\t","%u":e=>e.Ga||7,"%U":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),"%V":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},"%w":e=>e.Ga,"%W":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),"%y":e=>(e.Ka+1900).toString().substring(2),"%Y":e=>e.Ka+1900,"%z":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.lb,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),l)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=ge.Fa[e])&&e.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te("")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var r=V;return T||"function"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith("file://")||v||"function"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R("wasm streaming compile failed: "+n),R("falling back to ArrayBuffer instantiation"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c="./this.program",l=(e,t)=>{throw t},f="object"==typeof window,d="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(f||d)&&(d?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e="Aborted("+e+")"),M=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function H(e){return e.startsWith("data:application/octet-stream;base64,")}if(!H(D="ort-wasm.wasm")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function z(e,t,r){return function(e){if(!y&&(f||d)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b("failed to asynchronously prepare wasm: "+e),W(e)}))}function G(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):"",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):""},r=J(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(l in c={"%a":e=>f[e.ha].substring(0,3),"%A":e=>f[e.ha],"%b":e=>d[e.pa].substring(0,3),"%B":e=>d[e.pa],"%C":e=>o((e.na+1900)/100|0,2),"%d":e=>o(e.ra,2),"%e":e=>a(e.ra,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>o(e.oa,2),"%I":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},"%m":e=>o(e.pa+1,2),"%M":e=>o(e.xa,2),"%n":()=>"\\n","%p":e=>0<=e.oa&&12>e.oa?"AM":"PM","%S":e=>o(e.ya,2),"%t":()=>"\\t","%u":e=>e.ha||7,"%U":e=>o(Math.floor((e.ma+7-e.ha)/7),2),"%V":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},"%w":e=>e.ha,"%W":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),"%y":e=>(e.na+1900).toString().substring(2),"%Y":e=>e.na+1900,"%z":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.za,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),c)r.includes(l)&&(r=r.replace(new RegExp(l,"g"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var r=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith("file://")||p||"function"!=typeof fetch?z(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b("wasm streaming compile failed: "+n),b("falling back to ArrayBuffer instantiation"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:n})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n', "Worker", void 0, void 0);
        }
      }, 6614: (e) => {
        "use strict";
        e.exports = function(e2, t, n, r) {
          var o = self || window;
          try {
            try {
              var i;
              try {
                i = new o.Blob([e2]);
              } catch (t2) {
                (i = new (o.BlobBuilder || o.WebKitBlobBuilder || o.MozBlobBuilder || o.MSBlobBuilder)()).append(e2), i = i.getBlob();
              }
              var a = o.URL || o.webkitURL, s = a.createObjectURL(i), u = new o[t](s, n);
              return a.revokeObjectURL(s), u;
            } catch (r2) {
              return new o[t]("data:application/javascript,".concat(encodeURIComponent(e2)), n);
            }
          } catch (e3) {
            if (!r)
              throw Error("Inline worker is not supported");
            return new o[t](r, n);
          }
        };
      }, 2446: (e, t, n) => {
        "use strict";
        var r, o, i, a = n(2100), s = a.Reader, u = a.Writer, l = a.util, c = a.roots.default || (a.roots.default = {});
        c.onnx = ((i = {}).Version = (r = {}, (o = Object.create(r))[r[0] = "_START_VERSION"] = 0, o[r[1] = "IR_VERSION_2017_10_10"] = 1, o[r[2] = "IR_VERSION_2017_10_30"] = 2, o[r[3] = "IR_VERSION_2017_11_3"] = 3, o[r[4] = "IR_VERSION_2019_1_22"] = 4, o[r[5] = "IR_VERSION_2019_3_18"] = 5, o[r[6] = "IR_VERSION_2019_9_19"] = 6, o[r[7] = "IR_VERSION_2020_5_8"] = 7, o[r[8] = "IR_VERSION_2021_7_30"] = 8, o[r[9] = "IR_VERSION"] = 9, o), i.AttributeProto = function() {
          function e2(e3) {
            if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.refAttrName = "", e2.prototype.docString = "", e2.prototype.type = 0, e2.prototype.f = 0, e2.prototype.i = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.s = l.newBuffer([]), e2.prototype.t = null, e2.prototype.g = null, e2.prototype.sparseTensor = null, e2.prototype.tp = null, e2.prototype.floats = l.emptyArray, e2.prototype.ints = l.emptyArray, e2.prototype.strings = l.emptyArray, e2.prototype.tensors = l.emptyArray, e2.prototype.graphs = l.emptyArray, e2.prototype.sparseTensors = l.emptyArray, e2.prototype.typeProtos = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.f && Object.hasOwnProperty.call(e3, "f") && t2.uint32(21).float(e3.f), null != e3.i && Object.hasOwnProperty.call(e3, "i") && t2.uint32(24).int64(e3.i), null != e3.s && Object.hasOwnProperty.call(e3, "s") && t2.uint32(34).bytes(e3.s), null != e3.t && Object.hasOwnProperty.call(e3, "t") && c.onnx.TensorProto.encode(e3.t, t2.uint32(42).fork()).ldelim(), null != e3.g && Object.hasOwnProperty.call(e3, "g") && c.onnx.GraphProto.encode(e3.g, t2.uint32(50).fork()).ldelim(), null != e3.floats && e3.floats.length) {
              t2.uint32(58).fork();
              for (var n2 = 0; n2 < e3.floats.length; ++n2)
                t2.float(e3.floats[n2]);
              t2.ldelim();
            }
            if (null != e3.ints && e3.ints.length) {
              for (t2.uint32(66).fork(), n2 = 0; n2 < e3.ints.length; ++n2)
                t2.int64(e3.ints[n2]);
              t2.ldelim();
            }
            if (null != e3.strings && e3.strings.length)
              for (n2 = 0; n2 < e3.strings.length; ++n2)
                t2.uint32(74).bytes(e3.strings[n2]);
            if (null != e3.tensors && e3.tensors.length)
              for (n2 = 0; n2 < e3.tensors.length; ++n2)
                c.onnx.TensorProto.encode(e3.tensors[n2], t2.uint32(82).fork()).ldelim();
            if (null != e3.graphs && e3.graphs.length)
              for (n2 = 0; n2 < e3.graphs.length; ++n2)
                c.onnx.GraphProto.encode(e3.graphs[n2], t2.uint32(90).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(106).string(e3.docString), null != e3.tp && Object.hasOwnProperty.call(e3, "tp") && c.onnx.TypeProto.encode(e3.tp, t2.uint32(114).fork()).ldelim(), null != e3.typeProtos && e3.typeProtos.length)
              for (n2 = 0; n2 < e3.typeProtos.length; ++n2)
                c.onnx.TypeProto.encode(e3.typeProtos[n2], t2.uint32(122).fork()).ldelim();
            if (null != e3.type && Object.hasOwnProperty.call(e3, "type") && t2.uint32(160).int32(e3.type), null != e3.refAttrName && Object.hasOwnProperty.call(e3, "refAttrName") && t2.uint32(170).string(e3.refAttrName), null != e3.sparseTensor && Object.hasOwnProperty.call(e3, "sparseTensor") && c.onnx.SparseTensorProto.encode(e3.sparseTensor, t2.uint32(178).fork()).ldelim(), null != e3.sparseTensors && e3.sparseTensors.length)
              for (n2 = 0; n2 < e3.sparseTensors.length; ++n2)
                c.onnx.SparseTensorProto.encode(e3.sparseTensors[n2], t2.uint32(186).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.AttributeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 21:
                  r2.refAttrName = e3.string();
                  break;
                case 13:
                  r2.docString = e3.string();
                  break;
                case 20:
                  r2.type = e3.int32();
                  break;
                case 2:
                  r2.f = e3.float();
                  break;
                case 3:
                  r2.i = e3.int64();
                  break;
                case 4:
                  r2.s = e3.bytes();
                  break;
                case 5:
                  r2.t = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 6:
                  r2.g = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 22:
                  r2.sparseTensor = c.onnx.SparseTensorProto.decode(e3, e3.uint32());
                  break;
                case 14:
                  r2.tp = c.onnx.TypeProto.decode(e3, e3.uint32());
                  break;
                case 7:
                  if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & o2))
                    for (var i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.floats.push(e3.float());
                  else
                    r2.floats.push(e3.float());
                  break;
                case 8:
                  if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.ints.push(e3.int64());
                  else
                    r2.ints.push(e3.int64());
                  break;
                case 9:
                  r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(e3.bytes());
                  break;
                case 10:
                  r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(c.onnx.TensorProto.decode(e3, e3.uint32()));
                  break;
                case 11:
                  r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(c.onnx.GraphProto.decode(e3, e3.uint32()));
                  break;
                case 23:
                  r2.sparseTensors && r2.sparseTensors.length || (r2.sparseTensors = []), r2.sparseTensors.push(c.onnx.SparseTensorProto.decode(e3, e3.uint32()));
                  break;
                case 15:
                  r2.typeProtos && r2.typeProtos.length || (r2.typeProtos = []), r2.typeProtos.push(c.onnx.TypeProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.refAttrName && e3.hasOwnProperty("refAttrName") && !l.isString(e3.refAttrName))
              return "refAttrName: string expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.type && e3.hasOwnProperty("type"))
              switch (e3.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 11:
                case 13:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 14:
              }
            if (null != e3.f && e3.hasOwnProperty("f") && "number" != typeof e3.f)
              return "f: number expected";
            if (null != e3.i && e3.hasOwnProperty("i") && !(l.isInteger(e3.i) || e3.i && l.isInteger(e3.i.low) && l.isInteger(e3.i.high)))
              return "i: integer|Long expected";
            if (null != e3.s && e3.hasOwnProperty("s") && !(e3.s && "number" == typeof e3.s.length || l.isString(e3.s)))
              return "s: buffer expected";
            if (null != e3.t && e3.hasOwnProperty("t") && (n2 = c.onnx.TensorProto.verify(e3.t)))
              return "t." + n2;
            if (null != e3.g && e3.hasOwnProperty("g") && (n2 = c.onnx.GraphProto.verify(e3.g)))
              return "g." + n2;
            if (null != e3.sparseTensor && e3.hasOwnProperty("sparseTensor") && (n2 = c.onnx.SparseTensorProto.verify(e3.sparseTensor)))
              return "sparseTensor." + n2;
            if (null != e3.tp && e3.hasOwnProperty("tp") && (n2 = c.onnx.TypeProto.verify(e3.tp)))
              return "tp." + n2;
            if (null != e3.floats && e3.hasOwnProperty("floats")) {
              if (!Array.isArray(e3.floats))
                return "floats: array expected";
              for (var t2 = 0; t2 < e3.floats.length; ++t2)
                if ("number" != typeof e3.floats[t2])
                  return "floats: number[] expected";
            }
            if (null != e3.ints && e3.hasOwnProperty("ints")) {
              if (!Array.isArray(e3.ints))
                return "ints: array expected";
              for (t2 = 0; t2 < e3.ints.length; ++t2)
                if (!(l.isInteger(e3.ints[t2]) || e3.ints[t2] && l.isInteger(e3.ints[t2].low) && l.isInteger(e3.ints[t2].high)))
                  return "ints: integer|Long[] expected";
            }
            if (null != e3.strings && e3.hasOwnProperty("strings")) {
              if (!Array.isArray(e3.strings))
                return "strings: array expected";
              for (t2 = 0; t2 < e3.strings.length; ++t2)
                if (!(e3.strings[t2] && "number" == typeof e3.strings[t2].length || l.isString(e3.strings[t2])))
                  return "strings: buffer[] expected";
            }
            if (null != e3.tensors && e3.hasOwnProperty("tensors")) {
              if (!Array.isArray(e3.tensors))
                return "tensors: array expected";
              for (t2 = 0; t2 < e3.tensors.length; ++t2)
                if (n2 = c.onnx.TensorProto.verify(e3.tensors[t2]))
                  return "tensors." + n2;
            }
            if (null != e3.graphs && e3.hasOwnProperty("graphs")) {
              if (!Array.isArray(e3.graphs))
                return "graphs: array expected";
              for (t2 = 0; t2 < e3.graphs.length; ++t2)
                if (n2 = c.onnx.GraphProto.verify(e3.graphs[t2]))
                  return "graphs." + n2;
            }
            if (null != e3.sparseTensors && e3.hasOwnProperty("sparseTensors")) {
              if (!Array.isArray(e3.sparseTensors))
                return "sparseTensors: array expected";
              for (t2 = 0; t2 < e3.sparseTensors.length; ++t2)
                if (n2 = c.onnx.SparseTensorProto.verify(e3.sparseTensors[t2]))
                  return "sparseTensors." + n2;
            }
            if (null != e3.typeProtos && e3.hasOwnProperty("typeProtos")) {
              if (!Array.isArray(e3.typeProtos))
                return "typeProtos: array expected";
              for (t2 = 0; t2 < e3.typeProtos.length; ++t2) {
                var n2;
                if (n2 = c.onnx.TypeProto.verify(e3.typeProtos[t2]))
                  return "typeProtos." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.AttributeProto)
              return e3;
            var t2 = new c.onnx.AttributeProto();
            switch (null != e3.name && (t2.name = String(e3.name)), null != e3.refAttrName && (t2.refAttrName = String(e3.refAttrName)), null != e3.docString && (t2.docString = String(e3.docString)), e3.type) {
              default:
                if ("number" == typeof e3.type) {
                  t2.type = e3.type;
                  break;
                }
                break;
              case "UNDEFINED":
              case 0:
                t2.type = 0;
                break;
              case "FLOAT":
              case 1:
                t2.type = 1;
                break;
              case "INT":
              case 2:
                t2.type = 2;
                break;
              case "STRING":
              case 3:
                t2.type = 3;
                break;
              case "TENSOR":
              case 4:
                t2.type = 4;
                break;
              case "GRAPH":
              case 5:
                t2.type = 5;
                break;
              case "SPARSE_TENSOR":
              case 11:
                t2.type = 11;
                break;
              case "TYPE_PROTO":
              case 13:
                t2.type = 13;
                break;
              case "FLOATS":
              case 6:
                t2.type = 6;
                break;
              case "INTS":
              case 7:
                t2.type = 7;
                break;
              case "STRINGS":
              case 8:
                t2.type = 8;
                break;
              case "TENSORS":
              case 9:
                t2.type = 9;
                break;
              case "GRAPHS":
              case 10:
                t2.type = 10;
                break;
              case "SPARSE_TENSORS":
              case 12:
                t2.type = 12;
                break;
              case "TYPE_PROTOS":
              case 14:
                t2.type = 14;
            }
            if (null != e3.f && (t2.f = Number(e3.f)), null != e3.i && (l.Long ? (t2.i = l.Long.fromValue(e3.i)).unsigned = false : "string" == typeof e3.i ? t2.i = parseInt(e3.i, 10) : "number" == typeof e3.i ? t2.i = e3.i : "object" == typeof e3.i && (t2.i = new l.LongBits(e3.i.low >>> 0, e3.i.high >>> 0).toNumber())), null != e3.s && ("string" == typeof e3.s ? l.base64.decode(e3.s, t2.s = l.newBuffer(l.base64.length(e3.s)), 0) : e3.s.length >= 0 && (t2.s = e3.s)), null != e3.t) {
              if ("object" != typeof e3.t)
                throw TypeError(".onnx.AttributeProto.t: object expected");
              t2.t = c.onnx.TensorProto.fromObject(e3.t);
            }
            if (null != e3.g) {
              if ("object" != typeof e3.g)
                throw TypeError(".onnx.AttributeProto.g: object expected");
              t2.g = c.onnx.GraphProto.fromObject(e3.g);
            }
            if (null != e3.sparseTensor) {
              if ("object" != typeof e3.sparseTensor)
                throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
              t2.sparseTensor = c.onnx.SparseTensorProto.fromObject(e3.sparseTensor);
            }
            if (null != e3.tp) {
              if ("object" != typeof e3.tp)
                throw TypeError(".onnx.AttributeProto.tp: object expected");
              t2.tp = c.onnx.TypeProto.fromObject(e3.tp);
            }
            if (e3.floats) {
              if (!Array.isArray(e3.floats))
                throw TypeError(".onnx.AttributeProto.floats: array expected");
              t2.floats = [];
              for (var n2 = 0; n2 < e3.floats.length; ++n2)
                t2.floats[n2] = Number(e3.floats[n2]);
            }
            if (e3.ints) {
              if (!Array.isArray(e3.ints))
                throw TypeError(".onnx.AttributeProto.ints: array expected");
              for (t2.ints = [], n2 = 0; n2 < e3.ints.length; ++n2)
                l.Long ? (t2.ints[n2] = l.Long.fromValue(e3.ints[n2])).unsigned = false : "string" == typeof e3.ints[n2] ? t2.ints[n2] = parseInt(e3.ints[n2], 10) : "number" == typeof e3.ints[n2] ? t2.ints[n2] = e3.ints[n2] : "object" == typeof e3.ints[n2] && (t2.ints[n2] = new l.LongBits(e3.ints[n2].low >>> 0, e3.ints[n2].high >>> 0).toNumber());
            }
            if (e3.strings) {
              if (!Array.isArray(e3.strings))
                throw TypeError(".onnx.AttributeProto.strings: array expected");
              for (t2.strings = [], n2 = 0; n2 < e3.strings.length; ++n2)
                "string" == typeof e3.strings[n2] ? l.base64.decode(e3.strings[n2], t2.strings[n2] = l.newBuffer(l.base64.length(e3.strings[n2])), 0) : e3.strings[n2].length >= 0 && (t2.strings[n2] = e3.strings[n2]);
            }
            if (e3.tensors) {
              if (!Array.isArray(e3.tensors))
                throw TypeError(".onnx.AttributeProto.tensors: array expected");
              for (t2.tensors = [], n2 = 0; n2 < e3.tensors.length; ++n2) {
                if ("object" != typeof e3.tensors[n2])
                  throw TypeError(".onnx.AttributeProto.tensors: object expected");
                t2.tensors[n2] = c.onnx.TensorProto.fromObject(e3.tensors[n2]);
              }
            }
            if (e3.graphs) {
              if (!Array.isArray(e3.graphs))
                throw TypeError(".onnx.AttributeProto.graphs: array expected");
              for (t2.graphs = [], n2 = 0; n2 < e3.graphs.length; ++n2) {
                if ("object" != typeof e3.graphs[n2])
                  throw TypeError(".onnx.AttributeProto.graphs: object expected");
                t2.graphs[n2] = c.onnx.GraphProto.fromObject(e3.graphs[n2]);
              }
            }
            if (e3.sparseTensors) {
              if (!Array.isArray(e3.sparseTensors))
                throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
              for (t2.sparseTensors = [], n2 = 0; n2 < e3.sparseTensors.length; ++n2) {
                if ("object" != typeof e3.sparseTensors[n2])
                  throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
                t2.sparseTensors[n2] = c.onnx.SparseTensorProto.fromObject(e3.sparseTensors[n2]);
              }
            }
            if (e3.typeProtos) {
              if (!Array.isArray(e3.typeProtos))
                throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
              for (t2.typeProtos = [], n2 = 0; n2 < e3.typeProtos.length; ++n2) {
                if ("object" != typeof e3.typeProtos[n2])
                  throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
                t2.typeProtos[n2] = c.onnx.TypeProto.fromObject(e3.typeProtos[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = [], n2.typeProtos = [], n2.sparseTensors = []), t2.defaults) {
              if (n2.name = "", n2.f = 0, l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.i = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.i = t2.longs === String ? "0" : 0;
              t2.bytes === String ? n2.s = "" : (n2.s = [], t2.bytes !== Array && (n2.s = l.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.tp = null, n2.type = t2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "", n2.sparseTensor = null;
            }
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.f && e3.hasOwnProperty("f") && (n2.f = t2.json && !isFinite(e3.f) ? String(e3.f) : e3.f), null != e3.i && e3.hasOwnProperty("i") && ("number" == typeof e3.i ? n2.i = t2.longs === String ? String(e3.i) : e3.i : n2.i = t2.longs === String ? l.Long.prototype.toString.call(e3.i) : t2.longs === Number ? new l.LongBits(e3.i.low >>> 0, e3.i.high >>> 0).toNumber() : e3.i), null != e3.s && e3.hasOwnProperty("s") && (n2.s = t2.bytes === String ? l.base64.encode(e3.s, 0, e3.s.length) : t2.bytes === Array ? Array.prototype.slice.call(e3.s) : e3.s), null != e3.t && e3.hasOwnProperty("t") && (n2.t = c.onnx.TensorProto.toObject(e3.t, t2)), null != e3.g && e3.hasOwnProperty("g") && (n2.g = c.onnx.GraphProto.toObject(e3.g, t2)), e3.floats && e3.floats.length) {
              n2.floats = [];
              for (var o2 = 0; o2 < e3.floats.length; ++o2)
                n2.floats[o2] = t2.json && !isFinite(e3.floats[o2]) ? String(e3.floats[o2]) : e3.floats[o2];
            }
            if (e3.ints && e3.ints.length)
              for (n2.ints = [], o2 = 0; o2 < e3.ints.length; ++o2)
                "number" == typeof e3.ints[o2] ? n2.ints[o2] = t2.longs === String ? String(e3.ints[o2]) : e3.ints[o2] : n2.ints[o2] = t2.longs === String ? l.Long.prototype.toString.call(e3.ints[o2]) : t2.longs === Number ? new l.LongBits(e3.ints[o2].low >>> 0, e3.ints[o2].high >>> 0).toNumber() : e3.ints[o2];
            if (e3.strings && e3.strings.length)
              for (n2.strings = [], o2 = 0; o2 < e3.strings.length; ++o2)
                n2.strings[o2] = t2.bytes === String ? l.base64.encode(e3.strings[o2], 0, e3.strings[o2].length) : t2.bytes === Array ? Array.prototype.slice.call(e3.strings[o2]) : e3.strings[o2];
            if (e3.tensors && e3.tensors.length)
              for (n2.tensors = [], o2 = 0; o2 < e3.tensors.length; ++o2)
                n2.tensors[o2] = c.onnx.TensorProto.toObject(e3.tensors[o2], t2);
            if (e3.graphs && e3.graphs.length)
              for (n2.graphs = [], o2 = 0; o2 < e3.graphs.length; ++o2)
                n2.graphs[o2] = c.onnx.GraphProto.toObject(e3.graphs[o2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.tp && e3.hasOwnProperty("tp") && (n2.tp = c.onnx.TypeProto.toObject(e3.tp, t2)), e3.typeProtos && e3.typeProtos.length)
              for (n2.typeProtos = [], o2 = 0; o2 < e3.typeProtos.length; ++o2)
                n2.typeProtos[o2] = c.onnx.TypeProto.toObject(e3.typeProtos[o2], t2);
            if (null != e3.type && e3.hasOwnProperty("type") && (n2.type = t2.enums === String ? void 0 === c.onnx.AttributeProto.AttributeType[e3.type] ? e3.type : c.onnx.AttributeProto.AttributeType[e3.type] : e3.type), null != e3.refAttrName && e3.hasOwnProperty("refAttrName") && (n2.refAttrName = e3.refAttrName), null != e3.sparseTensor && e3.hasOwnProperty("sparseTensor") && (n2.sparseTensor = c.onnx.SparseTensorProto.toObject(e3.sparseTensor, t2)), e3.sparseTensors && e3.sparseTensors.length)
              for (n2.sparseTensors = [], o2 = 0; o2 < e3.sparseTensors.length; ++o2)
                n2.sparseTensors[o2] = c.onnx.SparseTensorProto.toObject(e3.sparseTensors[o2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.AttributeProto";
          }, e2.AttributeType = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "UNDEFINED"] = 0, t2[e3[1] = "FLOAT"] = 1, t2[e3[2] = "INT"] = 2, t2[e3[3] = "STRING"] = 3, t2[e3[4] = "TENSOR"] = 4, t2[e3[5] = "GRAPH"] = 5, t2[e3[11] = "SPARSE_TENSOR"] = 11, t2[e3[13] = "TYPE_PROTO"] = 13, t2[e3[6] = "FLOATS"] = 6, t2[e3[7] = "INTS"] = 7, t2[e3[8] = "STRINGS"] = 8, t2[e3[9] = "TENSORS"] = 9, t2[e3[10] = "GRAPHS"] = 10, t2[e3[12] = "SPARSE_TENSORS"] = 12, t2[e3[14] = "TYPE_PROTOS"] = 14, t2;
          }(), e2;
        }(), i.ValueInfoProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.type = null, e2.prototype.docString = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.type && Object.hasOwnProperty.call(e3, "type") && c.onnx.TypeProto.encode(e3.type, t2.uint32(18).fork()).ldelim(), null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(26).string(e3.docString), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.ValueInfoProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 2:
                  r2.type = c.onnx.TypeProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  r2.docString = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.type && e3.hasOwnProperty("type")) {
              var t2 = c.onnx.TypeProto.verify(e3.type);
              if (t2)
                return "type." + t2;
            }
            return null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString) ? "docString: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.ValueInfoProto)
              return e3;
            var t2 = new c.onnx.ValueInfoProto();
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.type) {
              if ("object" != typeof e3.type)
                throw TypeError(".onnx.ValueInfoProto.type: object expected");
              t2.type = c.onnx.TypeProto.fromObject(e3.type);
            }
            return null != e3.docString && (t2.docString = String(e3.docString)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            return t2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.type && e3.hasOwnProperty("type") && (n2.type = c.onnx.TypeProto.toObject(e3.type, t2)), null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.ValueInfoProto";
          }, e2;
        }(), i.NodeProto = function() {
          function e2(e3) {
            if (this.input = [], this.output = [], this.attribute = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.name = "", e2.prototype.opType = "", e2.prototype.domain = "", e2.prototype.attribute = l.emptyArray, e2.prototype.docString = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.input && e3.input.length)
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.uint32(10).string(e3.input[n2]);
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                t2.uint32(18).string(e3.output[n2]);
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(26).string(e3.name), null != e3.opType && Object.hasOwnProperty.call(e3, "opType") && t2.uint32(34).string(e3.opType), null != e3.attribute && e3.attribute.length)
              for (n2 = 0; n2 < e3.attribute.length; ++n2)
                c.onnx.AttributeProto.encode(e3.attribute[n2], t2.uint32(42).fork()).ldelim();
            return null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(50).string(e3.docString), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(58).string(e3.domain), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.NodeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(e3.string());
                  break;
                case 2:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(e3.string());
                  break;
                case 3:
                  r2.name = e3.string();
                  break;
                case 4:
                  r2.opType = e3.string();
                  break;
                case 7:
                  r2.domain = e3.string();
                  break;
                case 5:
                  r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(c.onnx.AttributeProto.decode(e3, e3.uint32()));
                  break;
                case 6:
                  r2.docString = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (var t2 = 0; t2 < e3.input.length; ++t2)
                if (!l.isString(e3.input[t2]))
                  return "input: string[] expected";
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (!l.isString(e3.output[t2]))
                  return "output: string[] expected";
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.opType && e3.hasOwnProperty("opType") && !l.isString(e3.opType))
              return "opType: string expected";
            if (null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain))
              return "domain: string expected";
            if (null != e3.attribute && e3.hasOwnProperty("attribute")) {
              if (!Array.isArray(e3.attribute))
                return "attribute: array expected";
              for (t2 = 0; t2 < e3.attribute.length; ++t2) {
                var n2 = c.onnx.AttributeProto.verify(e3.attribute[t2]);
                if (n2)
                  return "attribute." + n2;
              }
            }
            return null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString) ? "docString: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.NodeProto)
              return e3;
            var t2 = new c.onnx.NodeProto();
            if (e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.NodeProto.input: array expected");
              t2.input = [];
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.input[n2] = String(e3.input[n2]);
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.NodeProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2)
                t2.output[n2] = String(e3.output[n2]);
            }
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.opType && (t2.opType = String(e3.opType)), null != e3.domain && (t2.domain = String(e3.domain)), e3.attribute) {
              if (!Array.isArray(e3.attribute))
                throw TypeError(".onnx.NodeProto.attribute: array expected");
              for (t2.attribute = [], n2 = 0; n2 < e3.attribute.length; ++n2) {
                if ("object" != typeof e3.attribute[n2])
                  throw TypeError(".onnx.NodeProto.attribute: object expected");
                t2.attribute[n2] = c.onnx.AttributeProto.fromObject(e3.attribute[n2]);
              }
            }
            return null != e3.docString && (t2.docString = String(e3.docString)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), t2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), e3.input && e3.input.length) {
              n2.input = [];
              for (var r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = e3.input[r2];
            }
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = e3.output[r2];
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.opType && e3.hasOwnProperty("opType") && (n2.opType = e3.opType), e3.attribute && e3.attribute.length)
              for (n2.attribute = [], r2 = 0; r2 < e3.attribute.length; ++r2)
                n2.attribute[r2] = c.onnx.AttributeProto.toObject(e3.attribute[r2], t2);
            return null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.NodeProto";
          }, e2;
        }(), i.TrainingInfoProto = function() {
          function e2(e3) {
            if (this.initializationBinding = [], this.updateBinding = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.initialization = null, e2.prototype.algorithm = null, e2.prototype.initializationBinding = l.emptyArray, e2.prototype.updateBinding = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.initialization && Object.hasOwnProperty.call(e3, "initialization") && c.onnx.GraphProto.encode(e3.initialization, t2.uint32(10).fork()).ldelim(), null != e3.algorithm && Object.hasOwnProperty.call(e3, "algorithm") && c.onnx.GraphProto.encode(e3.algorithm, t2.uint32(18).fork()).ldelim(), null != e3.initializationBinding && e3.initializationBinding.length)
              for (var n2 = 0; n2 < e3.initializationBinding.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.initializationBinding[n2], t2.uint32(26).fork()).ldelim();
            if (null != e3.updateBinding && e3.updateBinding.length)
              for (n2 = 0; n2 < e3.updateBinding.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.updateBinding[n2], t2.uint32(34).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TrainingInfoProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.initialization = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 2:
                  r2.algorithm = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  r2.initializationBinding && r2.initializationBinding.length || (r2.initializationBinding = []), r2.initializationBinding.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 4:
                  r2.updateBinding && r2.updateBinding.length || (r2.updateBinding = []), r2.updateBinding.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.initialization && e3.hasOwnProperty("initialization") && (n2 = c.onnx.GraphProto.verify(e3.initialization)))
              return "initialization." + n2;
            if (null != e3.algorithm && e3.hasOwnProperty("algorithm") && (n2 = c.onnx.GraphProto.verify(e3.algorithm)))
              return "algorithm." + n2;
            if (null != e3.initializationBinding && e3.hasOwnProperty("initializationBinding")) {
              if (!Array.isArray(e3.initializationBinding))
                return "initializationBinding: array expected";
              for (var t2 = 0; t2 < e3.initializationBinding.length; ++t2)
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.initializationBinding[t2]))
                  return "initializationBinding." + n2;
            }
            if (null != e3.updateBinding && e3.hasOwnProperty("updateBinding")) {
              if (!Array.isArray(e3.updateBinding))
                return "updateBinding: array expected";
              for (t2 = 0; t2 < e3.updateBinding.length; ++t2) {
                var n2;
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.updateBinding[t2]))
                  return "updateBinding." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TrainingInfoProto)
              return e3;
            var t2 = new c.onnx.TrainingInfoProto();
            if (null != e3.initialization) {
              if ("object" != typeof e3.initialization)
                throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
              t2.initialization = c.onnx.GraphProto.fromObject(e3.initialization);
            }
            if (null != e3.algorithm) {
              if ("object" != typeof e3.algorithm)
                throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
              t2.algorithm = c.onnx.GraphProto.fromObject(e3.algorithm);
            }
            if (e3.initializationBinding) {
              if (!Array.isArray(e3.initializationBinding))
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
              t2.initializationBinding = [];
              for (var n2 = 0; n2 < e3.initializationBinding.length; ++n2) {
                if ("object" != typeof e3.initializationBinding[n2])
                  throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
                t2.initializationBinding[n2] = c.onnx.StringStringEntryProto.fromObject(e3.initializationBinding[n2]);
              }
            }
            if (e3.updateBinding) {
              if (!Array.isArray(e3.updateBinding))
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
              for (t2.updateBinding = [], n2 = 0; n2 < e3.updateBinding.length; ++n2) {
                if ("object" != typeof e3.updateBinding[n2])
                  throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
                t2.updateBinding[n2] = c.onnx.StringStringEntryProto.fromObject(e3.updateBinding[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.initializationBinding = [], n2.updateBinding = []), t2.defaults && (n2.initialization = null, n2.algorithm = null), null != e3.initialization && e3.hasOwnProperty("initialization") && (n2.initialization = c.onnx.GraphProto.toObject(e3.initialization, t2)), null != e3.algorithm && e3.hasOwnProperty("algorithm") && (n2.algorithm = c.onnx.GraphProto.toObject(e3.algorithm, t2)), e3.initializationBinding && e3.initializationBinding.length) {
              n2.initializationBinding = [];
              for (var r2 = 0; r2 < e3.initializationBinding.length; ++r2)
                n2.initializationBinding[r2] = c.onnx.StringStringEntryProto.toObject(e3.initializationBinding[r2], t2);
            }
            if (e3.updateBinding && e3.updateBinding.length)
              for (n2.updateBinding = [], r2 = 0; r2 < e3.updateBinding.length; ++r2)
                n2.updateBinding[r2] = c.onnx.StringStringEntryProto.toObject(e3.updateBinding[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TrainingInfoProto";
          }, e2;
        }(), i.ModelProto = function() {
          function e2(e3) {
            if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.irVersion = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.opsetImport = l.emptyArray, e2.prototype.producerName = "", e2.prototype.producerVersion = "", e2.prototype.domain = "", e2.prototype.modelVersion = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.docString = "", e2.prototype.graph = null, e2.prototype.metadataProps = l.emptyArray, e2.prototype.trainingInfo = l.emptyArray, e2.prototype.functions = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.irVersion && Object.hasOwnProperty.call(e3, "irVersion") && t2.uint32(8).int64(e3.irVersion), null != e3.producerName && Object.hasOwnProperty.call(e3, "producerName") && t2.uint32(18).string(e3.producerName), null != e3.producerVersion && Object.hasOwnProperty.call(e3, "producerVersion") && t2.uint32(26).string(e3.producerVersion), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(34).string(e3.domain), null != e3.modelVersion && Object.hasOwnProperty.call(e3, "modelVersion") && t2.uint32(40).int64(e3.modelVersion), null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(50).string(e3.docString), null != e3.graph && Object.hasOwnProperty.call(e3, "graph") && c.onnx.GraphProto.encode(e3.graph, t2.uint32(58).fork()).ldelim(), null != e3.opsetImport && e3.opsetImport.length)
              for (var n2 = 0; n2 < e3.opsetImport.length; ++n2)
                c.onnx.OperatorSetIdProto.encode(e3.opsetImport[n2], t2.uint32(66).fork()).ldelim();
            if (null != e3.metadataProps && e3.metadataProps.length)
              for (n2 = 0; n2 < e3.metadataProps.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.metadataProps[n2], t2.uint32(114).fork()).ldelim();
            if (null != e3.trainingInfo && e3.trainingInfo.length)
              for (n2 = 0; n2 < e3.trainingInfo.length; ++n2)
                c.onnx.TrainingInfoProto.encode(e3.trainingInfo[n2], t2.uint32(162).fork()).ldelim();
            if (null != e3.functions && e3.functions.length)
              for (n2 = 0; n2 < e3.functions.length; ++n2)
                c.onnx.FunctionProto.encode(e3.functions[n2], t2.uint32(202).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.ModelProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.irVersion = e3.int64();
                  break;
                case 8:
                  r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e3, e3.uint32()));
                  break;
                case 2:
                  r2.producerName = e3.string();
                  break;
                case 3:
                  r2.producerVersion = e3.string();
                  break;
                case 4:
                  r2.domain = e3.string();
                  break;
                case 5:
                  r2.modelVersion = e3.int64();
                  break;
                case 6:
                  r2.docString = e3.string();
                  break;
                case 7:
                  r2.graph = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 14:
                  r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 20:
                  r2.trainingInfo && r2.trainingInfo.length || (r2.trainingInfo = []), r2.trainingInfo.push(c.onnx.TrainingInfoProto.decode(e3, e3.uint32()));
                  break;
                case 25:
                  r2.functions && r2.functions.length || (r2.functions = []), r2.functions.push(c.onnx.FunctionProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.irVersion && e3.hasOwnProperty("irVersion") && !(l.isInteger(e3.irVersion) || e3.irVersion && l.isInteger(e3.irVersion.low) && l.isInteger(e3.irVersion.high)))
              return "irVersion: integer|Long expected";
            if (null != e3.opsetImport && e3.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(e3.opsetImport))
                return "opsetImport: array expected";
              for (var t2 = 0; t2 < e3.opsetImport.length; ++t2)
                if (n2 = c.onnx.OperatorSetIdProto.verify(e3.opsetImport[t2]))
                  return "opsetImport." + n2;
            }
            if (null != e3.producerName && e3.hasOwnProperty("producerName") && !l.isString(e3.producerName))
              return "producerName: string expected";
            if (null != e3.producerVersion && e3.hasOwnProperty("producerVersion") && !l.isString(e3.producerVersion))
              return "producerVersion: string expected";
            if (null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain))
              return "domain: string expected";
            if (null != e3.modelVersion && e3.hasOwnProperty("modelVersion") && !(l.isInteger(e3.modelVersion) || e3.modelVersion && l.isInteger(e3.modelVersion.low) && l.isInteger(e3.modelVersion.high)))
              return "modelVersion: integer|Long expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.graph && e3.hasOwnProperty("graph") && (n2 = c.onnx.GraphProto.verify(e3.graph)))
              return "graph." + n2;
            if (null != e3.metadataProps && e3.hasOwnProperty("metadataProps")) {
              if (!Array.isArray(e3.metadataProps))
                return "metadataProps: array expected";
              for (t2 = 0; t2 < e3.metadataProps.length; ++t2)
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.metadataProps[t2]))
                  return "metadataProps." + n2;
            }
            if (null != e3.trainingInfo && e3.hasOwnProperty("trainingInfo")) {
              if (!Array.isArray(e3.trainingInfo))
                return "trainingInfo: array expected";
              for (t2 = 0; t2 < e3.trainingInfo.length; ++t2)
                if (n2 = c.onnx.TrainingInfoProto.verify(e3.trainingInfo[t2]))
                  return "trainingInfo." + n2;
            }
            if (null != e3.functions && e3.hasOwnProperty("functions")) {
              if (!Array.isArray(e3.functions))
                return "functions: array expected";
              for (t2 = 0; t2 < e3.functions.length; ++t2) {
                var n2;
                if (n2 = c.onnx.FunctionProto.verify(e3.functions[t2]))
                  return "functions." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.ModelProto)
              return e3;
            var t2 = new c.onnx.ModelProto();
            if (null != e3.irVersion && (l.Long ? (t2.irVersion = l.Long.fromValue(e3.irVersion)).unsigned = false : "string" == typeof e3.irVersion ? t2.irVersion = parseInt(e3.irVersion, 10) : "number" == typeof e3.irVersion ? t2.irVersion = e3.irVersion : "object" == typeof e3.irVersion && (t2.irVersion = new l.LongBits(e3.irVersion.low >>> 0, e3.irVersion.high >>> 0).toNumber())), e3.opsetImport) {
              if (!Array.isArray(e3.opsetImport))
                throw TypeError(".onnx.ModelProto.opsetImport: array expected");
              t2.opsetImport = [];
              for (var n2 = 0; n2 < e3.opsetImport.length; ++n2) {
                if ("object" != typeof e3.opsetImport[n2])
                  throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                t2.opsetImport[n2] = c.onnx.OperatorSetIdProto.fromObject(e3.opsetImport[n2]);
              }
            }
            if (null != e3.producerName && (t2.producerName = String(e3.producerName)), null != e3.producerVersion && (t2.producerVersion = String(e3.producerVersion)), null != e3.domain && (t2.domain = String(e3.domain)), null != e3.modelVersion && (l.Long ? (t2.modelVersion = l.Long.fromValue(e3.modelVersion)).unsigned = false : "string" == typeof e3.modelVersion ? t2.modelVersion = parseInt(e3.modelVersion, 10) : "number" == typeof e3.modelVersion ? t2.modelVersion = e3.modelVersion : "object" == typeof e3.modelVersion && (t2.modelVersion = new l.LongBits(e3.modelVersion.low >>> 0, e3.modelVersion.high >>> 0).toNumber())), null != e3.docString && (t2.docString = String(e3.docString)), null != e3.graph) {
              if ("object" != typeof e3.graph)
                throw TypeError(".onnx.ModelProto.graph: object expected");
              t2.graph = c.onnx.GraphProto.fromObject(e3.graph);
            }
            if (e3.metadataProps) {
              if (!Array.isArray(e3.metadataProps))
                throw TypeError(".onnx.ModelProto.metadataProps: array expected");
              for (t2.metadataProps = [], n2 = 0; n2 < e3.metadataProps.length; ++n2) {
                if ("object" != typeof e3.metadataProps[n2])
                  throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                t2.metadataProps[n2] = c.onnx.StringStringEntryProto.fromObject(e3.metadataProps[n2]);
              }
            }
            if (e3.trainingInfo) {
              if (!Array.isArray(e3.trainingInfo))
                throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
              for (t2.trainingInfo = [], n2 = 0; n2 < e3.trainingInfo.length; ++n2) {
                if ("object" != typeof e3.trainingInfo[n2])
                  throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
                t2.trainingInfo[n2] = c.onnx.TrainingInfoProto.fromObject(e3.trainingInfo[n2]);
              }
            }
            if (e3.functions) {
              if (!Array.isArray(e3.functions))
                throw TypeError(".onnx.ModelProto.functions: array expected");
              for (t2.functions = [], n2 = 0; n2 < e3.functions.length; ++n2) {
                if ("object" != typeof e3.functions[n2])
                  throw TypeError(".onnx.ModelProto.functions: object expected");
                t2.functions[n2] = c.onnx.FunctionProto.fromObject(e3.functions[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.opsetImport = [], n2.metadataProps = [], n2.trainingInfo = [], n2.functions = []), t2.defaults) {
              if (l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.irVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.irVersion = t2.longs === String ? "0" : 0;
              n2.producerName = "", n2.producerVersion = "", n2.domain = "", l.Long ? (r2 = new l.Long(0, 0, false), n2.modelVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = t2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
            }
            if (null != e3.irVersion && e3.hasOwnProperty("irVersion") && ("number" == typeof e3.irVersion ? n2.irVersion = t2.longs === String ? String(e3.irVersion) : e3.irVersion : n2.irVersion = t2.longs === String ? l.Long.prototype.toString.call(e3.irVersion) : t2.longs === Number ? new l.LongBits(e3.irVersion.low >>> 0, e3.irVersion.high >>> 0).toNumber() : e3.irVersion), null != e3.producerName && e3.hasOwnProperty("producerName") && (n2.producerName = e3.producerName), null != e3.producerVersion && e3.hasOwnProperty("producerVersion") && (n2.producerVersion = e3.producerVersion), null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), null != e3.modelVersion && e3.hasOwnProperty("modelVersion") && ("number" == typeof e3.modelVersion ? n2.modelVersion = t2.longs === String ? String(e3.modelVersion) : e3.modelVersion : n2.modelVersion = t2.longs === String ? l.Long.prototype.toString.call(e3.modelVersion) : t2.longs === Number ? new l.LongBits(e3.modelVersion.low >>> 0, e3.modelVersion.high >>> 0).toNumber() : e3.modelVersion), null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.graph && e3.hasOwnProperty("graph") && (n2.graph = c.onnx.GraphProto.toObject(e3.graph, t2)), e3.opsetImport && e3.opsetImport.length) {
              n2.opsetImport = [];
              for (var o2 = 0; o2 < e3.opsetImport.length; ++o2)
                n2.opsetImport[o2] = c.onnx.OperatorSetIdProto.toObject(e3.opsetImport[o2], t2);
            }
            if (e3.metadataProps && e3.metadataProps.length)
              for (n2.metadataProps = [], o2 = 0; o2 < e3.metadataProps.length; ++o2)
                n2.metadataProps[o2] = c.onnx.StringStringEntryProto.toObject(e3.metadataProps[o2], t2);
            if (e3.trainingInfo && e3.trainingInfo.length)
              for (n2.trainingInfo = [], o2 = 0; o2 < e3.trainingInfo.length; ++o2)
                n2.trainingInfo[o2] = c.onnx.TrainingInfoProto.toObject(e3.trainingInfo[o2], t2);
            if (e3.functions && e3.functions.length)
              for (n2.functions = [], o2 = 0; o2 < e3.functions.length; ++o2)
                n2.functions[o2] = c.onnx.FunctionProto.toObject(e3.functions[o2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.ModelProto";
          }, e2;
        }(), i.StringStringEntryProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.StringStringEntryProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.key = e3.string();
                  break;
                case 2:
                  r2.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            return "object" != typeof e3 || null === e3 ? "object expected" : null != e3.key && e3.hasOwnProperty("key") && !l.isString(e3.key) ? "key: string expected" : null != e3.value && e3.hasOwnProperty("value") && !l.isString(e3.value) ? "value: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.StringStringEntryProto)
              return e3;
            var t2 = new c.onnx.StringStringEntryProto();
            return null != e3.key && (t2.key = String(e3.key)), null != e3.value && (t2.value = String(e3.value)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            return t2.defaults && (n2.key = "", n2.value = ""), null != e3.key && e3.hasOwnProperty("key") && (n2.key = e3.key), null != e3.value && e3.hasOwnProperty("value") && (n2.value = e3.value), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.StringStringEntryProto";
          }, e2;
        }(), i.TensorAnnotation = function() {
          function e2(e3) {
            if (this.quantParameterTensorNames = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.tensorName = "", e2.prototype.quantParameterTensorNames = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.tensorName && Object.hasOwnProperty.call(e3, "tensorName") && t2.uint32(10).string(e3.tensorName), null != e3.quantParameterTensorNames && e3.quantParameterTensorNames.length)
              for (var n2 = 0; n2 < e3.quantParameterTensorNames.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.quantParameterTensorNames[n2], t2.uint32(18).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorAnnotation(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.tensorName = e3.string();
                  break;
                case 2:
                  r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.tensorName && e3.hasOwnProperty("tensorName") && !l.isString(e3.tensorName))
              return "tensorName: string expected";
            if (null != e3.quantParameterTensorNames && e3.hasOwnProperty("quantParameterTensorNames")) {
              if (!Array.isArray(e3.quantParameterTensorNames))
                return "quantParameterTensorNames: array expected";
              for (var t2 = 0; t2 < e3.quantParameterTensorNames.length; ++t2) {
                var n2 = c.onnx.StringStringEntryProto.verify(e3.quantParameterTensorNames[t2]);
                if (n2)
                  return "quantParameterTensorNames." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorAnnotation)
              return e3;
            var t2 = new c.onnx.TensorAnnotation();
            if (null != e3.tensorName && (t2.tensorName = String(e3.tensorName)), e3.quantParameterTensorNames) {
              if (!Array.isArray(e3.quantParameterTensorNames))
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
              t2.quantParameterTensorNames = [];
              for (var n2 = 0; n2 < e3.quantParameterTensorNames.length; ++n2) {
                if ("object" != typeof e3.quantParameterTensorNames[n2])
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                t2.quantParameterTensorNames[n2] = c.onnx.StringStringEntryProto.fromObject(e3.quantParameterTensorNames[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.quantParameterTensorNames = []), t2.defaults && (n2.tensorName = ""), null != e3.tensorName && e3.hasOwnProperty("tensorName") && (n2.tensorName = e3.tensorName), e3.quantParameterTensorNames && e3.quantParameterTensorNames.length) {
              n2.quantParameterTensorNames = [];
              for (var r2 = 0; r2 < e3.quantParameterTensorNames.length; ++r2)
                n2.quantParameterTensorNames[r2] = c.onnx.StringStringEntryProto.toObject(e3.quantParameterTensorNames[r2], t2);
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorAnnotation";
          }, e2;
        }(), i.GraphProto = function() {
          function e2(e3) {
            if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.node = l.emptyArray, e2.prototype.name = "", e2.prototype.initializer = l.emptyArray, e2.prototype.sparseInitializer = l.emptyArray, e2.prototype.docString = "", e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.valueInfo = l.emptyArray, e2.prototype.quantizationAnnotation = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.node && e3.node.length)
              for (var n2 = 0; n2 < e3.node.length; ++n2)
                c.onnx.NodeProto.encode(e3.node[n2], t2.uint32(10).fork()).ldelim();
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(18).string(e3.name), null != e3.initializer && e3.initializer.length)
              for (n2 = 0; n2 < e3.initializer.length; ++n2)
                c.onnx.TensorProto.encode(e3.initializer[n2], t2.uint32(42).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(82).string(e3.docString), null != e3.input && e3.input.length)
              for (n2 = 0; n2 < e3.input.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.input[n2], t2.uint32(90).fork()).ldelim();
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.output[n2], t2.uint32(98).fork()).ldelim();
            if (null != e3.valueInfo && e3.valueInfo.length)
              for (n2 = 0; n2 < e3.valueInfo.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.valueInfo[n2], t2.uint32(106).fork()).ldelim();
            if (null != e3.quantizationAnnotation && e3.quantizationAnnotation.length)
              for (n2 = 0; n2 < e3.quantizationAnnotation.length; ++n2)
                c.onnx.TensorAnnotation.encode(e3.quantizationAnnotation[n2], t2.uint32(114).fork()).ldelim();
            if (null != e3.sparseInitializer && e3.sparseInitializer.length)
              for (n2 = 0; n2 < e3.sparseInitializer.length; ++n2)
                c.onnx.SparseTensorProto.encode(e3.sparseInitializer[n2], t2.uint32(122).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.GraphProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.node && r2.node.length || (r2.node = []), r2.node.push(c.onnx.NodeProto.decode(e3, e3.uint32()));
                  break;
                case 2:
                  r2.name = e3.string();
                  break;
                case 5:
                  r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(c.onnx.TensorProto.decode(e3, e3.uint32()));
                  break;
                case 15:
                  r2.sparseInitializer && r2.sparseInitializer.length || (r2.sparseInitializer = []), r2.sparseInitializer.push(c.onnx.SparseTensorProto.decode(e3, e3.uint32()));
                  break;
                case 10:
                  r2.docString = e3.string();
                  break;
                case 11:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 12:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 13:
                  r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 14:
                  r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.node && e3.hasOwnProperty("node")) {
              if (!Array.isArray(e3.node))
                return "node: array expected";
              for (var t2 = 0; t2 < e3.node.length; ++t2)
                if (n2 = c.onnx.NodeProto.verify(e3.node[t2]))
                  return "node." + n2;
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.initializer && e3.hasOwnProperty("initializer")) {
              if (!Array.isArray(e3.initializer))
                return "initializer: array expected";
              for (t2 = 0; t2 < e3.initializer.length; ++t2)
                if (n2 = c.onnx.TensorProto.verify(e3.initializer[t2]))
                  return "initializer." + n2;
            }
            if (null != e3.sparseInitializer && e3.hasOwnProperty("sparseInitializer")) {
              if (!Array.isArray(e3.sparseInitializer))
                return "sparseInitializer: array expected";
              for (t2 = 0; t2 < e3.sparseInitializer.length; ++t2)
                if (n2 = c.onnx.SparseTensorProto.verify(e3.sparseInitializer[t2]))
                  return "sparseInitializer." + n2;
            }
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (t2 = 0; t2 < e3.input.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.input[t2]))
                  return "input." + n2;
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.output[t2]))
                  return "output." + n2;
            }
            if (null != e3.valueInfo && e3.hasOwnProperty("valueInfo")) {
              if (!Array.isArray(e3.valueInfo))
                return "valueInfo: array expected";
              for (t2 = 0; t2 < e3.valueInfo.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.valueInfo[t2]))
                  return "valueInfo." + n2;
            }
            if (null != e3.quantizationAnnotation && e3.hasOwnProperty("quantizationAnnotation")) {
              if (!Array.isArray(e3.quantizationAnnotation))
                return "quantizationAnnotation: array expected";
              for (t2 = 0; t2 < e3.quantizationAnnotation.length; ++t2) {
                var n2;
                if (n2 = c.onnx.TensorAnnotation.verify(e3.quantizationAnnotation[t2]))
                  return "quantizationAnnotation." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.GraphProto)
              return e3;
            var t2 = new c.onnx.GraphProto();
            if (e3.node) {
              if (!Array.isArray(e3.node))
                throw TypeError(".onnx.GraphProto.node: array expected");
              t2.node = [];
              for (var n2 = 0; n2 < e3.node.length; ++n2) {
                if ("object" != typeof e3.node[n2])
                  throw TypeError(".onnx.GraphProto.node: object expected");
                t2.node[n2] = c.onnx.NodeProto.fromObject(e3.node[n2]);
              }
            }
            if (null != e3.name && (t2.name = String(e3.name)), e3.initializer) {
              if (!Array.isArray(e3.initializer))
                throw TypeError(".onnx.GraphProto.initializer: array expected");
              for (t2.initializer = [], n2 = 0; n2 < e3.initializer.length; ++n2) {
                if ("object" != typeof e3.initializer[n2])
                  throw TypeError(".onnx.GraphProto.initializer: object expected");
                t2.initializer[n2] = c.onnx.TensorProto.fromObject(e3.initializer[n2]);
              }
            }
            if (e3.sparseInitializer) {
              if (!Array.isArray(e3.sparseInitializer))
                throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
              for (t2.sparseInitializer = [], n2 = 0; n2 < e3.sparseInitializer.length; ++n2) {
                if ("object" != typeof e3.sparseInitializer[n2])
                  throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
                t2.sparseInitializer[n2] = c.onnx.SparseTensorProto.fromObject(e3.sparseInitializer[n2]);
              }
            }
            if (null != e3.docString && (t2.docString = String(e3.docString)), e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.GraphProto.input: array expected");
              for (t2.input = [], n2 = 0; n2 < e3.input.length; ++n2) {
                if ("object" != typeof e3.input[n2])
                  throw TypeError(".onnx.GraphProto.input: object expected");
                t2.input[n2] = c.onnx.ValueInfoProto.fromObject(e3.input[n2]);
              }
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.GraphProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2) {
                if ("object" != typeof e3.output[n2])
                  throw TypeError(".onnx.GraphProto.output: object expected");
                t2.output[n2] = c.onnx.ValueInfoProto.fromObject(e3.output[n2]);
              }
            }
            if (e3.valueInfo) {
              if (!Array.isArray(e3.valueInfo))
                throw TypeError(".onnx.GraphProto.valueInfo: array expected");
              for (t2.valueInfo = [], n2 = 0; n2 < e3.valueInfo.length; ++n2) {
                if ("object" != typeof e3.valueInfo[n2])
                  throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                t2.valueInfo[n2] = c.onnx.ValueInfoProto.fromObject(e3.valueInfo[n2]);
              }
            }
            if (e3.quantizationAnnotation) {
              if (!Array.isArray(e3.quantizationAnnotation))
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
              for (t2.quantizationAnnotation = [], n2 = 0; n2 < e3.quantizationAnnotation.length; ++n2) {
                if ("object" != typeof e3.quantizationAnnotation[n2])
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                t2.quantizationAnnotation[n2] = c.onnx.TensorAnnotation.fromObject(e3.quantizationAnnotation[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = [], n2.sparseInitializer = []), t2.defaults && (n2.name = "", n2.docString = ""), e3.node && e3.node.length) {
              n2.node = [];
              for (var r2 = 0; r2 < e3.node.length; ++r2)
                n2.node[r2] = c.onnx.NodeProto.toObject(e3.node[r2], t2);
            }
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), e3.initializer && e3.initializer.length)
              for (n2.initializer = [], r2 = 0; r2 < e3.initializer.length; ++r2)
                n2.initializer[r2] = c.onnx.TensorProto.toObject(e3.initializer[r2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.input && e3.input.length)
              for (n2.input = [], r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = c.onnx.ValueInfoProto.toObject(e3.input[r2], t2);
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = c.onnx.ValueInfoProto.toObject(e3.output[r2], t2);
            if (e3.valueInfo && e3.valueInfo.length)
              for (n2.valueInfo = [], r2 = 0; r2 < e3.valueInfo.length; ++r2)
                n2.valueInfo[r2] = c.onnx.ValueInfoProto.toObject(e3.valueInfo[r2], t2);
            if (e3.quantizationAnnotation && e3.quantizationAnnotation.length)
              for (n2.quantizationAnnotation = [], r2 = 0; r2 < e3.quantizationAnnotation.length; ++r2)
                n2.quantizationAnnotation[r2] = c.onnx.TensorAnnotation.toObject(e3.quantizationAnnotation[r2], t2);
            if (e3.sparseInitializer && e3.sparseInitializer.length)
              for (n2.sparseInitializer = [], r2 = 0; r2 < e3.sparseInitializer.length; ++r2)
                n2.sparseInitializer[r2] = c.onnx.SparseTensorProto.toObject(e3.sparseInitializer[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.GraphProto";
          }, e2;
        }(), i.TensorProto = function() {
          function e2(e3) {
            if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.dims = l.emptyArray, e2.prototype.dataType = 0, e2.prototype.segment = null, e2.prototype.floatData = l.emptyArray, e2.prototype.int32Data = l.emptyArray, e2.prototype.stringData = l.emptyArray, e2.prototype.int64Data = l.emptyArray, e2.prototype.name = "", e2.prototype.docString = "", e2.prototype.rawData = l.newBuffer([]), e2.prototype.externalData = l.emptyArray, e2.prototype.dataLocation = 0, e2.prototype.doubleData = l.emptyArray, e2.prototype.uint64Data = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.dims && e3.dims.length) {
              t2.uint32(10).fork();
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                t2.int64(e3.dims[n2]);
              t2.ldelim();
            }
            if (null != e3.dataType && Object.hasOwnProperty.call(e3, "dataType") && t2.uint32(16).int32(e3.dataType), null != e3.segment && Object.hasOwnProperty.call(e3, "segment") && c.onnx.TensorProto.Segment.encode(e3.segment, t2.uint32(26).fork()).ldelim(), null != e3.floatData && e3.floatData.length) {
              for (t2.uint32(34).fork(), n2 = 0; n2 < e3.floatData.length; ++n2)
                t2.float(e3.floatData[n2]);
              t2.ldelim();
            }
            if (null != e3.int32Data && e3.int32Data.length) {
              for (t2.uint32(42).fork(), n2 = 0; n2 < e3.int32Data.length; ++n2)
                t2.int32(e3.int32Data[n2]);
              t2.ldelim();
            }
            if (null != e3.stringData && e3.stringData.length)
              for (n2 = 0; n2 < e3.stringData.length; ++n2)
                t2.uint32(50).bytes(e3.stringData[n2]);
            if (null != e3.int64Data && e3.int64Data.length) {
              for (t2.uint32(58).fork(), n2 = 0; n2 < e3.int64Data.length; ++n2)
                t2.int64(e3.int64Data[n2]);
              t2.ldelim();
            }
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(66).string(e3.name), null != e3.rawData && Object.hasOwnProperty.call(e3, "rawData") && t2.uint32(74).bytes(e3.rawData), null != e3.doubleData && e3.doubleData.length) {
              for (t2.uint32(82).fork(), n2 = 0; n2 < e3.doubleData.length; ++n2)
                t2.double(e3.doubleData[n2]);
              t2.ldelim();
            }
            if (null != e3.uint64Data && e3.uint64Data.length) {
              for (t2.uint32(90).fork(), n2 = 0; n2 < e3.uint64Data.length; ++n2)
                t2.uint64(e3.uint64Data[n2]);
              t2.ldelim();
            }
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(98).string(e3.docString), null != e3.externalData && e3.externalData.length)
              for (n2 = 0; n2 < e3.externalData.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.externalData[n2], t2.uint32(106).fork()).ldelim();
            return null != e3.dataLocation && Object.hasOwnProperty.call(e3, "dataLocation") && t2.uint32(112).int32(e3.dataLocation), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & o2))
                    for (var i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.dims.push(e3.int64());
                  else
                    r2.dims.push(e3.int64());
                  break;
                case 2:
                  r2.dataType = e3.int32();
                  break;
                case 3:
                  r2.segment = c.onnx.TensorProto.Segment.decode(e3, e3.uint32());
                  break;
                case 4:
                  if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.floatData.push(e3.float());
                  else
                    r2.floatData.push(e3.float());
                  break;
                case 5:
                  if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.int32Data.push(e3.int32());
                  else
                    r2.int32Data.push(e3.int32());
                  break;
                case 6:
                  r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(e3.bytes());
                  break;
                case 7:
                  if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.int64Data.push(e3.int64());
                  else
                    r2.int64Data.push(e3.int64());
                  break;
                case 8:
                  r2.name = e3.string();
                  break;
                case 12:
                  r2.docString = e3.string();
                  break;
                case 9:
                  r2.rawData = e3.bytes();
                  break;
                case 13:
                  r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 14:
                  r2.dataLocation = e3.int32();
                  break;
                case 10:
                  if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.doubleData.push(e3.double());
                  else
                    r2.doubleData.push(e3.double());
                  break;
                case 11:
                  if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.uint64Data.push(e3.uint64());
                  else
                    r2.uint64Data.push(e3.uint64());
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.dims && e3.hasOwnProperty("dims")) {
              if (!Array.isArray(e3.dims))
                return "dims: array expected";
              for (var t2 = 0; t2 < e3.dims.length; ++t2)
                if (!(l.isInteger(e3.dims[t2]) || e3.dims[t2] && l.isInteger(e3.dims[t2].low) && l.isInteger(e3.dims[t2].high)))
                  return "dims: integer|Long[] expected";
            }
            if (null != e3.dataType && e3.hasOwnProperty("dataType") && !l.isInteger(e3.dataType))
              return "dataType: integer expected";
            if (null != e3.segment && e3.hasOwnProperty("segment") && (n2 = c.onnx.TensorProto.Segment.verify(e3.segment)))
              return "segment." + n2;
            if (null != e3.floatData && e3.hasOwnProperty("floatData")) {
              if (!Array.isArray(e3.floatData))
                return "floatData: array expected";
              for (t2 = 0; t2 < e3.floatData.length; ++t2)
                if ("number" != typeof e3.floatData[t2])
                  return "floatData: number[] expected";
            }
            if (null != e3.int32Data && e3.hasOwnProperty("int32Data")) {
              if (!Array.isArray(e3.int32Data))
                return "int32Data: array expected";
              for (t2 = 0; t2 < e3.int32Data.length; ++t2)
                if (!l.isInteger(e3.int32Data[t2]))
                  return "int32Data: integer[] expected";
            }
            if (null != e3.stringData && e3.hasOwnProperty("stringData")) {
              if (!Array.isArray(e3.stringData))
                return "stringData: array expected";
              for (t2 = 0; t2 < e3.stringData.length; ++t2)
                if (!(e3.stringData[t2] && "number" == typeof e3.stringData[t2].length || l.isString(e3.stringData[t2])))
                  return "stringData: buffer[] expected";
            }
            if (null != e3.int64Data && e3.hasOwnProperty("int64Data")) {
              if (!Array.isArray(e3.int64Data))
                return "int64Data: array expected";
              for (t2 = 0; t2 < e3.int64Data.length; ++t2)
                if (!(l.isInteger(e3.int64Data[t2]) || e3.int64Data[t2] && l.isInteger(e3.int64Data[t2].low) && l.isInteger(e3.int64Data[t2].high)))
                  return "int64Data: integer|Long[] expected";
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.rawData && e3.hasOwnProperty("rawData") && !(e3.rawData && "number" == typeof e3.rawData.length || l.isString(e3.rawData)))
              return "rawData: buffer expected";
            if (null != e3.externalData && e3.hasOwnProperty("externalData")) {
              if (!Array.isArray(e3.externalData))
                return "externalData: array expected";
              for (t2 = 0; t2 < e3.externalData.length; ++t2) {
                var n2;
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.externalData[t2]))
                  return "externalData." + n2;
              }
            }
            if (null != e3.dataLocation && e3.hasOwnProperty("dataLocation"))
              switch (e3.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
              }
            if (null != e3.doubleData && e3.hasOwnProperty("doubleData")) {
              if (!Array.isArray(e3.doubleData))
                return "doubleData: array expected";
              for (t2 = 0; t2 < e3.doubleData.length; ++t2)
                if ("number" != typeof e3.doubleData[t2])
                  return "doubleData: number[] expected";
            }
            if (null != e3.uint64Data && e3.hasOwnProperty("uint64Data")) {
              if (!Array.isArray(e3.uint64Data))
                return "uint64Data: array expected";
              for (t2 = 0; t2 < e3.uint64Data.length; ++t2)
                if (!(l.isInteger(e3.uint64Data[t2]) || e3.uint64Data[t2] && l.isInteger(e3.uint64Data[t2].low) && l.isInteger(e3.uint64Data[t2].high)))
                  return "uint64Data: integer|Long[] expected";
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorProto)
              return e3;
            var t2 = new c.onnx.TensorProto();
            if (e3.dims) {
              if (!Array.isArray(e3.dims))
                throw TypeError(".onnx.TensorProto.dims: array expected");
              t2.dims = [];
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                l.Long ? (t2.dims[n2] = l.Long.fromValue(e3.dims[n2])).unsigned = false : "string" == typeof e3.dims[n2] ? t2.dims[n2] = parseInt(e3.dims[n2], 10) : "number" == typeof e3.dims[n2] ? t2.dims[n2] = e3.dims[n2] : "object" == typeof e3.dims[n2] && (t2.dims[n2] = new l.LongBits(e3.dims[n2].low >>> 0, e3.dims[n2].high >>> 0).toNumber());
            }
            if (null != e3.dataType && (t2.dataType = 0 | e3.dataType), null != e3.segment) {
              if ("object" != typeof e3.segment)
                throw TypeError(".onnx.TensorProto.segment: object expected");
              t2.segment = c.onnx.TensorProto.Segment.fromObject(e3.segment);
            }
            if (e3.floatData) {
              if (!Array.isArray(e3.floatData))
                throw TypeError(".onnx.TensorProto.floatData: array expected");
              for (t2.floatData = [], n2 = 0; n2 < e3.floatData.length; ++n2)
                t2.floatData[n2] = Number(e3.floatData[n2]);
            }
            if (e3.int32Data) {
              if (!Array.isArray(e3.int32Data))
                throw TypeError(".onnx.TensorProto.int32Data: array expected");
              for (t2.int32Data = [], n2 = 0; n2 < e3.int32Data.length; ++n2)
                t2.int32Data[n2] = 0 | e3.int32Data[n2];
            }
            if (e3.stringData) {
              if (!Array.isArray(e3.stringData))
                throw TypeError(".onnx.TensorProto.stringData: array expected");
              for (t2.stringData = [], n2 = 0; n2 < e3.stringData.length; ++n2)
                "string" == typeof e3.stringData[n2] ? l.base64.decode(e3.stringData[n2], t2.stringData[n2] = l.newBuffer(l.base64.length(e3.stringData[n2])), 0) : e3.stringData[n2].length >= 0 && (t2.stringData[n2] = e3.stringData[n2]);
            }
            if (e3.int64Data) {
              if (!Array.isArray(e3.int64Data))
                throw TypeError(".onnx.TensorProto.int64Data: array expected");
              for (t2.int64Data = [], n2 = 0; n2 < e3.int64Data.length; ++n2)
                l.Long ? (t2.int64Data[n2] = l.Long.fromValue(e3.int64Data[n2])).unsigned = false : "string" == typeof e3.int64Data[n2] ? t2.int64Data[n2] = parseInt(e3.int64Data[n2], 10) : "number" == typeof e3.int64Data[n2] ? t2.int64Data[n2] = e3.int64Data[n2] : "object" == typeof e3.int64Data[n2] && (t2.int64Data[n2] = new l.LongBits(e3.int64Data[n2].low >>> 0, e3.int64Data[n2].high >>> 0).toNumber());
            }
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.docString && (t2.docString = String(e3.docString)), null != e3.rawData && ("string" == typeof e3.rawData ? l.base64.decode(e3.rawData, t2.rawData = l.newBuffer(l.base64.length(e3.rawData)), 0) : e3.rawData.length >= 0 && (t2.rawData = e3.rawData)), e3.externalData) {
              if (!Array.isArray(e3.externalData))
                throw TypeError(".onnx.TensorProto.externalData: array expected");
              for (t2.externalData = [], n2 = 0; n2 < e3.externalData.length; ++n2) {
                if ("object" != typeof e3.externalData[n2])
                  throw TypeError(".onnx.TensorProto.externalData: object expected");
                t2.externalData[n2] = c.onnx.StringStringEntryProto.fromObject(e3.externalData[n2]);
              }
            }
            switch (e3.dataLocation) {
              default:
                if ("number" == typeof e3.dataLocation) {
                  t2.dataLocation = e3.dataLocation;
                  break;
                }
                break;
              case "DEFAULT":
              case 0:
                t2.dataLocation = 0;
                break;
              case "EXTERNAL":
              case 1:
                t2.dataLocation = 1;
            }
            if (e3.doubleData) {
              if (!Array.isArray(e3.doubleData))
                throw TypeError(".onnx.TensorProto.doubleData: array expected");
              for (t2.doubleData = [], n2 = 0; n2 < e3.doubleData.length; ++n2)
                t2.doubleData[n2] = Number(e3.doubleData[n2]);
            }
            if (e3.uint64Data) {
              if (!Array.isArray(e3.uint64Data))
                throw TypeError(".onnx.TensorProto.uint64Data: array expected");
              for (t2.uint64Data = [], n2 = 0; n2 < e3.uint64Data.length; ++n2)
                l.Long ? (t2.uint64Data[n2] = l.Long.fromValue(e3.uint64Data[n2])).unsigned = true : "string" == typeof e3.uint64Data[n2] ? t2.uint64Data[n2] = parseInt(e3.uint64Data[n2], 10) : "number" == typeof e3.uint64Data[n2] ? t2.uint64Data[n2] = e3.uint64Data[n2] : "object" == typeof e3.uint64Data[n2] && (t2.uint64Data[n2] = new l.LongBits(e3.uint64Data[n2].low >>> 0, e3.uint64Data[n2].high >>> 0).toNumber(true));
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), t2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", t2.bytes === String ? n2.rawData = "" : (n2.rawData = [], t2.bytes !== Array && (n2.rawData = l.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = t2.enums === String ? "DEFAULT" : 0), e3.dims && e3.dims.length) {
              n2.dims = [];
              for (var r2 = 0; r2 < e3.dims.length; ++r2)
                "number" == typeof e3.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e3.dims[r2]) : e3.dims[r2] : n2.dims[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.dims[r2]) : t2.longs === Number ? new l.LongBits(e3.dims[r2].low >>> 0, e3.dims[r2].high >>> 0).toNumber() : e3.dims[r2];
            }
            if (null != e3.dataType && e3.hasOwnProperty("dataType") && (n2.dataType = e3.dataType), null != e3.segment && e3.hasOwnProperty("segment") && (n2.segment = c.onnx.TensorProto.Segment.toObject(e3.segment, t2)), e3.floatData && e3.floatData.length)
              for (n2.floatData = [], r2 = 0; r2 < e3.floatData.length; ++r2)
                n2.floatData[r2] = t2.json && !isFinite(e3.floatData[r2]) ? String(e3.floatData[r2]) : e3.floatData[r2];
            if (e3.int32Data && e3.int32Data.length)
              for (n2.int32Data = [], r2 = 0; r2 < e3.int32Data.length; ++r2)
                n2.int32Data[r2] = e3.int32Data[r2];
            if (e3.stringData && e3.stringData.length)
              for (n2.stringData = [], r2 = 0; r2 < e3.stringData.length; ++r2)
                n2.stringData[r2] = t2.bytes === String ? l.base64.encode(e3.stringData[r2], 0, e3.stringData[r2].length) : t2.bytes === Array ? Array.prototype.slice.call(e3.stringData[r2]) : e3.stringData[r2];
            if (e3.int64Data && e3.int64Data.length)
              for (n2.int64Data = [], r2 = 0; r2 < e3.int64Data.length; ++r2)
                "number" == typeof e3.int64Data[r2] ? n2.int64Data[r2] = t2.longs === String ? String(e3.int64Data[r2]) : e3.int64Data[r2] : n2.int64Data[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.int64Data[r2]) : t2.longs === Number ? new l.LongBits(e3.int64Data[r2].low >>> 0, e3.int64Data[r2].high >>> 0).toNumber() : e3.int64Data[r2];
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.rawData && e3.hasOwnProperty("rawData") && (n2.rawData = t2.bytes === String ? l.base64.encode(e3.rawData, 0, e3.rawData.length) : t2.bytes === Array ? Array.prototype.slice.call(e3.rawData) : e3.rawData), e3.doubleData && e3.doubleData.length)
              for (n2.doubleData = [], r2 = 0; r2 < e3.doubleData.length; ++r2)
                n2.doubleData[r2] = t2.json && !isFinite(e3.doubleData[r2]) ? String(e3.doubleData[r2]) : e3.doubleData[r2];
            if (e3.uint64Data && e3.uint64Data.length)
              for (n2.uint64Data = [], r2 = 0; r2 < e3.uint64Data.length; ++r2)
                "number" == typeof e3.uint64Data[r2] ? n2.uint64Data[r2] = t2.longs === String ? String(e3.uint64Data[r2]) : e3.uint64Data[r2] : n2.uint64Data[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.uint64Data[r2]) : t2.longs === Number ? new l.LongBits(e3.uint64Data[r2].low >>> 0, e3.uint64Data[r2].high >>> 0).toNumber(true) : e3.uint64Data[r2];
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.externalData && e3.externalData.length)
              for (n2.externalData = [], r2 = 0; r2 < e3.externalData.length; ++r2)
                n2.externalData[r2] = c.onnx.StringStringEntryProto.toObject(e3.externalData[r2], t2);
            return null != e3.dataLocation && e3.hasOwnProperty("dataLocation") && (n2.dataLocation = t2.enums === String ? void 0 === c.onnx.TensorProto.DataLocation[e3.dataLocation] ? e3.dataLocation : c.onnx.TensorProto.DataLocation[e3.dataLocation] : e3.dataLocation), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorProto";
          }, e2.DataType = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "UNDEFINED"] = 0, t2[e3[1] = "FLOAT"] = 1, t2[e3[2] = "UINT8"] = 2, t2[e3[3] = "INT8"] = 3, t2[e3[4] = "UINT16"] = 4, t2[e3[5] = "INT16"] = 5, t2[e3[6] = "INT32"] = 6, t2[e3[7] = "INT64"] = 7, t2[e3[8] = "STRING"] = 8, t2[e3[9] = "BOOL"] = 9, t2[e3[10] = "FLOAT16"] = 10, t2[e3[11] = "DOUBLE"] = 11, t2[e3[12] = "UINT32"] = 12, t2[e3[13] = "UINT64"] = 13, t2[e3[14] = "COMPLEX64"] = 14, t2[e3[15] = "COMPLEX128"] = 15, t2[e3[16] = "BFLOAT16"] = 16, t2[e3[17] = "FLOAT8E4M3FN"] = 17, t2[e3[18] = "FLOAT8E4M3FNUZ"] = 18, t2[e3[19] = "FLOAT8E5M2"] = 19, t2[e3[20] = "FLOAT8E5M2FNUZ"] = 20, t2;
          }(), e2.Segment = function() {
            function e3(e4) {
              if (e4)
                for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2)
                  null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.begin = l.Long ? l.Long.fromBits(0, 0, false) : 0, e3.prototype.end = l.Long ? l.Long.fromBits(0, 0, false) : 0, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              return t2 || (t2 = u.create()), null != e4.begin && Object.hasOwnProperty.call(e4, "begin") && t2.uint32(8).int64(e4.begin), null != e4.end && Object.hasOwnProperty.call(e4, "end") && t2.uint32(16).int64(e4.end), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new c.onnx.TensorProto.Segment(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.begin = e4.int64();
                    break;
                  case 2:
                    r2.end = e4.int64();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              return "object" != typeof e4 || null === e4 ? "object expected" : null != e4.begin && e4.hasOwnProperty("begin") && !(l.isInteger(e4.begin) || e4.begin && l.isInteger(e4.begin.low) && l.isInteger(e4.begin.high)) ? "begin: integer|Long expected" : null != e4.end && e4.hasOwnProperty("end") && !(l.isInteger(e4.end) || e4.end && l.isInteger(e4.end.low) && l.isInteger(e4.end.high)) ? "end: integer|Long expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TensorProto.Segment)
                return e4;
              var t2 = new c.onnx.TensorProto.Segment();
              return null != e4.begin && (l.Long ? (t2.begin = l.Long.fromValue(e4.begin)).unsigned = false : "string" == typeof e4.begin ? t2.begin = parseInt(e4.begin, 10) : "number" == typeof e4.begin ? t2.begin = e4.begin : "object" == typeof e4.begin && (t2.begin = new l.LongBits(e4.begin.low >>> 0, e4.begin.high >>> 0).toNumber())), null != e4.end && (l.Long ? (t2.end = l.Long.fromValue(e4.end)).unsigned = false : "string" == typeof e4.end ? t2.end = parseInt(e4.end, 10) : "number" == typeof e4.end ? t2.end = e4.end : "object" == typeof e4.end && (t2.end = new l.LongBits(e4.end.low >>> 0, e4.end.high >>> 0).toNumber())), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if (t2.defaults) {
                if (l.Long) {
                  var r2 = new l.Long(0, 0, false);
                  n2.begin = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
                } else
                  n2.begin = t2.longs === String ? "0" : 0;
                l.Long ? (r2 = new l.Long(0, 0, false), n2.end = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.end = t2.longs === String ? "0" : 0;
              }
              return null != e4.begin && e4.hasOwnProperty("begin") && ("number" == typeof e4.begin ? n2.begin = t2.longs === String ? String(e4.begin) : e4.begin : n2.begin = t2.longs === String ? l.Long.prototype.toString.call(e4.begin) : t2.longs === Number ? new l.LongBits(e4.begin.low >>> 0, e4.begin.high >>> 0).toNumber() : e4.begin), null != e4.end && e4.hasOwnProperty("end") && ("number" == typeof e4.end ? n2.end = t2.longs === String ? String(e4.end) : e4.end : n2.end = t2.longs === String ? l.Long.prototype.toString.call(e4.end) : t2.longs === Number ? new l.LongBits(e4.end.low >>> 0, e4.end.high >>> 0).toNumber() : e4.end), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorProto.Segment";
            }, e3;
          }(), e2.DataLocation = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "DEFAULT"] = 0, t2[e3[1] = "EXTERNAL"] = 1, t2;
          }(), e2;
        }(), i.SparseTensorProto = function() {
          function e2(e3) {
            if (this.dims = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.values = null, e2.prototype.indices = null, e2.prototype.dims = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.values && Object.hasOwnProperty.call(e3, "values") && c.onnx.TensorProto.encode(e3.values, t2.uint32(10).fork()).ldelim(), null != e3.indices && Object.hasOwnProperty.call(e3, "indices") && c.onnx.TensorProto.encode(e3.indices, t2.uint32(18).fork()).ldelim(), null != e3.dims && e3.dims.length) {
              t2.uint32(26).fork();
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                t2.int64(e3.dims[n2]);
              t2.ldelim();
            }
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.SparseTensorProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.values = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 2:
                  r2.indices = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & o2))
                    for (var i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.dims.push(e3.int64());
                  else
                    r2.dims.push(e3.int64());
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            var t2;
            if (null != e3.values && e3.hasOwnProperty("values") && (t2 = c.onnx.TensorProto.verify(e3.values)))
              return "values." + t2;
            if (null != e3.indices && e3.hasOwnProperty("indices") && (t2 = c.onnx.TensorProto.verify(e3.indices)))
              return "indices." + t2;
            if (null != e3.dims && e3.hasOwnProperty("dims")) {
              if (!Array.isArray(e3.dims))
                return "dims: array expected";
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                if (!(l.isInteger(e3.dims[n2]) || e3.dims[n2] && l.isInteger(e3.dims[n2].low) && l.isInteger(e3.dims[n2].high)))
                  return "dims: integer|Long[] expected";
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.SparseTensorProto)
              return e3;
            var t2 = new c.onnx.SparseTensorProto();
            if (null != e3.values) {
              if ("object" != typeof e3.values)
                throw TypeError(".onnx.SparseTensorProto.values: object expected");
              t2.values = c.onnx.TensorProto.fromObject(e3.values);
            }
            if (null != e3.indices) {
              if ("object" != typeof e3.indices)
                throw TypeError(".onnx.SparseTensorProto.indices: object expected");
              t2.indices = c.onnx.TensorProto.fromObject(e3.indices);
            }
            if (e3.dims) {
              if (!Array.isArray(e3.dims))
                throw TypeError(".onnx.SparseTensorProto.dims: array expected");
              t2.dims = [];
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                l.Long ? (t2.dims[n2] = l.Long.fromValue(e3.dims[n2])).unsigned = false : "string" == typeof e3.dims[n2] ? t2.dims[n2] = parseInt(e3.dims[n2], 10) : "number" == typeof e3.dims[n2] ? t2.dims[n2] = e3.dims[n2] : "object" == typeof e3.dims[n2] && (t2.dims[n2] = new l.LongBits(e3.dims[n2].low >>> 0, e3.dims[n2].high >>> 0).toNumber());
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dims = []), t2.defaults && (n2.values = null, n2.indices = null), null != e3.values && e3.hasOwnProperty("values") && (n2.values = c.onnx.TensorProto.toObject(e3.values, t2)), null != e3.indices && e3.hasOwnProperty("indices") && (n2.indices = c.onnx.TensorProto.toObject(e3.indices, t2)), e3.dims && e3.dims.length) {
              n2.dims = [];
              for (var r2 = 0; r2 < e3.dims.length; ++r2)
                "number" == typeof e3.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e3.dims[r2]) : e3.dims[r2] : n2.dims[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.dims[r2]) : t2.longs === Number ? new l.LongBits(e3.dims[r2].low >>> 0, e3.dims[r2].high >>> 0).toNumber() : e3.dims[r2];
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.SparseTensorProto";
          }, e2;
        }(), i.TensorShapeProto = function() {
          function e2(e3) {
            if (this.dim = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.dim = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.dim && e3.dim.length)
              for (var n2 = 0; n2 < e3.dim.length; ++n2)
                c.onnx.TensorShapeProto.Dimension.encode(e3.dim[n2], t2.uint32(10).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorShapeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              o2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e3, e3.uint32()))) : e3.skipType(7 & o2);
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.dim && e3.hasOwnProperty("dim")) {
              if (!Array.isArray(e3.dim))
                return "dim: array expected";
              for (var t2 = 0; t2 < e3.dim.length; ++t2) {
                var n2 = c.onnx.TensorShapeProto.Dimension.verify(e3.dim[t2]);
                if (n2)
                  return "dim." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorShapeProto)
              return e3;
            var t2 = new c.onnx.TensorShapeProto();
            if (e3.dim) {
              if (!Array.isArray(e3.dim))
                throw TypeError(".onnx.TensorShapeProto.dim: array expected");
              t2.dim = [];
              for (var n2 = 0; n2 < e3.dim.length; ++n2) {
                if ("object" != typeof e3.dim[n2])
                  throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                t2.dim[n2] = c.onnx.TensorShapeProto.Dimension.fromObject(e3.dim[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dim = []), e3.dim && e3.dim.length) {
              n2.dim = [];
              for (var r2 = 0; r2 < e3.dim.length; ++r2)
                n2.dim[r2] = c.onnx.TensorShapeProto.Dimension.toObject(e3.dim[r2], t2);
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorShapeProto";
          }, e2.Dimension = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            var t2;
            return e3.prototype.dimValue = null, e3.prototype.dimParam = null, e3.prototype.denotation = "", Object.defineProperty(e3.prototype, "value", { get: l.oneOfGetter(t2 = ["dimValue", "dimParam"]), set: l.oneOfSetter(t2) }), e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.dimValue && Object.hasOwnProperty.call(e4, "dimValue") && t3.uint32(8).int64(e4.dimValue), null != e4.dimParam && Object.hasOwnProperty.call(e4, "dimParam") && t3.uint32(18).string(e4.dimParam), null != e4.denotation && Object.hasOwnProperty.call(e4, "denotation") && t3.uint32(26).string(e4.denotation), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TensorShapeProto.Dimension(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.dimValue = e4.int64();
                    break;
                  case 2:
                    r2.dimParam = e4.string();
                    break;
                  case 3:
                    r2.denotation = e4.string();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              var t3 = {};
              if (null != e4.dimValue && e4.hasOwnProperty("dimValue") && (t3.value = 1, !(l.isInteger(e4.dimValue) || e4.dimValue && l.isInteger(e4.dimValue.low) && l.isInteger(e4.dimValue.high))))
                return "dimValue: integer|Long expected";
              if (null != e4.dimParam && e4.hasOwnProperty("dimParam")) {
                if (1 === t3.value)
                  return "value: multiple values";
                if (t3.value = 1, !l.isString(e4.dimParam))
                  return "dimParam: string expected";
              }
              return null != e4.denotation && e4.hasOwnProperty("denotation") && !l.isString(e4.denotation) ? "denotation: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TensorShapeProto.Dimension)
                return e4;
              var t3 = new c.onnx.TensorShapeProto.Dimension();
              return null != e4.dimValue && (l.Long ? (t3.dimValue = l.Long.fromValue(e4.dimValue)).unsigned = false : "string" == typeof e4.dimValue ? t3.dimValue = parseInt(e4.dimValue, 10) : "number" == typeof e4.dimValue ? t3.dimValue = e4.dimValue : "object" == typeof e4.dimValue && (t3.dimValue = new l.LongBits(e4.dimValue.low >>> 0, e4.dimValue.high >>> 0).toNumber())), null != e4.dimParam && (t3.dimParam = String(e4.dimParam)), null != e4.denotation && (t3.denotation = String(e4.denotation)), t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.denotation = ""), null != e4.dimValue && e4.hasOwnProperty("dimValue") && ("number" == typeof e4.dimValue ? n2.dimValue = t3.longs === String ? String(e4.dimValue) : e4.dimValue : n2.dimValue = t3.longs === String ? l.Long.prototype.toString.call(e4.dimValue) : t3.longs === Number ? new l.LongBits(e4.dimValue.low >>> 0, e4.dimValue.high >>> 0).toNumber() : e4.dimValue, t3.oneofs && (n2.value = "dimValue")), null != e4.dimParam && e4.hasOwnProperty("dimParam") && (n2.dimParam = e4.dimParam, t3.oneofs && (n2.value = "dimParam")), null != e4.denotation && e4.hasOwnProperty("denotation") && (n2.denotation = e4.denotation), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorShapeProto.Dimension";
            }, e3;
          }(), e2;
        }(), i.TypeProto = function() {
          function e2(e3) {
            if (e3)
              for (var t3 = Object.keys(e3), n2 = 0; n2 < t3.length; ++n2)
                null != e3[t3[n2]] && (this[t3[n2]] = e3[t3[n2]]);
          }
          var t2;
          return e2.prototype.tensorType = null, e2.prototype.sequenceType = null, e2.prototype.mapType = null, e2.prototype.optionalType = null, e2.prototype.sparseTensorType = null, e2.prototype.denotation = "", Object.defineProperty(e2.prototype, "value", { get: l.oneOfGetter(t2 = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]), set: l.oneOfSetter(t2) }), e2.create = function(t3) {
            return new e2(t3);
          }, e2.encode = function(e3, t3) {
            return t3 || (t3 = u.create()), null != e3.tensorType && Object.hasOwnProperty.call(e3, "tensorType") && c.onnx.TypeProto.Tensor.encode(e3.tensorType, t3.uint32(10).fork()).ldelim(), null != e3.sequenceType && Object.hasOwnProperty.call(e3, "sequenceType") && c.onnx.TypeProto.Sequence.encode(e3.sequenceType, t3.uint32(34).fork()).ldelim(), null != e3.mapType && Object.hasOwnProperty.call(e3, "mapType") && c.onnx.TypeProto.Map.encode(e3.mapType, t3.uint32(42).fork()).ldelim(), null != e3.denotation && Object.hasOwnProperty.call(e3, "denotation") && t3.uint32(50).string(e3.denotation), null != e3.sparseTensorType && Object.hasOwnProperty.call(e3, "sparseTensorType") && c.onnx.TypeProto.SparseTensor.encode(e3.sparseTensorType, t3.uint32(66).fork()).ldelim(), null != e3.optionalType && Object.hasOwnProperty.call(e3, "optionalType") && c.onnx.TypeProto.Optional.encode(e3.optionalType, t3.uint32(74).fork()).ldelim(), t3;
          }, e2.encodeDelimited = function(e3, t3) {
            return this.encode(e3, t3).ldelim();
          }, e2.decode = function(e3, t3) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t3 ? e3.len : e3.pos + t3, r2 = new c.onnx.TypeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.tensorType = c.onnx.TypeProto.Tensor.decode(e3, e3.uint32());
                  break;
                case 4:
                  r2.sequenceType = c.onnx.TypeProto.Sequence.decode(e3, e3.uint32());
                  break;
                case 5:
                  r2.mapType = c.onnx.TypeProto.Map.decode(e3, e3.uint32());
                  break;
                case 9:
                  r2.optionalType = c.onnx.TypeProto.Optional.decode(e3, e3.uint32());
                  break;
                case 8:
                  r2.sparseTensorType = c.onnx.TypeProto.SparseTensor.decode(e3, e3.uint32());
                  break;
                case 6:
                  r2.denotation = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            var t3 = {};
            if (null != e3.tensorType && e3.hasOwnProperty("tensorType") && (t3.value = 1, n2 = c.onnx.TypeProto.Tensor.verify(e3.tensorType)))
              return "tensorType." + n2;
            if (null != e3.sequenceType && e3.hasOwnProperty("sequenceType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Sequence.verify(e3.sequenceType))
                return "sequenceType." + n2;
            }
            if (null != e3.mapType && e3.hasOwnProperty("mapType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Map.verify(e3.mapType))
                return "mapType." + n2;
            }
            if (null != e3.optionalType && e3.hasOwnProperty("optionalType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Optional.verify(e3.optionalType))
                return "optionalType." + n2;
            }
            if (null != e3.sparseTensorType && e3.hasOwnProperty("sparseTensorType")) {
              if (1 === t3.value)
                return "value: multiple values";
              var n2;
              if (t3.value = 1, n2 = c.onnx.TypeProto.SparseTensor.verify(e3.sparseTensorType))
                return "sparseTensorType." + n2;
            }
            return null != e3.denotation && e3.hasOwnProperty("denotation") && !l.isString(e3.denotation) ? "denotation: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TypeProto)
              return e3;
            var t3 = new c.onnx.TypeProto();
            if (null != e3.tensorType) {
              if ("object" != typeof e3.tensorType)
                throw TypeError(".onnx.TypeProto.tensorType: object expected");
              t3.tensorType = c.onnx.TypeProto.Tensor.fromObject(e3.tensorType);
            }
            if (null != e3.sequenceType) {
              if ("object" != typeof e3.sequenceType)
                throw TypeError(".onnx.TypeProto.sequenceType: object expected");
              t3.sequenceType = c.onnx.TypeProto.Sequence.fromObject(e3.sequenceType);
            }
            if (null != e3.mapType) {
              if ("object" != typeof e3.mapType)
                throw TypeError(".onnx.TypeProto.mapType: object expected");
              t3.mapType = c.onnx.TypeProto.Map.fromObject(e3.mapType);
            }
            if (null != e3.optionalType) {
              if ("object" != typeof e3.optionalType)
                throw TypeError(".onnx.TypeProto.optionalType: object expected");
              t3.optionalType = c.onnx.TypeProto.Optional.fromObject(e3.optionalType);
            }
            if (null != e3.sparseTensorType) {
              if ("object" != typeof e3.sparseTensorType)
                throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
              t3.sparseTensorType = c.onnx.TypeProto.SparseTensor.fromObject(e3.sparseTensorType);
            }
            return null != e3.denotation && (t3.denotation = String(e3.denotation)), t3;
          }, e2.toObject = function(e3, t3) {
            t3 || (t3 = {});
            var n2 = {};
            return t3.defaults && (n2.denotation = ""), null != e3.tensorType && e3.hasOwnProperty("tensorType") && (n2.tensorType = c.onnx.TypeProto.Tensor.toObject(e3.tensorType, t3), t3.oneofs && (n2.value = "tensorType")), null != e3.sequenceType && e3.hasOwnProperty("sequenceType") && (n2.sequenceType = c.onnx.TypeProto.Sequence.toObject(e3.sequenceType, t3), t3.oneofs && (n2.value = "sequenceType")), null != e3.mapType && e3.hasOwnProperty("mapType") && (n2.mapType = c.onnx.TypeProto.Map.toObject(e3.mapType, t3), t3.oneofs && (n2.value = "mapType")), null != e3.denotation && e3.hasOwnProperty("denotation") && (n2.denotation = e3.denotation), null != e3.sparseTensorType && e3.hasOwnProperty("sparseTensorType") && (n2.sparseTensorType = c.onnx.TypeProto.SparseTensor.toObject(e3.sparseTensorType, t3), t3.oneofs && (n2.value = "sparseTensorType")), null != e3.optionalType && e3.hasOwnProperty("optionalType") && (n2.optionalType = c.onnx.TypeProto.Optional.toObject(e3.optionalType, t3), t3.oneofs && (n2.value = "optionalType")), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TypeProto";
          }, e2.Tensor = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = 0, e3.prototype.shape = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && t3.uint32(8).int32(e4.elemType), null != e4.shape && Object.hasOwnProperty.call(e4, "shape") && c.onnx.TensorShapeProto.encode(e4.shape, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Tensor(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.elemType = e4.int32();
                    break;
                  case 2:
                    r2.shape = c.onnx.TensorShapeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType") && !l.isInteger(e4.elemType))
                return "elemType: integer expected";
              if (null != e4.shape && e4.hasOwnProperty("shape")) {
                var t3 = c.onnx.TensorShapeProto.verify(e4.shape);
                if (t3)
                  return "shape." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Tensor)
                return e4;
              var t3 = new c.onnx.TypeProto.Tensor();
              if (null != e4.elemType && (t3.elemType = 0 | e4.elemType), null != e4.shape) {
                if ("object" != typeof e4.shape)
                  throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                t3.shape = c.onnx.TensorShapeProto.fromObject(e4.shape);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = e4.elemType), null != e4.shape && e4.hasOwnProperty("shape") && (n2.shape = c.onnx.TensorShapeProto.toObject(e4.shape, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Tensor";
            }, e3;
          }(), e2.Sequence = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && c.onnx.TypeProto.encode(e4.elemType, t3.uint32(10).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Sequence(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                o2 >>> 3 == 1 ? r2.elemType = c.onnx.TypeProto.decode(e4, e4.uint32()) : e4.skipType(7 & o2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType")) {
                var t3 = c.onnx.TypeProto.verify(e4.elemType);
                if (t3)
                  return "elemType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Sequence)
                return e4;
              var t3 = new c.onnx.TypeProto.Sequence();
              if (null != e4.elemType) {
                if ("object" != typeof e4.elemType)
                  throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
                t3.elemType = c.onnx.TypeProto.fromObject(e4.elemType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = c.onnx.TypeProto.toObject(e4.elemType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Sequence";
            }, e3;
          }(), e2.Map = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.keyType = 0, e3.prototype.valueType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.keyType && Object.hasOwnProperty.call(e4, "keyType") && t3.uint32(8).int32(e4.keyType), null != e4.valueType && Object.hasOwnProperty.call(e4, "valueType") && c.onnx.TypeProto.encode(e4.valueType, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Map(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.keyType = e4.int32();
                    break;
                  case 2:
                    r2.valueType = c.onnx.TypeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.keyType && e4.hasOwnProperty("keyType") && !l.isInteger(e4.keyType))
                return "keyType: integer expected";
              if (null != e4.valueType && e4.hasOwnProperty("valueType")) {
                var t3 = c.onnx.TypeProto.verify(e4.valueType);
                if (t3)
                  return "valueType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Map)
                return e4;
              var t3 = new c.onnx.TypeProto.Map();
              if (null != e4.keyType && (t3.keyType = 0 | e4.keyType), null != e4.valueType) {
                if ("object" != typeof e4.valueType)
                  throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
                t3.valueType = c.onnx.TypeProto.fromObject(e4.valueType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.keyType = 0, n2.valueType = null), null != e4.keyType && e4.hasOwnProperty("keyType") && (n2.keyType = e4.keyType), null != e4.valueType && e4.hasOwnProperty("valueType") && (n2.valueType = c.onnx.TypeProto.toObject(e4.valueType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Map";
            }, e3;
          }(), e2.Optional = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && c.onnx.TypeProto.encode(e4.elemType, t3.uint32(10).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Optional(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                o2 >>> 3 == 1 ? r2.elemType = c.onnx.TypeProto.decode(e4, e4.uint32()) : e4.skipType(7 & o2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType")) {
                var t3 = c.onnx.TypeProto.verify(e4.elemType);
                if (t3)
                  return "elemType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Optional)
                return e4;
              var t3 = new c.onnx.TypeProto.Optional();
              if (null != e4.elemType) {
                if ("object" != typeof e4.elemType)
                  throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
                t3.elemType = c.onnx.TypeProto.fromObject(e4.elemType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = c.onnx.TypeProto.toObject(e4.elemType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Optional";
            }, e3;
          }(), e2.SparseTensor = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = 0, e3.prototype.shape = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && t3.uint32(8).int32(e4.elemType), null != e4.shape && Object.hasOwnProperty.call(e4, "shape") && c.onnx.TensorShapeProto.encode(e4.shape, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.SparseTensor(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.elemType = e4.int32();
                    break;
                  case 2:
                    r2.shape = c.onnx.TensorShapeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType") && !l.isInteger(e4.elemType))
                return "elemType: integer expected";
              if (null != e4.shape && e4.hasOwnProperty("shape")) {
                var t3 = c.onnx.TensorShapeProto.verify(e4.shape);
                if (t3)
                  return "shape." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.SparseTensor)
                return e4;
              var t3 = new c.onnx.TypeProto.SparseTensor();
              if (null != e4.elemType && (t3.elemType = 0 | e4.elemType), null != e4.shape) {
                if ("object" != typeof e4.shape)
                  throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
                t3.shape = c.onnx.TensorShapeProto.fromObject(e4.shape);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = e4.elemType), null != e4.shape && e4.hasOwnProperty("shape") && (n2.shape = c.onnx.TensorShapeProto.toObject(e4.shape, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.SparseTensor";
            }, e3;
          }(), e2;
        }(), i.OperatorSetIdProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.domain = "", e2.prototype.version = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(10).string(e3.domain), null != e3.version && Object.hasOwnProperty.call(e3, "version") && t2.uint32(16).int64(e3.version), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.OperatorSetIdProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.domain = e3.string();
                  break;
                case 2:
                  r2.version = e3.int64();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            return "object" != typeof e3 || null === e3 ? "object expected" : null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain) ? "domain: string expected" : null != e3.version && e3.hasOwnProperty("version") && !(l.isInteger(e3.version) || e3.version && l.isInteger(e3.version.low) && l.isInteger(e3.version.high)) ? "version: integer|Long expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.OperatorSetIdProto)
              return e3;
            var t2 = new c.onnx.OperatorSetIdProto();
            return null != e3.domain && (t2.domain = String(e3.domain)), null != e3.version && (l.Long ? (t2.version = l.Long.fromValue(e3.version)).unsigned = false : "string" == typeof e3.version ? t2.version = parseInt(e3.version, 10) : "number" == typeof e3.version ? t2.version = e3.version : "object" == typeof e3.version && (t2.version = new l.LongBits(e3.version.low >>> 0, e3.version.high >>> 0).toNumber())), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if (t2.defaults)
              if (n2.domain = "", l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.version = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.version = t2.longs === String ? "0" : 0;
            return null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), null != e3.version && e3.hasOwnProperty("version") && ("number" == typeof e3.version ? n2.version = t2.longs === String ? String(e3.version) : e3.version : n2.version = t2.longs === String ? l.Long.prototype.toString.call(e3.version) : t2.longs === Number ? new l.LongBits(e3.version.low >>> 0, e3.version.high >>> 0).toNumber() : e3.version), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.OperatorSetIdProto";
          }, e2;
        }(), i.OperatorStatus = function() {
          var e2 = {}, t2 = Object.create(e2);
          return t2[e2[0] = "EXPERIMENTAL"] = 0, t2[e2[1] = "STABLE"] = 1, t2;
        }(), i.FunctionProto = function() {
          function e2(e3) {
            if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.attribute = l.emptyArray, e2.prototype.attributeProto = l.emptyArray, e2.prototype.node = l.emptyArray, e2.prototype.docString = "", e2.prototype.opsetImport = l.emptyArray, e2.prototype.domain = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.input && e3.input.length)
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.uint32(34).string(e3.input[n2]);
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                t2.uint32(42).string(e3.output[n2]);
            if (null != e3.attribute && e3.attribute.length)
              for (n2 = 0; n2 < e3.attribute.length; ++n2)
                t2.uint32(50).string(e3.attribute[n2]);
            if (null != e3.node && e3.node.length)
              for (n2 = 0; n2 < e3.node.length; ++n2)
                c.onnx.NodeProto.encode(e3.node[n2], t2.uint32(58).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(66).string(e3.docString), null != e3.opsetImport && e3.opsetImport.length)
              for (n2 = 0; n2 < e3.opsetImport.length; ++n2)
                c.onnx.OperatorSetIdProto.encode(e3.opsetImport[n2], t2.uint32(74).fork()).ldelim();
            if (null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(82).string(e3.domain), null != e3.attributeProto && e3.attributeProto.length)
              for (n2 = 0; n2 < e3.attributeProto.length; ++n2)
                c.onnx.AttributeProto.encode(e3.attributeProto[n2], t2.uint32(90).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.FunctionProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 4:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(e3.string());
                  break;
                case 5:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(e3.string());
                  break;
                case 6:
                  r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(e3.string());
                  break;
                case 11:
                  r2.attributeProto && r2.attributeProto.length || (r2.attributeProto = []), r2.attributeProto.push(c.onnx.AttributeProto.decode(e3, e3.uint32()));
                  break;
                case 7:
                  r2.node && r2.node.length || (r2.node = []), r2.node.push(c.onnx.NodeProto.decode(e3, e3.uint32()));
                  break;
                case 8:
                  r2.docString = e3.string();
                  break;
                case 9:
                  r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e3, e3.uint32()));
                  break;
                case 10:
                  r2.domain = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (var t2 = 0; t2 < e3.input.length; ++t2)
                if (!l.isString(e3.input[t2]))
                  return "input: string[] expected";
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (!l.isString(e3.output[t2]))
                  return "output: string[] expected";
            }
            if (null != e3.attribute && e3.hasOwnProperty("attribute")) {
              if (!Array.isArray(e3.attribute))
                return "attribute: array expected";
              for (t2 = 0; t2 < e3.attribute.length; ++t2)
                if (!l.isString(e3.attribute[t2]))
                  return "attribute: string[] expected";
            }
            if (null != e3.attributeProto && e3.hasOwnProperty("attributeProto")) {
              if (!Array.isArray(e3.attributeProto))
                return "attributeProto: array expected";
              for (t2 = 0; t2 < e3.attributeProto.length; ++t2)
                if (n2 = c.onnx.AttributeProto.verify(e3.attributeProto[t2]))
                  return "attributeProto." + n2;
            }
            if (null != e3.node && e3.hasOwnProperty("node")) {
              if (!Array.isArray(e3.node))
                return "node: array expected";
              for (t2 = 0; t2 < e3.node.length; ++t2)
                if (n2 = c.onnx.NodeProto.verify(e3.node[t2]))
                  return "node." + n2;
            }
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.opsetImport && e3.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(e3.opsetImport))
                return "opsetImport: array expected";
              for (t2 = 0; t2 < e3.opsetImport.length; ++t2) {
                var n2;
                if (n2 = c.onnx.OperatorSetIdProto.verify(e3.opsetImport[t2]))
                  return "opsetImport." + n2;
              }
            }
            return null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain) ? "domain: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.FunctionProto)
              return e3;
            var t2 = new c.onnx.FunctionProto();
            if (null != e3.name && (t2.name = String(e3.name)), e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.FunctionProto.input: array expected");
              t2.input = [];
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.input[n2] = String(e3.input[n2]);
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.FunctionProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2)
                t2.output[n2] = String(e3.output[n2]);
            }
            if (e3.attribute) {
              if (!Array.isArray(e3.attribute))
                throw TypeError(".onnx.FunctionProto.attribute: array expected");
              for (t2.attribute = [], n2 = 0; n2 < e3.attribute.length; ++n2)
                t2.attribute[n2] = String(e3.attribute[n2]);
            }
            if (e3.attributeProto) {
              if (!Array.isArray(e3.attributeProto))
                throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
              for (t2.attributeProto = [], n2 = 0; n2 < e3.attributeProto.length; ++n2) {
                if ("object" != typeof e3.attributeProto[n2])
                  throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
                t2.attributeProto[n2] = c.onnx.AttributeProto.fromObject(e3.attributeProto[n2]);
              }
            }
            if (e3.node) {
              if (!Array.isArray(e3.node))
                throw TypeError(".onnx.FunctionProto.node: array expected");
              for (t2.node = [], n2 = 0; n2 < e3.node.length; ++n2) {
                if ("object" != typeof e3.node[n2])
                  throw TypeError(".onnx.FunctionProto.node: object expected");
                t2.node[n2] = c.onnx.NodeProto.fromObject(e3.node[n2]);
              }
            }
            if (null != e3.docString && (t2.docString = String(e3.docString)), e3.opsetImport) {
              if (!Array.isArray(e3.opsetImport))
                throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
              for (t2.opsetImport = [], n2 = 0; n2 < e3.opsetImport.length; ++n2) {
                if ("object" != typeof e3.opsetImport[n2])
                  throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
                t2.opsetImport[n2] = c.onnx.OperatorSetIdProto.fromObject(e3.opsetImport[n2]);
              }
            }
            return null != e3.domain && (t2.domain = String(e3.domain)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = [], n2.node = [], n2.opsetImport = [], n2.attributeProto = []), t2.defaults && (n2.name = "", n2.docString = "", n2.domain = ""), null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), e3.input && e3.input.length) {
              n2.input = [];
              for (var r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = e3.input[r2];
            }
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = e3.output[r2];
            if (e3.attribute && e3.attribute.length)
              for (n2.attribute = [], r2 = 0; r2 < e3.attribute.length; ++r2)
                n2.attribute[r2] = e3.attribute[r2];
            if (e3.node && e3.node.length)
              for (n2.node = [], r2 = 0; r2 < e3.node.length; ++r2)
                n2.node[r2] = c.onnx.NodeProto.toObject(e3.node[r2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.opsetImport && e3.opsetImport.length)
              for (n2.opsetImport = [], r2 = 0; r2 < e3.opsetImport.length; ++r2)
                n2.opsetImport[r2] = c.onnx.OperatorSetIdProto.toObject(e3.opsetImport[r2], t2);
            if (null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), e3.attributeProto && e3.attributeProto.length)
              for (n2.attributeProto = [], r2 = 0; r2 < e3.attributeProto.length; ++r2)
                n2.attributeProto[r2] = c.onnx.AttributeProto.toObject(e3.attributeProto[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.FunctionProto";
          }, e2;
        }(), i), e.exports = c;
      }, 3474: (e, t, n) => {
        var _scriptDir, r = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (_scriptDir = _scriptDir || __filename), function(e2 = {}) {
          function t2() {
            return D.buffer != N.buffer && U(), N;
          }
          function r2() {
            return D.buffer != N.buffer && U(), R;
          }
          function o() {
            return D.buffer != N.buffer && U(), L;
          }
          function i() {
            return D.buffer != N.buffer && U(), C;
          }
          function a() {
            return D.buffer != N.buffer && U(), j;
          }
          var s, u, l = e2;
          l.ready = new Promise((e3, t3) => {
            s = e3, u = t3;
          });
          var c, p, d, f = Object.assign({}, l), h = "./this.program", g = (e3, t3) => {
            throw t3;
          }, b = "object" == typeof window, m = "function" == typeof importScripts, y = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, v = l.ENVIRONMENT_IS_PTHREAD || false, _ = "";
          function w(e3) {
            return l.locateFile ? l.locateFile(e3, _) : _ + e3;
          }
          if (y) {
            var T = n(1384), x = n(908);
            let t3;
            _ = m ? x.dirname(_) + "/" : __dirname + "/", c = (e3, t4) => (e3 = e3.startsWith("file://") ? new URL(e3) : x.normalize(e3), T.readFileSync(e3, t4 ? void 0 : "utf8")), d = (e3) => ((e3 = c(e3, true)).buffer || (e3 = new Uint8Array(e3)), e3), p = (e3, t4, n2, r3 = true) => {
              e3 = e3.startsWith("file://") ? new URL(e3) : x.normalize(e3), T.readFile(e3, r3 ? void 0 : "utf8", (e4, o2) => {
                e4 ? n2(e4) : t4(r3 ? o2.buffer : o2);
              });
            }, !l.thisProgram && 1 < process.argv.length && (h = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), g = (e3, t4) => {
              throw process.exitCode = e3, t4;
            }, l.inspect = () => "[Emscripten Module object]";
            try {
              t3 = n(9925);
            } catch (e3) {
              throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e3;
            }
            global.Worker = t3.Worker;
          } else
            (b || m) && (m ? _ = self.location.href : "undefined" != typeof document && document.currentScript && (_ = document.currentScript.src), _scriptDir && (_ = _scriptDir), _ = 0 !== _.indexOf("blob:") ? _.substr(0, _.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", y || (c = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.send(null), t3.responseText;
            }, m && (d = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), p = (e3, t3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", e3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? t3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            }));
          y && "undefined" == typeof performance && (global.performance = n(6953).performance);
          var O = console.log.bind(console), S = console.error.bind(console);
          y && (O = (...e3) => T.writeSync(1, e3.join(" ") + "\n"), S = (...e3) => T.writeSync(2, e3.join(" ") + "\n"));
          var A, P = l.print || O, I = l.printErr || S;
          Object.assign(l, f), f = null, l.thisProgram && (h = l.thisProgram), l.quit && (g = l.quit), l.wasmBinary && (A = l.wasmBinary);
          var E = l.noExitRuntime || true;
          "object" != typeof WebAssembly && te("no native wasm support detected");
          var D, $, k, F, N, R, L, C, j, M = false;
          function U() {
            var e3 = D.buffer;
            l.HEAP8 = N = new Int8Array(e3), l.HEAP16 = new Int16Array(e3), l.HEAP32 = L = new Int32Array(e3), l.HEAPU8 = R = new Uint8Array(e3), l.HEAPU16 = new Uint16Array(e3), l.HEAPU32 = C = new Uint32Array(e3), l.HEAPF32 = new Float32Array(e3), l.HEAPF64 = j = new Float64Array(e3);
          }
          var B = l.INITIAL_MEMORY || 16777216;
          if (5242880 <= B || te("INITIAL_MEMORY should be larger than STACK_SIZE, was " + B + "! (STACK_SIZE=5242880)"), v)
            D = l.wasmMemory;
          else if (l.wasmMemory)
            D = l.wasmMemory;
          else if (!((D = new WebAssembly.Memory({ initial: B / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer))
            throw I("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), y && I("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
          U(), B = D.buffer.byteLength;
          var V, z2 = [], G = [], H = [], W = 0;
          function q() {
            return E || 0 < W;
          }
          var X, Y, K = 0, J = null, Z = null;
          function Q() {
            K++, l.monitorRunDependencies && l.monitorRunDependencies(K);
          }
          function ee() {
            if (K--, l.monitorRunDependencies && l.monitorRunDependencies(K), 0 == K && (null !== J && (clearInterval(J), J = null), Z)) {
              var e3 = Z;
              Z = null, e3();
            }
          }
          function te(e3) {
            throw l.onAbort && l.onAbort(e3), I(e3 = "Aborted(" + e3 + ")"), M = true, F = 1, e3 = new WebAssembly.RuntimeError(e3 + ". Build with -sASSERTIONS for more info."), u(e3), e3;
          }
          function ne(e3) {
            return e3.startsWith("data:application/octet-stream;base64,");
          }
          function re(e3) {
            if (e3 == X && A)
              return new Uint8Array(A);
            if (d)
              return d(e3);
            throw "both async and sync fetching of the wasm failed";
          }
          function oe(e3, t3, n2) {
            return function(e4) {
              if (!A && (b || m)) {
                if ("function" == typeof fetch && !e4.startsWith("file://"))
                  return fetch(e4, { credentials: "same-origin" }).then((t4) => {
                    if (!t4.ok)
                      throw "failed to load wasm binary file at '" + e4 + "'";
                    return t4.arrayBuffer();
                  }).catch(() => re(e4));
                if (p)
                  return new Promise((t4, n3) => {
                    p(e4, (e5) => t4(new Uint8Array(e5)), n3);
                  });
              }
              return Promise.resolve().then(() => re(e4));
            }(e3).then((e4) => WebAssembly.instantiate(e4, t3)).then((e4) => e4).then(n2, (e4) => {
              I("failed to asynchronously prepare wasm: " + e4), te(e4);
            });
          }
          function ie(e3) {
            this.name = "ExitStatus", this.message = `Program terminated with exit(${e3})`, this.status = e3;
          }
          function ae(e3) {
            e3.terminate(), e3.onmessage = () => {
            };
          }
          function se(e3) {
            (e3 = he.Fa[e3]) || te(), he.fb(e3);
          }
          function ue(e3) {
            var t3 = he.Za();
            if (!t3)
              return 6;
            he.Ia.push(t3), he.Fa[e3.Ha] = t3, t3.Ha = e3.Ha;
            var n2 = { cmd: "run", start_routine: e3.gb, arg: e3.Ya, pthread_ptr: e3.Ha };
            return y && t3.unref(), t3.postMessage(n2, e3.mb), 0;
          }
          ne(X = "ort-wasm-threaded.wasm") || (X = w(X));
          var le = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, ce = (e3, t3, n2) => {
            var r3 = (t3 >>>= 0) + n2;
            for (n2 = t3; e3[n2] && !(n2 >= r3); )
              ++n2;
            if (16 < n2 - t3 && e3.buffer && le)
              return le.decode(e3.buffer instanceof SharedArrayBuffer ? e3.slice(t3, n2) : e3.subarray(t3, n2));
            for (r3 = ""; t3 < n2; ) {
              var o2 = e3[t3++];
              if (128 & o2) {
                var i2 = 63 & e3[t3++];
                if (192 == (224 & o2))
                  r3 += String.fromCharCode((31 & o2) << 6 | i2);
                else {
                  var a2 = 63 & e3[t3++];
                  65536 > (o2 = 224 == (240 & o2) ? (15 & o2) << 12 | i2 << 6 | a2 : (7 & o2) << 18 | i2 << 12 | a2 << 6 | 63 & e3[t3++]) ? r3 += String.fromCharCode(o2) : (o2 -= 65536, r3 += String.fromCharCode(55296 | o2 >> 10, 56320 | 1023 & o2));
                }
              } else
                r3 += String.fromCharCode(o2);
            }
            return r3;
          }, pe = (e3, t3) => (e3 >>>= 0) ? ce(r2(), e3, t3) : "";
          function de(e3) {
            if (v)
              return qe(1, 1, e3);
            F = e3, q() || (he.hb(), l.onExit && l.onExit(e3), M = true), g(e3, new ie(e3));
          }
          var fe = (e3) => {
            if (F = e3, v)
              throw be(e3), "unwind";
            de(e3);
          }, he = { La: [], Ia: [], Ta: [], Fa: {}, Pa: function() {
            v ? he.ab() : he.$a();
          }, $a: function() {
            z2.unshift(() => {
              Q(), he.bb(() => ee());
            });
          }, ab: function() {
            he.receiveObjectTransfer = he.eb, he.threadInitTLS = he.Sa, he.setExitStatus = he.Ra, E = false;
          }, Ra: function(e3) {
            F = e3;
          }, rb: ["$terminateWorker"], hb: function() {
            for (var e3 of he.Ia)
              ae(e3);
            for (e3 of he.La)
              ae(e3);
            he.La = [], he.Ia = [], he.Fa = [];
          }, fb: function(e3) {
            var t3 = e3.Ha;
            delete he.Fa[t3], he.La.push(e3), he.Ia.splice(he.Ia.indexOf(e3), 1), e3.Ha = 0, mt(t3);
          }, eb: function() {
          }, Sa: function() {
            he.Ta.forEach((e3) => e3());
          }, cb: (e3) => new Promise((t3) => {
            e3.onmessage = (n3) => {
              var r4 = (n3 = n3.data).cmd;
              if (n3.targetThread && n3.targetThread != dt()) {
                var o2 = he.Fa[n3.qb];
                o2 ? o2.postMessage(n3, n3.transferList) : I('Internal error! Worker sent a message "' + r4 + '" to target pthread ' + n3.targetThread + ", but that thread no longer exists!");
              } else
                "checkMailbox" === r4 ? Me() : "spawnThread" === r4 ? ue(n3) : "cleanupThread" === r4 ? se(n3.thread) : "killThread" === r4 ? (n3 = n3.thread, r4 = he.Fa[n3], delete he.Fa[n3], ae(r4), mt(n3), he.Ia.splice(he.Ia.indexOf(r4), 1), r4.Ha = 0) : "cancelThread" === r4 ? he.Fa[n3.thread].postMessage({ cmd: "cancel" }) : "loaded" === r4 ? (e3.loaded = true, t3(e3)) : "alert" === r4 ? alert("Thread " + n3.threadId + ": " + n3.text) : "setimmediate" === n3.target ? e3.postMessage(n3) : "callHandler" === r4 ? l[n3.handler](...n3.args) : r4 && I("worker sent an unknown command " + r4);
            }, e3.onerror = (e4) => {
              throw I("worker sent an error! " + e4.filename + ":" + e4.lineno + ": " + e4.message), e4;
            }, y && (e3.on("message", function(t4) {
              e3.onmessage({ data: t4 });
            }), e3.on("error", function(t4) {
              e3.onerror(t4);
            }));
            var n2, r3 = [];
            for (n2 of ["onExit", "onAbort", "print", "printErr"])
              l.hasOwnProperty(n2) && r3.push(n2);
            e3.postMessage({ cmd: "load", handlers: r3, urlOrBlob: l.mainScriptUrlOrBlob || _scriptDir, wasmMemory: D, wasmModule: k });
          }), bb: function(e3) {
            e3();
          }, Xa: function() {
            var e3 = w("ort-wasm-threaded.worker.js");
            e3 = new Worker(e3), he.La.push(e3);
          }, Za: function() {
            return 0 == he.La.length && (he.Xa(), he.cb(he.La[0])), he.La.pop();
          } };
          l.PThread = he;
          var ge = (e3) => {
            for (; 0 < e3.length; )
              e3.shift()(l);
          };
          function be(e3) {
            if (v)
              return qe(2, 0, e3);
            fe(e3);
          }
          l.establishStackSpace = function() {
            var e3 = dt(), t3 = o()[e3 + 52 >> 2 >>> 0];
            e3 = o()[e3 + 56 >> 2 >>> 0], wt(t3, t3 - e3), xt(t3);
          };
          var me = [];
          function ye(e3) {
            this.Oa = e3 - 24, this.Wa = function(e4) {
              i()[this.Oa + 4 >> 2 >>> 0] = e4;
            }, this.Va = function(e4) {
              i()[this.Oa + 8 >> 2 >>> 0] = e4;
            }, this.Pa = function(e4, t3) {
              this.Ua(), this.Wa(e4), this.Va(t3);
            }, this.Ua = function() {
              i()[this.Oa + 16 >> 2 >>> 0] = 0;
            };
          }
          function ve(e3, t3, n2, r3) {
            return v ? qe(3, 1, e3, t3, n2, r3) : _e(e3, t3, n2, r3);
          }
          function _e(e3, t3, n2, r3) {
            if (e3 >>>= 0, t3 >>>= 0, n2 >>>= 0, r3 >>>= 0, "undefined" == typeof SharedArrayBuffer)
              return I("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
            var o2 = [];
            return v && 0 === o2.length ? ve(e3, t3, n2, r3) : (e3 = { gb: n2, Ha: e3, Ya: r3, mb: o2 }, v ? (e3.ob = "spawnThread", postMessage(e3, o2), 0) : ue(e3));
          }
          function we(e3, t3, n2) {
            return v ? qe(4, 1, e3, t3, n2) : 0;
          }
          function Te(e3, t3) {
            if (v)
              return qe(5, 1, e3, t3);
          }
          l.invokeEntryPoint = function(e3, t3) {
            var n2 = me[e3];
            n2 || (e3 >= me.length && (me.length = e3 + 1), me[e3] = n2 = V.get(e3)), e3 = n2(t3), q() ? he.Ra(e3) : yt(e3);
          };
          var xe = (e3) => {
            for (var t3 = 0, n2 = 0; n2 < e3.length; ++n2) {
              var r3 = e3.charCodeAt(n2);
              127 >= r3 ? t3++ : 2047 >= r3 ? t3 += 2 : 55296 <= r3 && 57343 >= r3 ? (t3 += 4, ++n2) : t3 += 3;
            }
            return t3;
          }, Oe = (e3, t3, n2, r3) => {
            if (!(0 < r3))
              return 0;
            var o2 = n2 >>>= 0;
            r3 = n2 + r3 - 1;
            for (var i2 = 0; i2 < e3.length; ++i2) {
              var a2 = e3.charCodeAt(i2);
              if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++i2)), 127 >= a2) {
                if (n2 >= r3)
                  break;
                t3[n2++ >>> 0] = a2;
              } else {
                if (2047 >= a2) {
                  if (n2 + 1 >= r3)
                    break;
                  t3[n2++ >>> 0] = 192 | a2 >> 6;
                } else {
                  if (65535 >= a2) {
                    if (n2 + 2 >= r3)
                      break;
                    t3[n2++ >>> 0] = 224 | a2 >> 12;
                  } else {
                    if (n2 + 3 >= r3)
                      break;
                    t3[n2++ >>> 0] = 240 | a2 >> 18, t3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                }
                t3[n2++ >>> 0] = 128 | 63 & a2;
              }
            }
            return t3[n2 >>> 0] = 0, n2 - o2;
          }, Se = (e3, t3, n2) => Oe(e3, r2(), t3, n2);
          function Ae(e3, t3) {
            if (v)
              return qe(6, 1, e3, t3);
          }
          function Pe(e3, t3, n2) {
            if (v)
              return qe(7, 1, e3, t3, n2);
          }
          function Ie(e3, t3, n2) {
            return v ? qe(8, 1, e3, t3, n2) : 0;
          }
          function Ee(e3, t3) {
            if (v)
              return qe(9, 1, e3, t3);
          }
          function De(e3, t3, n2) {
            if (v)
              return qe(10, 1, e3, t3, n2);
          }
          function $e(e3, t3, n2, r3) {
            if (v)
              return qe(11, 1, e3, t3, n2, r3);
          }
          function ke(e3, t3, n2, r3) {
            if (v)
              return qe(12, 1, e3, t3, n2, r3);
          }
          function Fe(e3, t3, n2, r3) {
            if (v)
              return qe(13, 1, e3, t3, n2, r3);
          }
          function Ne(e3) {
            if (v)
              return qe(14, 1, e3);
          }
          function Re(e3, t3) {
            if (v)
              return qe(15, 1, e3, t3);
          }
          function Le(e3, t3, n2) {
            if (v)
              return qe(16, 1, e3, t3, n2);
          }
          var Ce = (e3) => {
            if (!M)
              try {
                if (e3(), !q())
                  try {
                    v ? yt(F) : fe(F);
                  } catch (e4) {
                    e4 instanceof ie || "unwind" == e4 || g(1, e4);
                  }
              } catch (e4) {
                e4 instanceof ie || "unwind" == e4 || g(1, e4);
              }
          };
          function je(e3) {
            e3 >>>= 0, "function" == typeof Atomics.nb && (Atomics.nb(o(), e3 >> 2, e3).value.then(Me), e3 += 128, Atomics.store(o(), e3 >> 2, 1));
          }
          function Me() {
            var e3 = dt();
            e3 && (je(e3), Ce(() => vt()));
          }
          l.__emscripten_thread_mailbox_await = je, l.checkMailbox = Me;
          var Ue = (e3) => 0 == e3 % 4 && (0 != e3 % 100 || 0 == e3 % 400), Be = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Ve = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          function ze(e3, t3, n2, r3, o2, i2, a2, s2) {
            return v ? qe(17, 1, e3, t3, n2, r3, o2, i2, a2, s2) : -52;
          }
          function Ge(e3, t3, n2, r3, o2, i2, a2) {
            if (v)
              return qe(18, 1, e3, t3, n2, r3, o2, i2, a2);
          }
          var He = (e3) => {
            var t3 = xe(e3) + 1, n2 = ft(t3);
            return n2 && Se(e3, n2, t3), n2;
          }, We = (e3) => {
            var t3 = Tt();
            return e3 = e3(), xt(t3), e3;
          };
          function qe(e3, t3) {
            var n2 = arguments.length - 2, r3 = arguments;
            return We(() => {
              for (var o2 = Ot(8 * n2), i2 = o2 >> 3, s2 = 0; s2 < n2; s2++) {
                var u2 = r3[2 + s2];
                a()[i2 + s2 >>> 0] = u2;
              }
              return bt(e3, n2, o2, t3);
            });
          }
          var Xe, Ye = [], Ke = {}, Je = () => {
            if (!Xe) {
              var e3, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: h || "./this.program" };
              for (e3 in Ke)
                void 0 === Ke[e3] ? delete t3[e3] : t3[e3] = Ke[e3];
              var n2 = [];
              for (e3 in t3)
                n2.push(`${e3}=${t3[e3]}`);
              Xe = n2;
            }
            return Xe;
          };
          function Ze(e3, n2) {
            if (v)
              return qe(19, 1, e3, n2);
            e3 >>>= 0, n2 >>>= 0;
            var r3 = 0;
            return Je().forEach(function(o2, a2) {
              var s2 = n2 + r3;
              for (a2 = i()[e3 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < o2.length; ++s2)
                t2()[a2++ >> 0 >>> 0] = o2.charCodeAt(s2);
              t2()[a2 >> 0 >>> 0] = 0, r3 += o2.length + 1;
            }), 0;
          }
          function Qe(e3, t3) {
            if (v)
              return qe(20, 1, e3, t3);
            e3 >>>= 0, t3 >>>= 0;
            var n2 = Je();
            i()[e3 >> 2 >>> 0] = n2.length;
            var r3 = 0;
            return n2.forEach(function(e4) {
              r3 += e4.length + 1;
            }), i()[t3 >> 2 >>> 0] = r3, 0;
          }
          function et(e3) {
            return v ? qe(21, 1, e3) : 52;
          }
          function tt(e3, t3, n2, r3) {
            return v ? qe(22, 1, e3, t3, n2, r3) : 52;
          }
          function nt(e3, t3, n2, r3, o2) {
            return v ? qe(23, 1, e3, t3, n2, r3, o2) : 70;
          }
          var rt = [null, [], []];
          function ot(e3, t3, n2, o2) {
            if (v)
              return qe(24, 1, e3, t3, n2, o2);
            t3 >>>= 0, n2 >>>= 0, o2 >>>= 0;
            for (var a2 = 0, s2 = 0; s2 < n2; s2++) {
              var u2 = i()[t3 >> 2 >>> 0], l2 = i()[t3 + 4 >> 2 >>> 0];
              t3 += 8;
              for (var c2 = 0; c2 < l2; c2++) {
                var p2 = r2()[u2 + c2 >>> 0], d2 = rt[e3];
                0 === p2 || 10 === p2 ? ((1 === e3 ? P : I)(ce(d2, 0)), d2.length = 0) : d2.push(p2);
              }
              a2 += l2;
            }
            return i()[o2 >> 2 >>> 0] = a2, 0;
          }
          var it = (e3) => (it = (() => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
              return (e5) => (e5.set(crypto.getRandomValues(new Uint8Array(e5.byteLength))), e5);
            if (y)
              try {
                var e4 = n(760);
                if (e4.randomFillSync)
                  return (t4) => e4.randomFillSync(t4);
                var t3 = e4.randomBytes;
                return (e5) => (e5.set(t3(e5.byteLength)), e5);
              } catch (e5) {
              }
            te("initRandomDevice");
          })())(e3), at = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], st = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ut = (e3, n2) => {
            t2().set(e3, n2 >>> 0);
          };
          function lt(e3, t3, n2, r3) {
            function i2(e4, t4, n3) {
              for (e4 = "number" == typeof e4 ? e4.toString() : e4 || ""; e4.length < t4; )
                e4 = n3[0] + e4;
              return e4;
            }
            function a2(e4, t4) {
              return i2(e4, t4, "0");
            }
            function s2(e4, t4) {
              function n3(e5) {
                return 0 > e5 ? -1 : 0 < e5 ? 1 : 0;
              }
              var r4;
              return 0 === (r4 = n3(e4.getFullYear() - t4.getFullYear())) && 0 === (r4 = n3(e4.getMonth() - t4.getMonth())) && (r4 = n3(e4.getDate() - t4.getDate())), r4;
            }
            function u2(e4) {
              switch (e4.getDay()) {
                case 0:
                  return new Date(e4.getFullYear() - 1, 11, 29);
                case 1:
                  return e4;
                case 2:
                  return new Date(e4.getFullYear(), 0, 3);
                case 3:
                  return new Date(e4.getFullYear(), 0, 2);
                case 4:
                  return new Date(e4.getFullYear(), 0, 1);
                case 5:
                  return new Date(e4.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(e4.getFullYear() - 1, 11, 30);
              }
            }
            function l2(e4) {
              var t4 = e4.Ja;
              for (e4 = new Date(new Date(e4.Ka + 1900, 0, 1).getTime()); 0 < t4; ) {
                var n3 = e4.getMonth(), r4 = (Ue(e4.getFullYear()) ? at : st)[n3];
                if (!(t4 > r4 - e4.getDate())) {
                  e4.setDate(e4.getDate() + t4);
                  break;
                }
                t4 -= r4 - e4.getDate() + 1, e4.setDate(1), 11 > n3 ? e4.setMonth(n3 + 1) : (e4.setMonth(0), e4.setFullYear(e4.getFullYear() + 1));
              }
              return n3 = new Date(e4.getFullYear() + 1, 0, 4), t4 = u2(new Date(e4.getFullYear(), 0, 4)), n3 = u2(n3), 0 >= s2(t4, e4) ? 0 >= s2(n3, e4) ? e4.getFullYear() + 1 : e4.getFullYear() : e4.getFullYear() - 1;
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0, r3 >>>= 0;
            var c2 = o()[r3 + 40 >> 2 >>> 0];
            for (var p2 in r3 = { kb: o()[r3 >> 2 >>> 0], jb: o()[r3 + 4 >> 2 >>> 0], Ma: o()[r3 + 8 >> 2 >>> 0], Qa: o()[r3 + 12 >> 2 >>> 0], Na: o()[r3 + 16 >> 2 >>> 0], Ka: o()[r3 + 20 >> 2 >>> 0], Ga: o()[r3 + 24 >> 2 >>> 0], Ja: o()[r3 + 28 >> 2 >>> 0], sb: o()[r3 + 32 >> 2 >>> 0], ib: o()[r3 + 36 >> 2 >>> 0], lb: c2 ? pe(c2) : "" }, n2 = pe(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
              n2 = n2.replace(new RegExp(p2, "g"), c2[p2]);
            var d2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f2 = "January February March April May June July August September October November December".split(" ");
            for (p2 in c2 = { "%a": (e4) => d2[e4.Ga].substring(0, 3), "%A": (e4) => d2[e4.Ga], "%b": (e4) => f2[e4.Na].substring(0, 3), "%B": (e4) => f2[e4.Na], "%C": (e4) => a2((e4.Ka + 1900) / 100 | 0, 2), "%d": (e4) => a2(e4.Qa, 2), "%e": (e4) => i2(e4.Qa, 2, " "), "%g": (e4) => l2(e4).toString().substring(2), "%G": (e4) => l2(e4), "%H": (e4) => a2(e4.Ma, 2), "%I": (e4) => (0 == (e4 = e4.Ma) ? e4 = 12 : 12 < e4 && (e4 -= 12), a2(e4, 2)), "%j": (e4) => {
              for (var t4 = 0, n3 = 0; n3 <= e4.Na - 1; t4 += (Ue(e4.Ka + 1900) ? at : st)[n3++])
                ;
              return a2(e4.Qa + t4, 3);
            }, "%m": (e4) => a2(e4.Na + 1, 2), "%M": (e4) => a2(e4.jb, 2), "%n": () => "\n", "%p": (e4) => 0 <= e4.Ma && 12 > e4.Ma ? "AM" : "PM", "%S": (e4) => a2(e4.kb, 2), "%t": () => "	", "%u": (e4) => e4.Ga || 7, "%U": (e4) => a2(Math.floor((e4.Ja + 7 - e4.Ga) / 7), 2), "%V": (e4) => {
              var t4 = Math.floor((e4.Ja + 7 - (e4.Ga + 6) % 7) / 7);
              if (2 >= (e4.Ga + 371 - e4.Ja - 2) % 7 && t4++, t4)
                53 == t4 && (4 == (n3 = (e4.Ga + 371 - e4.Ja) % 7) || 3 == n3 && Ue(e4.Ka) || (t4 = 1));
              else {
                t4 = 52;
                var n3 = (e4.Ga + 7 - e4.Ja - 1) % 7;
                (4 == n3 || 5 == n3 && Ue(e4.Ka % 400 - 1)) && t4++;
              }
              return a2(t4, 2);
            }, "%w": (e4) => e4.Ga, "%W": (e4) => a2(Math.floor((e4.Ja + 7 - (e4.Ga + 6) % 7) / 7), 2), "%y": (e4) => (e4.Ka + 1900).toString().substring(2), "%Y": (e4) => e4.Ka + 1900, "%z": (e4) => {
              var t4 = 0 <= (e4 = e4.ib);
              return e4 = Math.abs(e4) / 60, (t4 ? "+" : "-") + String("0000" + (e4 / 60 * 100 + e4 % 60)).slice(-4);
            }, "%Z": (e4) => e4.lb, "%%": () => "%" }, n2 = n2.replace(/%%/g, "\0\0"), c2)
              n2.includes(p2) && (n2 = n2.replace(new RegExp(p2, "g"), c2[p2](r3)));
            return p2 = function(e4) {
              var t4 = Array(xe(e4) + 1);
              return Oe(e4, t4, 0, t4.length), t4;
            }(n2 = n2.replace(/\0\0/g, "%")), p2.length > t3 ? 0 : (ut(p2, e3), p2.length - 1);
          }
          he.Pa();
          var ct = [null, de, be, ve, we, Te, Ae, Pe, Ie, Ee, De, $e, ke, Fe, Ne, Re, Le, ze, Ge, Ze, Qe, et, tt, nt, ot], pt = { b: function(e3, t3, n2) {
            throw new ye(e3 >>>= 0).Pa(t3 >>> 0, n2 >>> 0), e3;
          }, N: function(e3) {
            ht(e3 >>> 0, !m, 1, !b, 131072, false), he.Sa();
          }, k: function(e3) {
            e3 >>>= 0, v ? postMessage({ cmd: "cleanupThread", thread: e3 }) : se(e3);
          }, I: _e, h: we, T: Te, E: Ae, G: Pe, U: Ie, R: Ee, J: De, Q: $e, o: ke, F: Fe, C: Ne, S: Re, D: Le, q: () => true, A: function(e3, t3) {
            (e3 >>>= 0) == t3 >>> 0 ? setTimeout(() => Me()) : v ? postMessage({ targetThread: e3, cmd: "checkMailbox" }) : (e3 = he.Fa[e3]) && e3.postMessage({ cmd: "checkMailbox" });
          }, L: function() {
            return -1;
          }, M: je, p: function(e3) {
            y && he.Fa[e3 >>> 0].ref();
          }, t: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), o()[n2 >> 2 >>> 0] = e3.getUTCSeconds(), o()[n2 + 4 >> 2 >>> 0] = e3.getUTCMinutes(), o()[n2 + 8 >> 2 >>> 0] = e3.getUTCHours(), o()[n2 + 12 >> 2 >>> 0] = e3.getUTCDate(), o()[n2 + 16 >> 2 >>> 0] = e3.getUTCMonth(), o()[n2 + 20 >> 2 >>> 0] = e3.getUTCFullYear() - 1900, o()[n2 + 24 >> 2 >>> 0] = e3.getUTCDay(), e3 = (e3.getTime() - Date.UTC(e3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, o()[n2 + 28 >> 2 >>> 0] = e3;
          }, u: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), o()[n2 >> 2 >>> 0] = e3.getSeconds(), o()[n2 + 4 >> 2 >>> 0] = e3.getMinutes(), o()[n2 + 8 >> 2 >>> 0] = e3.getHours(), o()[n2 + 12 >> 2 >>> 0] = e3.getDate(), o()[n2 + 16 >> 2 >>> 0] = e3.getMonth(), o()[n2 + 20 >> 2 >>> 0] = e3.getFullYear() - 1900, o()[n2 + 24 >> 2 >>> 0] = e3.getDay(), t3 = (Ue(e3.getFullYear()) ? Be : Ve)[e3.getMonth()] + e3.getDate() - 1 | 0, o()[n2 + 28 >> 2 >>> 0] = t3, o()[n2 + 36 >> 2 >>> 0] = -60 * e3.getTimezoneOffset(), t3 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset();
            var r3 = new Date(e3.getFullYear(), 0, 1).getTimezoneOffset();
            e3 = 0 | (t3 != r3 && e3.getTimezoneOffset() == Math.min(r3, t3)), o()[n2 + 32 >> 2 >>> 0] = e3;
          }, v: function(e3) {
            e3 >>>= 0;
            var t3 = new Date(o()[e3 + 20 >> 2 >>> 0] + 1900, o()[e3 + 16 >> 2 >>> 0], o()[e3 + 12 >> 2 >>> 0], o()[e3 + 8 >> 2 >>> 0], o()[e3 + 4 >> 2 >>> 0], o()[e3 >> 2 >>> 0], 0), n2 = o()[e3 + 32 >> 2 >>> 0], r3 = t3.getTimezoneOffset(), i2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = new Date(t3.getFullYear(), 0, 1).getTimezoneOffset(), s2 = Math.min(a2, i2);
            return 0 > n2 ? o()[e3 + 32 >> 2 >>> 0] = Number(i2 != a2 && s2 == r3) : 0 < n2 != (s2 == r3) && (i2 = Math.max(a2, i2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? s2 : i2) - r3))), o()[e3 + 24 >> 2 >>> 0] = t3.getDay(), n2 = (Ue(t3.getFullYear()) ? Be : Ve)[t3.getMonth()] + t3.getDate() - 1 | 0, o()[e3 + 28 >> 2 >>> 0] = n2, o()[e3 >> 2 >>> 0] = t3.getSeconds(), o()[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), o()[e3 + 8 >> 2 >>> 0] = t3.getHours(), o()[e3 + 12 >> 2 >>> 0] = t3.getDate(), o()[e3 + 16 >> 2 >>> 0] = t3.getMonth(), o()[e3 + 20 >> 2 >>> 0] = t3.getYear(), e3 = t3.getTime() / 1e3, _t((Y = e3, 1 <= +Math.abs(Y) ? 0 < Y ? +Math.floor(Y / 4294967296) >>> 0 : ~~+Math.ceil((Y - +(~~Y >>> 0)) / 4294967296) >>> 0 : 0)), e3 >>> 0;
          }, r: ze, s: Ge, z: function(e3, t3, n2) {
            function r3(e4) {
              return (e4 = e4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e4[1] : "GMT";
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0;
            var a2 = (/* @__PURE__ */ new Date()).getFullYear(), s2 = new Date(a2, 0, 1), u2 = new Date(a2, 6, 1);
            a2 = s2.getTimezoneOffset();
            var l2 = u2.getTimezoneOffset(), c2 = Math.max(a2, l2);
            i()[e3 >> 2 >>> 0] = 60 * c2, o()[t3 >> 2 >>> 0] = Number(a2 != l2), e3 = r3(s2), t3 = r3(u2), e3 = He(e3), t3 = He(t3), l2 < a2 ? (i()[n2 >> 2 >>> 0] = e3, i()[n2 + 4 >> 2 >>> 0] = t3) : (i()[n2 >> 2 >>> 0] = t3, i()[n2 + 4 >> 2 >>> 0] = e3);
          }, c: () => {
            te("");
          }, l: function() {
          }, i: function() {
            return Date.now();
          }, V: () => {
            throw W += 1, "unwind";
          }, B: function() {
            return 4294901760;
          }, e: () => performance.timeOrigin + performance.now(), f: function() {
            return y ? n(3993).cpus().length : navigator.hardwareConcurrency;
          }, K: function(e3, t3, n2, r3) {
            for (he.pb = t3 >>> 0, Ye.length = n2, t3 = r3 >>> 0 >> 3, r3 = 0; r3 < n2; r3++)
              Ye[r3] = a()[t3 + r3 >>> 0];
            return ct[e3].apply(null, Ye);
          }, y: function(e3) {
            e3 >>>= 0;
            var t3 = r2().length;
            if (e3 <= t3 || 4294901760 < e3)
              return false;
            for (var n2 = 1; 4 >= n2; n2 *= 2) {
              var o2 = t3 * (1 + 0.2 / n2);
              o2 = Math.min(o2, e3 + 100663296);
              var i2 = Math;
              o2 = Math.max(e3, o2);
              e: {
                i2 = i2.min.call(i2, 4294901760, o2 + (65536 - o2 % 65536) % 65536) - D.buffer.byteLength + 65535 >>> 16;
                try {
                  D.grow(i2), U();
                  var a2 = 1;
                  break e;
                } catch (e4) {
                }
                a2 = void 0;
              }
              if (a2)
                return true;
            }
            return false;
          }, O: Ze, P: Qe, j: fe, g: et, n: tt, w: nt, m: ot, x: function(e3, t3) {
            return e3 >>>= 0, t3 >>>= 0, it(r2().subarray(e3 >>> 0, e3 + t3 >>> 0)), 0;
          }, a: D || l.wasmMemory, H: lt, d: function(e3, t3, n2, r3) {
            return lt(e3 >>> 0, t3 >>> 0, n2 >>> 0, r3 >>> 0);
          } };
          !function() {
            function e3(e4, t4) {
              return e4 = e4.exports, $ = e4 = function(e5) {
                var t5 = (e6) => () => e6() >>> 0, n2 = (e6) => (t6) => e6(t6) >>> 0;
                return (e5 = Object.assign({}, e5)).__errno_location = t5(e5.__errno_location), e5.pthread_self = t5(e5.pthread_self), e5.malloc = n2(e5.malloc), e5.stackSave = t5(e5.stackSave), e5.stackAlloc = n2(e5.stackAlloc), e5;
              }(e4), he.Ta.push($.sa), V = $.ta, G.unshift($.W), k = t4, ee(), e4;
            }
            var t3 = { a: pt };
            if (Q(), l.instantiateWasm)
              try {
                return l.instantiateWasm(t3, e3);
              } catch (e4) {
                I("Module.instantiateWasm callback failed with error: " + e4), u(e4);
              }
            (function(e4, t4) {
              var n2 = X;
              return A || "function" != typeof WebAssembly.instantiateStreaming || ne(n2) || n2.startsWith("file://") || y || "function" != typeof fetch ? oe(n2, e4, t4) : fetch(n2, { credentials: "same-origin" }).then((r3) => WebAssembly.instantiateStreaming(r3, e4).then(t4, function(r4) {
                return I("wasm streaming compile failed: " + r4), I("falling back to ArrayBuffer instantiation"), oe(n2, e4, t4);
              }));
            })(t3, function(t4) {
              e3(t4.instance, t4.module);
            }).catch(u);
          }(), l._OrtInit = (e3, t3) => (l._OrtInit = $.X)(e3, t3), l._OrtGetLastError = (e3, t3) => (l._OrtGetLastError = $.Y)(e3, t3), l._OrtCreateSessionOptions = (e3, t3, n2, r3, o2, i2, a2, s2, u2, c2) => (l._OrtCreateSessionOptions = $.Z)(e3, t3, n2, r3, o2, i2, a2, s2, u2, c2), l._OrtAppendExecutionProvider = (e3, t3) => (l._OrtAppendExecutionProvider = $._)(e3, t3), l._OrtAddSessionConfigEntry = (e3, t3, n2) => (l._OrtAddSessionConfigEntry = $.$)(e3, t3, n2), l._OrtReleaseSessionOptions = (e3) => (l._OrtReleaseSessionOptions = $.aa)(e3), l._OrtCreateSession = (e3, t3, n2) => (l._OrtCreateSession = $.ba)(e3, t3, n2), l._OrtReleaseSession = (e3) => (l._OrtReleaseSession = $.ca)(e3), l._OrtGetInputOutputCount = (e3, t3, n2) => (l._OrtGetInputOutputCount = $.da)(e3, t3, n2), l._OrtGetInputName = (e3, t3) => (l._OrtGetInputName = $.ea)(e3, t3), l._OrtGetOutputName = (e3, t3) => (l._OrtGetOutputName = $.fa)(e3, t3), l._OrtFree = (e3) => (l._OrtFree = $.ga)(e3), l._OrtCreateTensor = (e3, t3, n2, r3, o2) => (l._OrtCreateTensor = $.ha)(e3, t3, n2, r3, o2), l._OrtGetTensorData = (e3, t3, n2, r3, o2) => (l._OrtGetTensorData = $.ia)(e3, t3, n2, r3, o2), l._OrtReleaseTensor = (e3) => (l._OrtReleaseTensor = $.ja)(e3), l._OrtCreateRunOptions = (e3, t3, n2, r3) => (l._OrtCreateRunOptions = $.ka)(e3, t3, n2, r3), l._OrtAddRunConfigEntry = (e3, t3, n2) => (l._OrtAddRunConfigEntry = $.la)(e3, t3, n2), l._OrtReleaseRunOptions = (e3) => (l._OrtReleaseRunOptions = $.ma)(e3), l._OrtRun = (e3, t3, n2, r3, o2, i2, a2, s2) => (l._OrtRun = $.na)(e3, t3, n2, r3, o2, i2, a2, s2), l._OrtEndProfiling = (e3) => (l._OrtEndProfiling = $.oa)(e3);
          var dt = l._pthread_self = () => (dt = l._pthread_self = $.pa)(), ft = l._malloc = (e3) => (ft = l._malloc = $.qa)(e3);
          l._free = (e3) => (l._free = $.ra)(e3), l.__emscripten_tls_init = () => (l.__emscripten_tls_init = $.sa)();
          var ht = l.__emscripten_thread_init = (e3, t3, n2, r3, o2, i2) => (ht = l.__emscripten_thread_init = $.ua)(e3, t3, n2, r3, o2, i2);
          l.__emscripten_thread_crashed = () => (l.__emscripten_thread_crashed = $.va)();
          var gt, bt = (e3, t3, n2, r3) => (bt = $.wa)(e3, t3, n2, r3), mt = (e3) => (mt = $.xa)(e3), yt = l.__emscripten_thread_exit = (e3) => (yt = l.__emscripten_thread_exit = $.ya)(e3), vt = l.__emscripten_check_mailbox = () => (vt = l.__emscripten_check_mailbox = $.za)(), _t = (e3) => (_t = $.Aa)(e3), wt = (e3, t3) => (wt = $.Ba)(e3, t3), Tt = () => (Tt = $.Ca)(), xt = (e3) => (xt = $.Da)(e3), Ot = (e3) => (Ot = $.Ea)(e3);
          function St() {
            function e3() {
              if (!gt && (gt = true, l.calledRun = true, !M) && (v || ge(G), s(l), l.onRuntimeInitialized && l.onRuntimeInitialized(), !v)) {
                if (l.postRun)
                  for ("function" == typeof l.postRun && (l.postRun = [l.postRun]); l.postRun.length; ) {
                    var e4 = l.postRun.shift();
                    H.unshift(e4);
                  }
                ge(H);
              }
            }
            if (!(0 < K))
              if (v)
                s(l), v || ge(G), startWorker(l);
              else {
                if (l.preRun)
                  for ("function" == typeof l.preRun && (l.preRun = [l.preRun]); l.preRun.length; )
                    z2.unshift(l.preRun.shift());
                ge(z2), 0 < K || (l.setStatus ? (l.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    l.setStatus("");
                  }, 1), e3();
                }, 1)) : e3());
              }
          }
          if (l.keepRuntimeAlive = q, l.wasmMemory = D, l.stackAlloc = Ot, l.stackSave = Tt, l.stackRestore = xt, l.UTF8ToString = pe, l.stringToUTF8 = Se, l.lengthBytesUTF8 = xe, l.ExitStatus = ie, l.PThread = he, Z = function e3() {
            gt || St(), gt || (Z = e3);
          }, l.preInit)
            for ("function" == typeof l.preInit && (l.preInit = [l.preInit]); 0 < l.preInit.length; )
              l.preInit.pop()();
          return St(), e2.ready;
        });
        e.exports = r;
      }, 932: (e, t, n) => {
        var _scriptDir, r = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (_scriptDir = _scriptDir || __filename), function(e2 = {}) {
          var t2, r2, o = e2;
          o.ready = new Promise((e3, n2) => {
            t2 = e3, r2 = n2;
          });
          var i, a, s, u = Object.assign({}, o), l = "./this.program", c = (e3, t3) => {
            throw t3;
          }, p = "object" == typeof window, d = "function" == typeof importScripts, f = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, h = "";
          if (f) {
            var g = n(1384), b = n(908);
            h = d ? b.dirname(h) + "/" : __dirname + "/", i = (e3, t3) => (e3 = e3.startsWith("file://") ? new URL(e3) : b.normalize(e3), g.readFileSync(e3, t3 ? void 0 : "utf8")), s = (e3) => ((e3 = i(e3, true)).buffer || (e3 = new Uint8Array(e3)), e3), a = (e3, t3, n2, r3 = true) => {
              e3 = e3.startsWith("file://") ? new URL(e3) : b.normalize(e3), g.readFile(e3, r3 ? void 0 : "utf8", (e4, o2) => {
                e4 ? n2(e4) : t3(r3 ? o2.buffer : o2);
              });
            }, !o.thisProgram && 1 < process.argv.length && (l = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), c = (e3, t3) => {
              throw process.exitCode = e3, t3;
            }, o.inspect = () => "[Emscripten Module object]";
          } else
            (p || d) && (d ? h = self.location.href : "undefined" != typeof document && document.currentScript && (h = document.currentScript.src), _scriptDir && (h = _scriptDir), h = 0 !== h.indexOf("blob:") ? h.substr(0, h.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", i = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.send(null), t3.responseText;
            }, d && (s = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), a = (e3, t3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", e3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? t3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            });
          var m, y = o.print || console.log.bind(console), v = o.printErr || console.error.bind(console);
          Object.assign(o, u), u = null, o.thisProgram && (l = o.thisProgram), o.quit && (c = o.quit), o.wasmBinary && (m = o.wasmBinary);
          var _ = o.noExitRuntime || true;
          "object" != typeof WebAssembly && j("no native wasm support detected");
          var w, T, x, O, S, A, P = false;
          function I() {
            var e3 = w.buffer;
            o.HEAP8 = x = new Int8Array(e3), o.HEAP16 = new Int16Array(e3), o.HEAP32 = S = new Int32Array(e3), o.HEAPU8 = O = new Uint8Array(e3), o.HEAPU16 = new Uint16Array(e3), o.HEAPU32 = A = new Uint32Array(e3), o.HEAPF32 = new Float32Array(e3), o.HEAPF64 = new Float64Array(e3);
          }
          var E = [], D = [], $ = [];
          function k() {
            var e3 = o.preRun.shift();
            E.unshift(e3);
          }
          var F, N, R = 0, L = null, C = null;
          function j(e3) {
            throw o.onAbort && o.onAbort(e3), v(e3 = "Aborted(" + e3 + ")"), P = true, e3 = new WebAssembly.RuntimeError(e3 + ". Build with -sASSERTIONS for more info."), r2(e3), e3;
          }
          function M(e3) {
            return e3.startsWith("data:application/octet-stream;base64,");
          }
          if (!M(F = "ort-wasm.wasm")) {
            var U = F;
            F = o.locateFile ? o.locateFile(U, h) : h + U;
          }
          function B(e3) {
            if (e3 == F && m)
              return new Uint8Array(m);
            if (s)
              return s(e3);
            throw "both async and sync fetching of the wasm failed";
          }
          function V(e3, t3, n2) {
            return function(e4) {
              if (!m && (p || d)) {
                if ("function" == typeof fetch && !e4.startsWith("file://"))
                  return fetch(e4, { credentials: "same-origin" }).then((t4) => {
                    if (!t4.ok)
                      throw "failed to load wasm binary file at '" + e4 + "'";
                    return t4.arrayBuffer();
                  }).catch(() => B(e4));
                if (a)
                  return new Promise((t4, n3) => {
                    a(e4, (e5) => t4(new Uint8Array(e5)), n3);
                  });
              }
              return Promise.resolve().then(() => B(e4));
            }(e3).then((e4) => WebAssembly.instantiate(e4, t3)).then((e4) => e4).then(n2, (e4) => {
              v("failed to asynchronously prepare wasm: " + e4), j(e4);
            });
          }
          function z2(e3) {
            this.name = "ExitStatus", this.message = `Program terminated with exit(${e3})`, this.status = e3;
          }
          var G = (e3) => {
            for (; 0 < e3.length; )
              e3.shift()(o);
          };
          function H(e3) {
            this.qa = e3 - 24, this.va = function(e4) {
              A[this.qa + 4 >> 2 >>> 0] = e4;
            }, this.ua = function(e4) {
              A[this.qa + 8 >> 2 >>> 0] = e4;
            }, this.sa = function(e4, t3) {
              this.ta(), this.va(e4), this.ua(t3);
            }, this.ta = function() {
              A[this.qa + 16 >> 2 >>> 0] = 0;
            };
          }
          var W, q = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, X = (e3, t3, n2) => {
            var r3 = (t3 >>>= 0) + n2;
            for (n2 = t3; e3[n2] && !(n2 >= r3); )
              ++n2;
            if (16 < n2 - t3 && e3.buffer && q)
              return q.decode(e3.subarray(t3, n2));
            for (r3 = ""; t3 < n2; ) {
              var o2 = e3[t3++];
              if (128 & o2) {
                var i2 = 63 & e3[t3++];
                if (192 == (224 & o2))
                  r3 += String.fromCharCode((31 & o2) << 6 | i2);
                else {
                  var a2 = 63 & e3[t3++];
                  65536 > (o2 = 224 == (240 & o2) ? (15 & o2) << 12 | i2 << 6 | a2 : (7 & o2) << 18 | i2 << 12 | a2 << 6 | 63 & e3[t3++]) ? r3 += String.fromCharCode(o2) : (o2 -= 65536, r3 += String.fromCharCode(55296 | o2 >> 10, 56320 | 1023 & o2));
                }
              } else
                r3 += String.fromCharCode(o2);
            }
            return r3;
          }, Y = (e3, t3) => (e3 >>>= 0) ? X(O, e3, t3) : "", K = (e3) => {
            for (var t3 = 0, n2 = 0; n2 < e3.length; ++n2) {
              var r3 = e3.charCodeAt(n2);
              127 >= r3 ? t3++ : 2047 >= r3 ? t3 += 2 : 55296 <= r3 && 57343 >= r3 ? (t3 += 4, ++n2) : t3 += 3;
            }
            return t3;
          }, J = (e3, t3, n2, r3) => {
            if (!(0 < r3))
              return 0;
            var o2 = n2 >>>= 0;
            r3 = n2 + r3 - 1;
            for (var i2 = 0; i2 < e3.length; ++i2) {
              var a2 = e3.charCodeAt(i2);
              if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++i2)), 127 >= a2) {
                if (n2 >= r3)
                  break;
                t3[n2++ >>> 0] = a2;
              } else {
                if (2047 >= a2) {
                  if (n2 + 1 >= r3)
                    break;
                  t3[n2++ >>> 0] = 192 | a2 >> 6;
                } else {
                  if (65535 >= a2) {
                    if (n2 + 2 >= r3)
                      break;
                    t3[n2++ >>> 0] = 224 | a2 >> 12;
                  } else {
                    if (n2 + 3 >= r3)
                      break;
                    t3[n2++ >>> 0] = 240 | a2 >> 18, t3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                }
                t3[n2++ >>> 0] = 128 | 63 & a2;
              }
            }
            return t3[n2 >>> 0] = 0, n2 - o2;
          }, Z = (e3) => 0 == e3 % 4 && (0 != e3 % 100 || 0 == e3 % 400), Q = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], ee = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], te = (e3) => {
            var t3 = K(e3) + 1, n2 = ce(t3);
            return n2 && J(e3, O, n2, t3), n2;
          }, ne = {}, re = () => {
            if (!W) {
              var e3, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: l || "./this.program" };
              for (e3 in ne)
                void 0 === ne[e3] ? delete t3[e3] : t3[e3] = ne[e3];
              var n2 = [];
              for (e3 in t3)
                n2.push(`${e3}=${t3[e3]}`);
              W = n2;
            }
            return W;
          }, oe = [null, [], []], ie = (e3) => (ie = (() => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
              return (e5) => crypto.getRandomValues(e5);
            if (f)
              try {
                var e4 = n(760);
                if (e4.randomFillSync)
                  return (t4) => e4.randomFillSync(t4);
                var t3 = e4.randomBytes;
                return (e5) => (e5.set(t3(e5.byteLength)), e5);
              } catch (e5) {
              }
            j("initRandomDevice");
          })())(e3), ae = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], se = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function ue(e3, t3, n2, r3) {
            function o2(e4, t4, n3) {
              for (e4 = "number" == typeof e4 ? e4.toString() : e4 || ""; e4.length < t4; )
                e4 = n3[0] + e4;
              return e4;
            }
            function i2(e4, t4) {
              return o2(e4, t4, "0");
            }
            function a2(e4, t4) {
              function n3(e5) {
                return 0 > e5 ? -1 : 0 < e5 ? 1 : 0;
              }
              var r4;
              return 0 === (r4 = n3(e4.getFullYear() - t4.getFullYear())) && 0 === (r4 = n3(e4.getMonth() - t4.getMonth())) && (r4 = n3(e4.getDate() - t4.getDate())), r4;
            }
            function s2(e4) {
              switch (e4.getDay()) {
                case 0:
                  return new Date(e4.getFullYear() - 1, 11, 29);
                case 1:
                  return e4;
                case 2:
                  return new Date(e4.getFullYear(), 0, 3);
                case 3:
                  return new Date(e4.getFullYear(), 0, 2);
                case 4:
                  return new Date(e4.getFullYear(), 0, 1);
                case 5:
                  return new Date(e4.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(e4.getFullYear() - 1, 11, 30);
              }
            }
            function u2(e4) {
              var t4 = e4.ma;
              for (e4 = new Date(new Date(e4.na + 1900, 0, 1).getTime()); 0 < t4; ) {
                var n3 = e4.getMonth(), r4 = (Z(e4.getFullYear()) ? ae : se)[n3];
                if (!(t4 > r4 - e4.getDate())) {
                  e4.setDate(e4.getDate() + t4);
                  break;
                }
                t4 -= r4 - e4.getDate() + 1, e4.setDate(1), 11 > n3 ? e4.setMonth(n3 + 1) : (e4.setMonth(0), e4.setFullYear(e4.getFullYear() + 1));
              }
              return n3 = new Date(e4.getFullYear() + 1, 0, 4), t4 = s2(new Date(e4.getFullYear(), 0, 4)), n3 = s2(n3), 0 >= a2(t4, e4) ? 0 >= a2(n3, e4) ? e4.getFullYear() + 1 : e4.getFullYear() : e4.getFullYear() - 1;
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0;
            var l2 = S[40 + (r3 >>>= 0) >> 2 >>> 0];
            for (var c2 in r3 = { ya: S[r3 >> 2 >>> 0], xa: S[r3 + 4 >> 2 >>> 0], oa: S[r3 + 8 >> 2 >>> 0], ra: S[r3 + 12 >> 2 >>> 0], pa: S[r3 + 16 >> 2 >>> 0], na: S[r3 + 20 >> 2 >>> 0], ha: S[r3 + 24 >> 2 >>> 0], ma: S[r3 + 28 >> 2 >>> 0], Aa: S[r3 + 32 >> 2 >>> 0], wa: S[r3 + 36 >> 2 >>> 0], za: l2 ? Y(l2) : "" }, n2 = Y(n2), l2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
              n2 = n2.replace(new RegExp(c2, "g"), l2[c2]);
            var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), d2 = "January February March April May June July August September October November December".split(" ");
            for (c2 in l2 = { "%a": (e4) => p2[e4.ha].substring(0, 3), "%A": (e4) => p2[e4.ha], "%b": (e4) => d2[e4.pa].substring(0, 3), "%B": (e4) => d2[e4.pa], "%C": (e4) => i2((e4.na + 1900) / 100 | 0, 2), "%d": (e4) => i2(e4.ra, 2), "%e": (e4) => o2(e4.ra, 2, " "), "%g": (e4) => u2(e4).toString().substring(2), "%G": (e4) => u2(e4), "%H": (e4) => i2(e4.oa, 2), "%I": (e4) => (0 == (e4 = e4.oa) ? e4 = 12 : 12 < e4 && (e4 -= 12), i2(e4, 2)), "%j": (e4) => {
              for (var t4 = 0, n3 = 0; n3 <= e4.pa - 1; t4 += (Z(e4.na + 1900) ? ae : se)[n3++])
                ;
              return i2(e4.ra + t4, 3);
            }, "%m": (e4) => i2(e4.pa + 1, 2), "%M": (e4) => i2(e4.xa, 2), "%n": () => "\n", "%p": (e4) => 0 <= e4.oa && 12 > e4.oa ? "AM" : "PM", "%S": (e4) => i2(e4.ya, 2), "%t": () => "	", "%u": (e4) => e4.ha || 7, "%U": (e4) => i2(Math.floor((e4.ma + 7 - e4.ha) / 7), 2), "%V": (e4) => {
              var t4 = Math.floor((e4.ma + 7 - (e4.ha + 6) % 7) / 7);
              if (2 >= (e4.ha + 371 - e4.ma - 2) % 7 && t4++, t4)
                53 == t4 && (4 == (n3 = (e4.ha + 371 - e4.ma) % 7) || 3 == n3 && Z(e4.na) || (t4 = 1));
              else {
                t4 = 52;
                var n3 = (e4.ha + 7 - e4.ma - 1) % 7;
                (4 == n3 || 5 == n3 && Z(e4.na % 400 - 1)) && t4++;
              }
              return i2(t4, 2);
            }, "%w": (e4) => e4.ha, "%W": (e4) => i2(Math.floor((e4.ma + 7 - (e4.ha + 6) % 7) / 7), 2), "%y": (e4) => (e4.na + 1900).toString().substring(2), "%Y": (e4) => e4.na + 1900, "%z": (e4) => {
              var t4 = 0 <= (e4 = e4.wa);
              return e4 = Math.abs(e4) / 60, (t4 ? "+" : "-") + String("0000" + (e4 / 60 * 100 + e4 % 60)).slice(-4);
            }, "%Z": (e4) => e4.za, "%%": () => "%" }, n2 = n2.replace(/%%/g, "\0\0"), l2)
              n2.includes(c2) && (n2 = n2.replace(new RegExp(c2, "g"), l2[c2](r3)));
            return c2 = function(e4) {
              var t4 = Array(K(e4) + 1);
              return J(e4, t4, 0, t4.length), t4;
            }(n2 = n2.replace(/\0\0/g, "%")), c2.length > t3 ? 0 : (x.set(c2, e3 >>> 0), c2.length - 1);
          }
          var le = { a: function(e3, t3, n2) {
            throw new H(e3 >>>= 0).sa(t3 >>> 0, n2 >>> 0), e3;
          }, e: function() {
            return 0;
          }, I: function() {
          }, y: function() {
          }, A: function() {
          }, K: function() {
            return 0;
          }, G: function() {
          }, B: function() {
          }, F: function() {
          }, g: function() {
          }, z: function() {
          }, w: function() {
          }, H: function() {
          }, x: function() {
          }, k: () => true, n: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), S[n2 >> 2 >>> 0] = e3.getUTCSeconds(), S[n2 + 4 >> 2 >>> 0] = e3.getUTCMinutes(), S[n2 + 8 >> 2 >>> 0] = e3.getUTCHours(), S[n2 + 12 >> 2 >>> 0] = e3.getUTCDate(), S[n2 + 16 >> 2 >>> 0] = e3.getUTCMonth(), S[n2 + 20 >> 2 >>> 0] = e3.getUTCFullYear() - 1900, S[n2 + 24 >> 2 >>> 0] = e3.getUTCDay(), S[n2 + 28 >> 2 >>> 0] = (e3.getTime() - Date.UTC(e3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
          }, o: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), S[n2 >> 2 >>> 0] = e3.getSeconds(), S[n2 + 4 >> 2 >>> 0] = e3.getMinutes(), S[n2 + 8 >> 2 >>> 0] = e3.getHours(), S[n2 + 12 >> 2 >>> 0] = e3.getDate(), S[n2 + 16 >> 2 >>> 0] = e3.getMonth(), S[n2 + 20 >> 2 >>> 0] = e3.getFullYear() - 1900, S[n2 + 24 >> 2 >>> 0] = e3.getDay(), S[n2 + 28 >> 2 >>> 0] = (Z(e3.getFullYear()) ? Q : ee)[e3.getMonth()] + e3.getDate() - 1 | 0, S[n2 + 36 >> 2 >>> 0] = -60 * e3.getTimezoneOffset(), t3 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset();
            var r3 = new Date(e3.getFullYear(), 0, 1).getTimezoneOffset();
            S[n2 + 32 >> 2 >>> 0] = 0 | (t3 != r3 && e3.getTimezoneOffset() == Math.min(r3, t3));
          }, p: function(e3) {
            e3 >>>= 0;
            var t3 = new Date(S[e3 + 20 >> 2 >>> 0] + 1900, S[e3 + 16 >> 2 >>> 0], S[e3 + 12 >> 2 >>> 0], S[e3 + 8 >> 2 >>> 0], S[e3 + 4 >> 2 >>> 0], S[e3 >> 2 >>> 0], 0), n2 = S[e3 + 32 >> 2 >>> 0], r3 = t3.getTimezoneOffset(), o2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), i2 = new Date(t3.getFullYear(), 0, 1).getTimezoneOffset(), a2 = Math.min(i2, o2);
            return 0 > n2 ? S[e3 + 32 >> 2 >>> 0] = Number(o2 != i2 && a2 == r3) : 0 < n2 != (a2 == r3) && (o2 = Math.max(i2, o2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? a2 : o2) - r3))), S[e3 + 24 >> 2 >>> 0] = t3.getDay(), S[e3 + 28 >> 2 >>> 0] = (Z(t3.getFullYear()) ? Q : ee)[t3.getMonth()] + t3.getDate() - 1 | 0, S[e3 >> 2 >>> 0] = t3.getSeconds(), S[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), S[e3 + 8 >> 2 >>> 0] = t3.getHours(), S[e3 + 12 >> 2 >>> 0] = t3.getDate(), S[e3 + 16 >> 2 >>> 0] = t3.getMonth(), S[e3 + 20 >> 2 >>> 0] = t3.getYear(), e3 = t3.getTime() / 1e3, de((N = e3, 1 <= +Math.abs(N) ? 0 < N ? +Math.floor(N / 4294967296) >>> 0 : ~~+Math.ceil((N - +(~~N >>> 0)) / 4294967296) >>> 0 : 0)), e3 >>> 0;
          }, l: function() {
            return -52;
          }, m: function() {
          }, u: function(e3, t3, n2) {
            function r3(e4) {
              return (e4 = e4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e4[1] : "GMT";
            }
            n2 >>>= 0;
            var o2 = (/* @__PURE__ */ new Date()).getFullYear(), i2 = new Date(o2, 0, 1), a2 = new Date(o2, 6, 1);
            o2 = i2.getTimezoneOffset();
            var s2 = a2.getTimezoneOffset();
            A[e3 >>> 0 >> 2 >>> 0] = 60 * Math.max(o2, s2), S[t3 >>> 0 >> 2 >>> 0] = Number(o2 != s2), e3 = r3(i2), t3 = r3(a2), e3 = te(e3), t3 = te(t3), s2 < o2 ? (A[n2 >> 2 >>> 0] = e3, A[n2 + 4 >> 2 >>> 0] = t3) : (A[n2 >> 2 >>> 0] = t3, A[n2 + 4 >> 2 >>> 0] = e3);
          }, d: () => {
            j("");
          }, h: function() {
            return Date.now();
          }, v: function() {
            return 4294901760;
          }, b: () => performance.now(), J: function(e3, t3, n2) {
            return t3 >>>= 0, O.copyWithin(e3 >>> 0 >>> 0, t3 >>> 0, t3 + (n2 >>> 0) >>> 0);
          }, t: function(e3) {
            e3 >>>= 0;
            var t3 = O.length;
            if (4294901760 < e3)
              return false;
            for (var n2 = 1; 4 >= n2; n2 *= 2) {
              var r3 = t3 * (1 + 0.2 / n2);
              r3 = Math.min(r3, e3 + 100663296);
              var o2 = Math;
              r3 = Math.max(e3, r3);
              e: {
                o2 = o2.min.call(o2, 4294901760, r3 + (65536 - r3 % 65536) % 65536) - w.buffer.byteLength + 65535 >>> 16;
                try {
                  w.grow(o2), I();
                  var i2 = 1;
                  break e;
                } catch (e4) {
                }
                i2 = void 0;
              }
              if (i2)
                return true;
            }
            return false;
          }, D: function(e3, t3) {
            e3 >>>= 0, t3 >>>= 0;
            var n2 = 0;
            return re().forEach(function(r3, o2) {
              var i2 = t3 + n2;
              for (o2 = A[e3 + 4 * o2 >> 2 >>> 0] = i2, i2 = 0; i2 < r3.length; ++i2)
                x[o2++ >> 0 >>> 0] = r3.charCodeAt(i2);
              x[o2 >> 0 >>> 0] = 0, n2 += r3.length + 1;
            }), 0;
          }, E: function(e3, t3) {
            e3 >>>= 0, t3 >>>= 0;
            var n2 = re();
            A[e3 >> 2 >>> 0] = n2.length;
            var r3 = 0;
            return n2.forEach(function(e4) {
              r3 += e4.length + 1;
            }), A[t3 >> 2 >>> 0] = r3, 0;
          }, s: (e3) => {
            _ || (o.onExit && o.onExit(e3), P = true), c(e3, new z2(e3));
          }, f: () => 52, j: function() {
            return 52;
          }, q: function() {
            return 70;
          }, i: function(e3, t3, n2, r3) {
            t3 >>>= 0, n2 >>>= 0, r3 >>>= 0;
            for (var o2 = 0, i2 = 0; i2 < n2; i2++) {
              var a2 = A[t3 >> 2 >>> 0], s2 = A[t3 + 4 >> 2 >>> 0];
              t3 += 8;
              for (var u2 = 0; u2 < s2; u2++) {
                var l2 = O[a2 + u2 >>> 0], c2 = oe[e3];
                0 === l2 || 10 === l2 ? ((1 === e3 ? y : v)(X(c2, 0)), c2.length = 0) : c2.push(l2);
              }
              o2 += s2;
            }
            return A[r3 >> 2 >>> 0] = o2, 0;
          }, r: function(e3, t3) {
            return e3 >>>= 0, ie(O.subarray(e3 >>> 0, e3 + (t3 >>> 0) >>> 0)), 0;
          }, C: ue, c: function(e3, t3, n2, r3) {
            return ue(e3 >>> 0, t3 >>> 0, n2 >>> 0, r3 >>> 0);
          } };
          !function() {
            function e3(e4) {
              if (e4 = e4.exports, T = e4 = function(e5) {
                var t5 = (e6) => () => e6() >>> 0, n2 = (e6) => (t6) => e6(t6) >>> 0;
                return (e5 = Object.assign({}, e5)).__errno_location = t5(e5.__errno_location), e5.malloc = n2(e5.malloc), e5.stackSave = t5(e5.stackSave), e5.stackAlloc = n2(e5.stackAlloc), e5;
              }(e4), w = T.L, I(), D.unshift(T.M), R--, o.monitorRunDependencies && o.monitorRunDependencies(R), 0 == R && (null !== L && (clearInterval(L), L = null), C)) {
                var t4 = C;
                C = null, t4();
              }
              return e4;
            }
            var t3 = { a: le };
            if (R++, o.monitorRunDependencies && o.monitorRunDependencies(R), o.instantiateWasm)
              try {
                return o.instantiateWasm(t3, e3);
              } catch (e4) {
                v("Module.instantiateWasm callback failed with error: " + e4), r2(e4);
              }
            (function(e4, t4) {
              var n2 = F;
              return m || "function" != typeof WebAssembly.instantiateStreaming || M(n2) || n2.startsWith("file://") || f || "function" != typeof fetch ? V(n2, e4, t4) : fetch(n2, { credentials: "same-origin" }).then((r3) => WebAssembly.instantiateStreaming(r3, e4).then(t4, function(r4) {
                return v("wasm streaming compile failed: " + r4), v("falling back to ArrayBuffer instantiation"), V(n2, e4, t4);
              }));
            })(t3, function(t4) {
              e3(t4.instance);
            }).catch(r2);
          }(), o._OrtInit = (e3, t3) => (o._OrtInit = T.N)(e3, t3), o._OrtGetLastError = (e3, t3) => (o._OrtGetLastError = T.O)(e3, t3), o._OrtCreateSessionOptions = (e3, t3, n2, r3, i2, a2, s2, u2, l2, c2) => (o._OrtCreateSessionOptions = T.P)(e3, t3, n2, r3, i2, a2, s2, u2, l2, c2), o._OrtAppendExecutionProvider = (e3, t3) => (o._OrtAppendExecutionProvider = T.Q)(e3, t3), o._OrtAddSessionConfigEntry = (e3, t3, n2) => (o._OrtAddSessionConfigEntry = T.R)(e3, t3, n2), o._OrtReleaseSessionOptions = (e3) => (o._OrtReleaseSessionOptions = T.S)(e3), o._OrtCreateSession = (e3, t3, n2) => (o._OrtCreateSession = T.T)(e3, t3, n2), o._OrtReleaseSession = (e3) => (o._OrtReleaseSession = T.U)(e3), o._OrtGetInputOutputCount = (e3, t3, n2) => (o._OrtGetInputOutputCount = T.V)(e3, t3, n2), o._OrtGetInputName = (e3, t3) => (o._OrtGetInputName = T.W)(e3, t3), o._OrtGetOutputName = (e3, t3) => (o._OrtGetOutputName = T.X)(e3, t3), o._OrtFree = (e3) => (o._OrtFree = T.Y)(e3), o._OrtCreateTensor = (e3, t3, n2, r3, i2) => (o._OrtCreateTensor = T.Z)(e3, t3, n2, r3, i2), o._OrtGetTensorData = (e3, t3, n2, r3, i2) => (o._OrtGetTensorData = T._)(e3, t3, n2, r3, i2), o._OrtReleaseTensor = (e3) => (o._OrtReleaseTensor = T.$)(e3), o._OrtCreateRunOptions = (e3, t3, n2, r3) => (o._OrtCreateRunOptions = T.aa)(e3, t3, n2, r3), o._OrtAddRunConfigEntry = (e3, t3, n2) => (o._OrtAddRunConfigEntry = T.ba)(e3, t3, n2), o._OrtReleaseRunOptions = (e3) => (o._OrtReleaseRunOptions = T.ca)(e3), o._OrtRun = (e3, t3, n2, r3, i2, a2, s2, u2) => (o._OrtRun = T.da)(e3, t3, n2, r3, i2, a2, s2, u2), o._OrtEndProfiling = (e3) => (o._OrtEndProfiling = T.ea)(e3);
          var ce = o._malloc = (e3) => (ce = o._malloc = T.fa)(e3);
          o._free = (e3) => (o._free = T.ga)(e3);
          var pe, de = (e3) => (de = T.ia)(e3), fe = () => (fe = T.ja)(), he = (e3) => (he = T.ka)(e3), ge = (e3) => (ge = T.la)(e3);
          function be() {
            function e3() {
              if (!pe && (pe = true, o.calledRun = true, !P)) {
                if (G(D), t2(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), o.postRun)
                  for ("function" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length; ) {
                    var e4 = o.postRun.shift();
                    $.unshift(e4);
                  }
                G($);
              }
            }
            if (!(0 < R)) {
              if (o.preRun)
                for ("function" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length; )
                  k();
              G(E), 0 < R || (o.setStatus ? (o.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  o.setStatus("");
                }, 1), e3();
              }, 1)) : e3());
            }
          }
          if (o.stackAlloc = ge, o.stackSave = fe, o.stackRestore = he, o.UTF8ToString = Y, o.stringToUTF8 = (e3, t3, n2) => J(e3, O, t3, n2), o.lengthBytesUTF8 = K, C = function e3() {
            pe || be(), pe || (C = e3);
          }, o.preInit)
            for ("function" == typeof o.preInit && (o.preInit = [o.preInit]); 0 < o.preInit.length; )
              o.preInit.pop()();
          return be(), e2.ready;
        });
        e.exports = r;
      }, 4537: (e) => {
        "use strict";
        e.exports = function(e2, t) {
          for (var n = new Array(arguments.length - 1), r = 0, o = 2, i = true; o < arguments.length; )
            n[r++] = arguments[o++];
          return new Promise(function(o2, a) {
            n[r] = function(e3) {
              if (i)
                if (i = false, e3)
                  a(e3);
                else {
                  for (var t2 = new Array(arguments.length - 1), n2 = 0; n2 < t2.length; )
                    t2[n2++] = arguments[n2];
                  o2.apply(null, t2);
                }
            };
            try {
              e2.apply(t || null, n);
            } catch (e3) {
              i && (i = false, a(e3));
            }
          });
        };
      }, 7419: (e, t) => {
        "use strict";
        var n = t;
        n.length = function(e2) {
          var t2 = e2.length;
          if (!t2)
            return 0;
          for (var n2 = 0; --t2 % 4 > 1 && "=" === e2.charAt(t2); )
            ++n2;
          return Math.ceil(3 * e2.length) / 4 - n2;
        };
        for (var r = new Array(64), o = new Array(123), i = 0; i < 64; )
          o[r[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
        n.encode = function(e2, t2, n2) {
          for (var o2, i2 = null, a2 = [], s = 0, u = 0; t2 < n2; ) {
            var l = e2[t2++];
            switch (u) {
              case 0:
                a2[s++] = r[l >> 2], o2 = (3 & l) << 4, u = 1;
                break;
              case 1:
                a2[s++] = r[o2 | l >> 4], o2 = (15 & l) << 2, u = 2;
                break;
              case 2:
                a2[s++] = r[o2 | l >> 6], a2[s++] = r[63 & l], u = 0;
            }
            s > 8191 && ((i2 || (i2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
          }
          return u && (a2[s++] = r[o2], a2[s++] = 61, 1 === u && (a2[s++] = 61)), i2 ? (s && i2.push(String.fromCharCode.apply(String, a2.slice(0, s))), i2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
        };
        var a = "invalid encoding";
        n.decode = function(e2, t2, n2) {
          for (var r2, i2 = n2, s = 0, u = 0; u < e2.length; ) {
            var l = e2.charCodeAt(u++);
            if (61 === l && s > 1)
              break;
            if (void 0 === (l = o[l]))
              throw Error(a);
            switch (s) {
              case 0:
                r2 = l, s = 1;
                break;
              case 1:
                t2[n2++] = r2 << 2 | (48 & l) >> 4, r2 = l, s = 2;
                break;
              case 2:
                t2[n2++] = (15 & r2) << 4 | (60 & l) >> 2, r2 = l, s = 3;
                break;
              case 3:
                t2[n2++] = (3 & r2) << 6 | l, s = 0;
            }
          }
          if (1 === s)
            throw Error(a);
          return n2 - i2;
        }, n.test = function(e2) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e2);
        };
      }, 9211: (e) => {
        "use strict";
        function t() {
          this._listeners = {};
        }
        e.exports = t, t.prototype.on = function(e2, t2, n) {
          return (this._listeners[e2] || (this._listeners[e2] = [])).push({ fn: t2, ctx: n || this }), this;
        }, t.prototype.off = function(e2, t2) {
          if (void 0 === e2)
            this._listeners = {};
          else if (void 0 === t2)
            this._listeners[e2] = [];
          else
            for (var n = this._listeners[e2], r = 0; r < n.length; )
              n[r].fn === t2 ? n.splice(r, 1) : ++r;
          return this;
        }, t.prototype.emit = function(e2) {
          var t2 = this._listeners[e2];
          if (t2) {
            for (var n = [], r = 1; r < arguments.length; )
              n.push(arguments[r++]);
            for (r = 0; r < t2.length; )
              t2[r].fn.apply(t2[r++].ctx, n);
          }
          return this;
        };
      }, 945: (e) => {
        "use strict";
        function t(e2) {
          return "undefined" != typeof Float32Array ? function() {
            var t2 = new Float32Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[3];
            function o2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[0], r3[o3 + 1] = n2[1], r3[o3 + 2] = n2[2], r3[o3 + 3] = n2[3];
            }
            function i2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[3], r3[o3 + 1] = n2[2], r3[o3 + 2] = n2[1], r3[o3 + 3] = n2[0];
            }
            function a(e3, r3) {
              return n2[0] = e3[r3], n2[1] = e3[r3 + 1], n2[2] = e3[r3 + 2], n2[3] = e3[r3 + 3], t2[0];
            }
            function s(e3, r3) {
              return n2[3] = e3[r3], n2[2] = e3[r3 + 1], n2[1] = e3[r3 + 2], n2[0] = e3[r3 + 3], t2[0];
            }
            e2.writeFloatLE = r2 ? o2 : i2, e2.writeFloatBE = r2 ? i2 : o2, e2.readFloatLE = r2 ? a : s, e2.readFloatBE = r2 ? s : a;
          }() : function() {
            function t2(e3, t3, n2, r2) {
              var o2 = t3 < 0 ? 1 : 0;
              if (o2 && (t3 = -t3), 0 === t3)
                e3(1 / t3 > 0 ? 0 : 2147483648, n2, r2);
              else if (isNaN(t3))
                e3(2143289344, n2, r2);
              else if (t3 > 34028234663852886e22)
                e3((o2 << 31 | 2139095040) >>> 0, n2, r2);
              else if (t3 < 11754943508222875e-54)
                e3((o2 << 31 | Math.round(t3 / 1401298464324817e-60)) >>> 0, n2, r2);
              else {
                var i2 = Math.floor(Math.log(t3) / Math.LN2);
                e3((o2 << 31 | i2 + 127 << 23 | 8388607 & Math.round(t3 * Math.pow(2, -i2) * 8388608)) >>> 0, n2, r2);
              }
            }
            function a(e3, t3, n2) {
              var r2 = e3(t3, n2), o2 = 2 * (r2 >> 31) + 1, i2 = r2 >>> 23 & 255, a2 = 8388607 & r2;
              return 255 === i2 ? a2 ? NaN : o2 * (1 / 0) : 0 === i2 ? 1401298464324817e-60 * o2 * a2 : o2 * Math.pow(2, i2 - 150) * (a2 + 8388608);
            }
            e2.writeFloatLE = t2.bind(null, n), e2.writeFloatBE = t2.bind(null, r), e2.readFloatLE = a.bind(null, o), e2.readFloatBE = a.bind(null, i);
          }(), "undefined" != typeof Float64Array ? function() {
            var t2 = new Float64Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[7];
            function o2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[0], r3[o3 + 1] = n2[1], r3[o3 + 2] = n2[2], r3[o3 + 3] = n2[3], r3[o3 + 4] = n2[4], r3[o3 + 5] = n2[5], r3[o3 + 6] = n2[6], r3[o3 + 7] = n2[7];
            }
            function i2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[7], r3[o3 + 1] = n2[6], r3[o3 + 2] = n2[5], r3[o3 + 3] = n2[4], r3[o3 + 4] = n2[3], r3[o3 + 5] = n2[2], r3[o3 + 6] = n2[1], r3[o3 + 7] = n2[0];
            }
            function a(e3, r3) {
              return n2[0] = e3[r3], n2[1] = e3[r3 + 1], n2[2] = e3[r3 + 2], n2[3] = e3[r3 + 3], n2[4] = e3[r3 + 4], n2[5] = e3[r3 + 5], n2[6] = e3[r3 + 6], n2[7] = e3[r3 + 7], t2[0];
            }
            function s(e3, r3) {
              return n2[7] = e3[r3], n2[6] = e3[r3 + 1], n2[5] = e3[r3 + 2], n2[4] = e3[r3 + 3], n2[3] = e3[r3 + 4], n2[2] = e3[r3 + 5], n2[1] = e3[r3 + 6], n2[0] = e3[r3 + 7], t2[0];
            }
            e2.writeDoubleLE = r2 ? o2 : i2, e2.writeDoubleBE = r2 ? i2 : o2, e2.readDoubleLE = r2 ? a : s, e2.readDoubleBE = r2 ? s : a;
          }() : function() {
            function t2(e3, t3, n2, r2, o2, i2) {
              var a2 = r2 < 0 ? 1 : 0;
              if (a2 && (r2 = -r2), 0 === r2)
                e3(0, o2, i2 + t3), e3(1 / r2 > 0 ? 0 : 2147483648, o2, i2 + n2);
              else if (isNaN(r2))
                e3(0, o2, i2 + t3), e3(2146959360, o2, i2 + n2);
              else if (r2 > 17976931348623157e292)
                e3(0, o2, i2 + t3), e3((a2 << 31 | 2146435072) >>> 0, o2, i2 + n2);
              else {
                var s;
                if (r2 < 22250738585072014e-324)
                  e3((s = r2 / 5e-324) >>> 0, o2, i2 + t3), e3((a2 << 31 | s / 4294967296) >>> 0, o2, i2 + n2);
                else {
                  var u = Math.floor(Math.log(r2) / Math.LN2);
                  1024 === u && (u = 1023), e3(4503599627370496 * (s = r2 * Math.pow(2, -u)) >>> 0, o2, i2 + t3), e3((a2 << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, o2, i2 + n2);
                }
              }
            }
            function a(e3, t3, n2, r2, o2) {
              var i2 = e3(r2, o2 + t3), a2 = e3(r2, o2 + n2), s = 2 * (a2 >> 31) + 1, u = a2 >>> 20 & 2047, l = 4294967296 * (1048575 & a2) + i2;
              return 2047 === u ? l ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * l : s * Math.pow(2, u - 1075) * (l + 4503599627370496);
            }
            e2.writeDoubleLE = t2.bind(null, n, 0, 4), e2.writeDoubleBE = t2.bind(null, r, 4, 0), e2.readDoubleLE = a.bind(null, o, 0, 4), e2.readDoubleBE = a.bind(null, i, 4, 0);
          }(), e2;
        }
        function n(e2, t2, n2) {
          t2[n2] = 255 & e2, t2[n2 + 1] = e2 >>> 8 & 255, t2[n2 + 2] = e2 >>> 16 & 255, t2[n2 + 3] = e2 >>> 24;
        }
        function r(e2, t2, n2) {
          t2[n2] = e2 >>> 24, t2[n2 + 1] = e2 >>> 16 & 255, t2[n2 + 2] = e2 >>> 8 & 255, t2[n2 + 3] = 255 & e2;
        }
        function o(e2, t2) {
          return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
        }
        function i(e2, t2) {
          return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
        }
        e.exports = t(t);
      }, 7199: (module) => {
        "use strict";
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
              return mod;
          } catch (e) {
          }
          return null;
        }
        module.exports = inquire;
      }, 6662: (e) => {
        "use strict";
        e.exports = function(e2, t, n) {
          var r = n || 8192, o = r >>> 1, i = null, a = r;
          return function(n2) {
            if (n2 < 1 || n2 > o)
              return e2(n2);
            a + n2 > r && (i = e2(r), a = 0);
            var s = t.call(i, a, a += n2);
            return 7 & a && (a = 1 + (7 | a)), s;
          };
        };
      }, 4997: (e, t) => {
        "use strict";
        var n = t;
        n.length = function(e2) {
          for (var t2 = 0, n2 = 0, r = 0; r < e2.length; ++r)
            (n2 = e2.charCodeAt(r)) < 128 ? t2 += 1 : n2 < 2048 ? t2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & e2.charCodeAt(r + 1)) ? (++r, t2 += 4) : t2 += 3;
          return t2;
        }, n.read = function(e2, t2, n2) {
          if (n2 - t2 < 1)
            return "";
          for (var r, o = null, i = [], a = 0; t2 < n2; )
            (r = e2[t2++]) < 128 ? i[a++] = r : r > 191 && r < 224 ? i[a++] = (31 & r) << 6 | 63 & e2[t2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e2[t2++]) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++]) - 65536, i[a++] = 55296 + (r >> 10), i[a++] = 56320 + (1023 & r)) : i[a++] = (15 & r) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++], a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), a = 0);
          return o ? (a && o.push(String.fromCharCode.apply(String, i.slice(0, a))), o.join("")) : String.fromCharCode.apply(String, i.slice(0, a));
        }, n.write = function(e2, t2, n2) {
          for (var r, o, i = n2, a = 0; a < e2.length; ++a)
            (r = e2.charCodeAt(a)) < 128 ? t2[n2++] = r : r < 2048 ? (t2[n2++] = r >> 6 | 192, t2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (o = e2.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & o), ++a, t2[n2++] = r >> 18 | 240, t2[n2++] = r >> 12 & 63 | 128, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128) : (t2[n2++] = r >> 12 | 224, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128);
          return n2 - i;
        };
      }, 3442: (e, t) => {
        "use strict";
        t.__esModule = true;
        var n = function() {
          function e2(t2) {
            if (!t2)
              throw new TypeError("Invalid argument; `value` has no value.");
            this.value = e2.EMPTY, t2 && e2.isGuid(t2) && (this.value = t2);
          }
          return e2.isGuid = function(t2) {
            var n2 = t2.toString();
            return t2 && (t2 instanceof e2 || e2.validator.test(n2));
          }, e2.create = function() {
            return new e2([e2.gen(2), e2.gen(1), e2.gen(1), e2.gen(1), e2.gen(3)].join("-"));
          }, e2.createEmpty = function() {
            return new e2("emptyguid");
          }, e2.parse = function(t2) {
            return new e2(t2);
          }, e2.raw = function() {
            return [e2.gen(2), e2.gen(1), e2.gen(1), e2.gen(1), e2.gen(3)].join("-");
          }, e2.gen = function(e3) {
            for (var t2 = "", n2 = 0; n2 < e3; n2++)
              t2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
            return t2;
          }, e2.prototype.equals = function(t2) {
            return e2.isGuid(t2) && this.value === t2.toString();
          }, e2.prototype.isEmpty = function() {
            return this.value === e2.EMPTY;
          }, e2.prototype.toString = function() {
            return this.value;
          }, e2.prototype.toJSON = function() {
            return { value: this.value };
          }, e2.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), e2.EMPTY = "00000000-0000-0000-0000-000000000000", e2;
        }();
        t.Guid = n;
      }, 2100: (e, t, n) => {
        "use strict";
        e.exports = n(9482);
      }, 9482: (e, t, n) => {
        "use strict";
        var r = t;
        function o() {
          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
        }
        r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = o, o();
      }, 1408: (e, t, n) => {
        "use strict";
        e.exports = u;
        var r, o = n(9693), i = o.LongBits, a = o.utf8;
        function s(e2, t2) {
          return RangeError("index out of range: " + e2.pos + " + " + (t2 || 1) + " > " + e2.len);
        }
        function u(e2) {
          this.buf = e2, this.pos = 0, this.len = e2.length;
        }
        var l, c = "undefined" != typeof Uint8Array ? function(e2) {
          if (e2 instanceof Uint8Array || Array.isArray(e2))
            return new u(e2);
          throw Error("illegal buffer");
        } : function(e2) {
          if (Array.isArray(e2))
            return new u(e2);
          throw Error("illegal buffer");
        }, p = function() {
          return o.Buffer ? function(e2) {
            return (u.create = function(e3) {
              return o.Buffer.isBuffer(e3) ? new r(e3) : c(e3);
            })(e2);
          } : c;
        };
        function d() {
          var e2 = new i(0, 0), t2 = 0;
          if (!(this.len - this.pos > 4)) {
            for (; t2 < 3; ++t2) {
              if (this.pos >= this.len)
                throw s(this);
              if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128)
                return e2;
            }
            return e2.lo = (e2.lo | (127 & this.buf[this.pos++]) << 7 * t2) >>> 0, e2;
          }
          for (; t2 < 4; ++t2)
            if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128)
              return e2;
          if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e2.hi = (e2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
            return e2;
          if (t2 = 0, this.len - this.pos > 4) {
            for (; t2 < 5; ++t2)
              if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128)
                return e2;
          } else
            for (; t2 < 5; ++t2) {
              if (this.pos >= this.len)
                throw s(this);
              if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128)
                return e2;
            }
          throw Error("invalid varint encoding");
        }
        function f(e2, t2) {
          return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
        }
        function h() {
          if (this.pos + 8 > this.len)
            throw s(this, 8);
          return new i(f(this.buf, this.pos += 4), f(this.buf, this.pos += 4));
        }
        u.create = p(), u.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, u.prototype.uint32 = (l = 4294967295, function() {
          if (l = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if ((this.pos += 5) > this.len)
            throw this.pos = this.len, s(this, 10);
          return l;
        }), u.prototype.int32 = function() {
          return 0 | this.uint32();
        }, u.prototype.sint32 = function() {
          var e2 = this.uint32();
          return e2 >>> 1 ^ -(1 & e2) | 0;
        }, u.prototype.bool = function() {
          return 0 !== this.uint32();
        }, u.prototype.fixed32 = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          return f(this.buf, this.pos += 4);
        }, u.prototype.sfixed32 = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          return 0 | f(this.buf, this.pos += 4);
        }, u.prototype.float = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          var e2 = o.float.readFloatLE(this.buf, this.pos);
          return this.pos += 4, e2;
        }, u.prototype.double = function() {
          if (this.pos + 8 > this.len)
            throw s(this, 4);
          var e2 = o.float.readDoubleLE(this.buf, this.pos);
          return this.pos += 8, e2;
        }, u.prototype.bytes = function() {
          var e2 = this.uint32(), t2 = this.pos, n2 = this.pos + e2;
          if (n2 > this.len)
            throw s(this, e2);
          return this.pos += e2, Array.isArray(this.buf) ? this.buf.slice(t2, n2) : t2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, t2, n2);
        }, u.prototype.string = function() {
          var e2 = this.bytes();
          return a.read(e2, 0, e2.length);
        }, u.prototype.skip = function(e2) {
          if ("number" == typeof e2) {
            if (this.pos + e2 > this.len)
              throw s(this, e2);
            this.pos += e2;
          } else
            do {
              if (this.pos >= this.len)
                throw s(this);
            } while (128 & this.buf[this.pos++]);
          return this;
        }, u.prototype.skipType = function(e2) {
          switch (e2) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              for (; 4 != (e2 = 7 & this.uint32()); )
                this.skipType(e2);
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + e2 + " at offset " + this.pos);
          }
          return this;
        }, u._configure = function(e2) {
          r = e2, u.create = p(), r._configure();
          var t2 = o.Long ? "toLong" : "toNumber";
          o.merge(u.prototype, { int64: function() {
            return d.call(this)[t2](false);
          }, uint64: function() {
            return d.call(this)[t2](true);
          }, sint64: function() {
            return d.call(this).zzDecode()[t2](false);
          }, fixed64: function() {
            return h.call(this)[t2](true);
          }, sfixed64: function() {
            return h.call(this)[t2](false);
          } });
        };
      }, 593: (e, t, n) => {
        "use strict";
        e.exports = i;
        var r = n(1408);
        (i.prototype = Object.create(r.prototype)).constructor = i;
        var o = n(9693);
        function i(e2) {
          r.call(this, e2);
        }
        i._configure = function() {
          o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice);
        }, i.prototype.string = function() {
          var e2 = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e2, this.len));
        }, i._configure();
      }, 5054: (e) => {
        "use strict";
        e.exports = {};
      }, 5994: (e, t, n) => {
        "use strict";
        t.Service = n(7948);
      }, 7948: (e, t, n) => {
        "use strict";
        e.exports = o;
        var r = n(9693);
        function o(e2, t2, n2) {
          if ("function" != typeof e2)
            throw TypeError("rpcImpl must be a function");
          r.EventEmitter.call(this), this.rpcImpl = e2, this.requestDelimited = Boolean(t2), this.responseDelimited = Boolean(n2);
        }
        (o.prototype = Object.create(r.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e2(t2, n2, o2, i, a) {
          if (!i)
            throw TypeError("request must be specified");
          var s = this;
          if (!a)
            return r.asPromise(e2, s, t2, n2, o2, i);
          if (s.rpcImpl)
            try {
              return s.rpcImpl(t2, n2[s.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), function(e3, n3) {
                if (e3)
                  return s.emit("error", e3, t2), a(e3);
                if (null !== n3) {
                  if (!(n3 instanceof o2))
                    try {
                      n3 = o2[s.responseDelimited ? "decodeDelimited" : "decode"](n3);
                    } catch (e4) {
                      return s.emit("error", e4, t2), a(e4);
                    }
                  return s.emit("data", n3, t2), a(null, n3);
                }
                s.end(true);
              });
            } catch (e3) {
              return s.emit("error", e3, t2), void setTimeout(function() {
                a(e3);
              }, 0);
            }
          else
            setTimeout(function() {
              a(Error("already ended"));
            }, 0);
        }, o.prototype.end = function(e2) {
          return this.rpcImpl && (e2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
        };
      }, 1945: (e, t, n) => {
        "use strict";
        e.exports = o;
        var r = n(9693);
        function o(e2, t2) {
          this.lo = e2 >>> 0, this.hi = t2 >>> 0;
        }
        var i = o.zero = new o(0, 0);
        i.toNumber = function() {
          return 0;
        }, i.zzEncode = i.zzDecode = function() {
          return this;
        }, i.length = function() {
          return 1;
        };
        var a = o.zeroHash = "\0\0\0\0\0\0\0\0";
        o.fromNumber = function(e2) {
          if (0 === e2)
            return i;
          var t2 = e2 < 0;
          t2 && (e2 = -e2);
          var n2 = e2 >>> 0, r2 = (e2 - n2) / 4294967296 >>> 0;
          return t2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new o(n2, r2);
        }, o.from = function(e2) {
          if ("number" == typeof e2)
            return o.fromNumber(e2);
          if (r.isString(e2)) {
            if (!r.Long)
              return o.fromNumber(parseInt(e2, 10));
            e2 = r.Long.fromString(e2);
          }
          return e2.low || e2.high ? new o(e2.low >>> 0, e2.high >>> 0) : i;
        }, o.prototype.toNumber = function(e2) {
          if (!e2 && this.hi >>> 31) {
            var t2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
            return t2 || (n2 = n2 + 1 >>> 0), -(t2 + 4294967296 * n2);
          }
          return this.lo + 4294967296 * this.hi;
        }, o.prototype.toLong = function(e2) {
          return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(e2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e2) };
        };
        var s = String.prototype.charCodeAt;
        o.fromHash = function(e2) {
          return e2 === a ? i : new o((s.call(e2, 0) | s.call(e2, 1) << 8 | s.call(e2, 2) << 16 | s.call(e2, 3) << 24) >>> 0, (s.call(e2, 4) | s.call(e2, 5) << 8 | s.call(e2, 6) << 16 | s.call(e2, 7) << 24) >>> 0);
        }, o.prototype.toHash = function() {
          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        }, o.prototype.zzEncode = function() {
          var e2 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e2) >>> 0, this.lo = (this.lo << 1 ^ e2) >>> 0, this;
        }, o.prototype.zzDecode = function() {
          var e2 = -(1 & this.lo);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e2) >>> 0, this.hi = (this.hi >>> 1 ^ e2) >>> 0, this;
        }, o.prototype.length = function() {
          var e2 = this.lo, t2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
          return 0 === n2 ? 0 === t2 ? e2 < 16384 ? e2 < 128 ? 1 : 2 : e2 < 2097152 ? 3 : 4 : t2 < 16384 ? t2 < 128 ? 5 : 6 : t2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
        };
      }, 9693: function(e, t, n) {
        "use strict";
        var r = t;
        function o(e2, t2, n2) {
          for (var r2 = Object.keys(t2), o2 = 0; o2 < r2.length; ++o2)
            void 0 !== e2[r2[o2]] && n2 || (e2[r2[o2]] = t2[r2[o2]]);
          return e2;
        }
        function i(e2) {
          function t2(e3, n2) {
            if (!(this instanceof t2))
              return new t2(e3, n2);
            Object.defineProperty(this, "message", { get: function() {
              return e3;
            } }), Error.captureStackTrace ? Error.captureStackTrace(this, t2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && o(this, n2);
          }
          return t2.prototype = Object.create(Error.prototype, { constructor: { value: t2, writable: true, enumerable: false, configurable: true }, name: { get: function() {
            return e2;
          }, set: void 0, enumerable: false, configurable: true }, toString: { value: function() {
            return this.name + ": " + this.message;
          }, writable: true, enumerable: false, configurable: true } }), t2;
        }
        r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean("undefined" != typeof global && global && global.process && global.process.versions && global.process.versions.node), r.global = r.isNode && global || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(e2) {
          return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
        }, r.isString = function(e2) {
          return "string" == typeof e2 || e2 instanceof String;
        }, r.isObject = function(e2) {
          return e2 && "object" == typeof e2;
        }, r.isset = r.isSet = function(e2, t2) {
          var n2 = e2[t2];
          return !(null == n2 || !e2.hasOwnProperty(t2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
        }, r.Buffer = function() {
          try {
            var e2 = r.inquire("buffer").Buffer;
            return e2.prototype.utf8Write ? e2 : null;
          } catch (e3) {
            return null;
          }
        }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(e2) {
          return "number" == typeof e2 ? r.Buffer ? r._Buffer_allocUnsafe(e2) : new r.Array(e2) : r.Buffer ? r._Buffer_from(e2) : "undefined" == typeof Uint8Array ? e2 : new Uint8Array(e2);
        }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(e2) {
          return e2 ? r.LongBits.from(e2).toHash() : r.LongBits.zeroHash;
        }, r.longFromHash = function(e2, t2) {
          var n2 = r.LongBits.fromHash(e2);
          return r.Long ? r.Long.fromBits(n2.lo, n2.hi, t2) : n2.toNumber(Boolean(t2));
        }, r.merge = o, r.lcFirst = function(e2) {
          return e2.charAt(0).toLowerCase() + e2.substring(1);
        }, r.newError = i, r.ProtocolError = i("ProtocolError"), r.oneOfGetter = function(e2) {
          for (var t2 = {}, n2 = 0; n2 < e2.length; ++n2)
            t2[e2[n2]] = 1;
          return function() {
            for (var e3 = Object.keys(this), n3 = e3.length - 1; n3 > -1; --n3)
              if (1 === t2[e3[n3]] && void 0 !== this[e3[n3]] && null !== this[e3[n3]])
                return e3[n3];
          };
        }, r.oneOfSetter = function(e2) {
          return function(t2) {
            for (var n2 = 0; n2 < e2.length; ++n2)
              e2[n2] !== t2 && delete this[e2[n2]];
          };
        }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
          var e2 = r.Buffer;
          e2 ? (r._Buffer_from = e2.from !== Uint8Array.from && e2.from || function(t2, n2) {
            return new e2(t2, n2);
          }, r._Buffer_allocUnsafe = e2.allocUnsafe || function(t2) {
            return new e2(t2);
          }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
        };
      }, 1173: (e, t, n) => {
        "use strict";
        e.exports = p;
        var r, o = n(9693), i = o.LongBits, a = o.base64, s = o.utf8;
        function u(e2, t2, n2) {
          this.fn = e2, this.len = t2, this.next = void 0, this.val = n2;
        }
        function l() {
        }
        function c(e2) {
          this.head = e2.head, this.tail = e2.tail, this.len = e2.len, this.next = e2.states;
        }
        function p() {
          this.len = 0, this.head = new u(l, 0, 0), this.tail = this.head, this.states = null;
        }
        var d = function() {
          return o.Buffer ? function() {
            return (p.create = function() {
              return new r();
            })();
          } : function() {
            return new p();
          };
        };
        function f(e2, t2, n2) {
          t2[n2] = 255 & e2;
        }
        function h(e2, t2) {
          this.len = e2, this.next = void 0, this.val = t2;
        }
        function g(e2, t2, n2) {
          for (; e2.hi; )
            t2[n2++] = 127 & e2.lo | 128, e2.lo = (e2.lo >>> 7 | e2.hi << 25) >>> 0, e2.hi >>>= 7;
          for (; e2.lo > 127; )
            t2[n2++] = 127 & e2.lo | 128, e2.lo = e2.lo >>> 7;
          t2[n2++] = e2.lo;
        }
        function b(e2, t2, n2) {
          t2[n2] = 255 & e2, t2[n2 + 1] = e2 >>> 8 & 255, t2[n2 + 2] = e2 >>> 16 & 255, t2[n2 + 3] = e2 >>> 24;
        }
        p.create = d(), p.alloc = function(e2) {
          return new o.Array(e2);
        }, o.Array !== Array && (p.alloc = o.pool(p.alloc, o.Array.prototype.subarray)), p.prototype._push = function(e2, t2, n2) {
          return this.tail = this.tail.next = new u(e2, t2, n2), this.len += t2, this;
        }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(e2, t2, n2) {
          for (; e2 > 127; )
            t2[n2++] = 127 & e2 | 128, e2 >>>= 7;
          t2[n2] = e2;
        }, p.prototype.uint32 = function(e2) {
          return this.len += (this.tail = this.tail.next = new h((e2 >>>= 0) < 128 ? 1 : e2 < 16384 ? 2 : e2 < 2097152 ? 3 : e2 < 268435456 ? 4 : 5, e2)).len, this;
        }, p.prototype.int32 = function(e2) {
          return e2 < 0 ? this._push(g, 10, i.fromNumber(e2)) : this.uint32(e2);
        }, p.prototype.sint32 = function(e2) {
          return this.uint32((e2 << 1 ^ e2 >> 31) >>> 0);
        }, p.prototype.uint64 = function(e2) {
          var t2 = i.from(e2);
          return this._push(g, t2.length(), t2);
        }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(e2) {
          var t2 = i.from(e2).zzEncode();
          return this._push(g, t2.length(), t2);
        }, p.prototype.bool = function(e2) {
          return this._push(f, 1, e2 ? 1 : 0);
        }, p.prototype.fixed32 = function(e2) {
          return this._push(b, 4, e2 >>> 0);
        }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(e2) {
          var t2 = i.from(e2);
          return this._push(b, 4, t2.lo)._push(b, 4, t2.hi);
        }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(e2) {
          return this._push(o.float.writeFloatLE, 4, e2);
        }, p.prototype.double = function(e2) {
          return this._push(o.float.writeDoubleLE, 8, e2);
        };
        var m = o.Array.prototype.set ? function(e2, t2, n2) {
          t2.set(e2, n2);
        } : function(e2, t2, n2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[n2 + r2] = e2[r2];
        };
        p.prototype.bytes = function(e2) {
          var t2 = e2.length >>> 0;
          if (!t2)
            return this._push(f, 1, 0);
          if (o.isString(e2)) {
            var n2 = p.alloc(t2 = a.length(e2));
            a.decode(e2, n2, 0), e2 = n2;
          }
          return this.uint32(t2)._push(m, t2, e2);
        }, p.prototype.string = function(e2) {
          var t2 = s.length(e2);
          return t2 ? this.uint32(t2)._push(s.write, t2, e2) : this._push(f, 1, 0);
        }, p.prototype.fork = function() {
          return this.states = new c(this), this.head = this.tail = new u(l, 0, 0), this.len = 0, this;
        }, p.prototype.reset = function() {
          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(l, 0, 0), this.len = 0), this;
        }, p.prototype.ldelim = function() {
          var e2 = this.head, t2 = this.tail, n2 = this.len;
          return this.reset().uint32(n2), n2 && (this.tail.next = e2.next, this.tail = t2, this.len += n2), this;
        }, p.prototype.finish = function() {
          for (var e2 = this.head.next, t2 = this.constructor.alloc(this.len), n2 = 0; e2; )
            e2.fn(e2.val, t2, n2), n2 += e2.len, e2 = e2.next;
          return t2;
        }, p._configure = function(e2) {
          r = e2, p.create = d(), r._configure();
        };
      }, 3155: (e, t, n) => {
        "use strict";
        e.exports = i;
        var r = n(1173);
        (i.prototype = Object.create(r.prototype)).constructor = i;
        var o = n(9693);
        function i() {
          r.call(this);
        }
        function a(e2, t2, n2) {
          e2.length < 40 ? o.utf8.write(e2, t2, n2) : t2.utf8Write ? t2.utf8Write(e2, n2) : t2.write(e2, n2);
        }
        i._configure = function() {
          i.alloc = o._Buffer_allocUnsafe, i.writeBytesBuffer = o.Buffer && o.Buffer.prototype instanceof Uint8Array && "set" === o.Buffer.prototype.set.name ? function(e2, t2, n2) {
            t2.set(e2, n2);
          } : function(e2, t2, n2) {
            if (e2.copy)
              e2.copy(t2, n2, 0, e2.length);
            else
              for (var r2 = 0; r2 < e2.length; )
                t2[n2++] = e2[r2++];
          };
        }, i.prototype.bytes = function(e2) {
          o.isString(e2) && (e2 = o._Buffer_from(e2, "base64"));
          var t2 = e2.length >>> 0;
          return this.uint32(t2), t2 && this._push(i.writeBytesBuffer, t2, e2), this;
        }, i.prototype.string = function(e2) {
          var t2 = o.Buffer.byteLength(e2);
          return this.uint32(t2), t2 && this._push(a, t2, e2), this;
        }, i._configure();
      }, 4154: (e) => {
        "use strict";
        e.exports = '"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\n';
      }, 7067: () => {
      }, 1296: () => {
      }, 760: () => {
      }, 1384: () => {
      }, 3993: () => {
      }, 908: () => {
      }, 6953: () => {
      }, 9925: () => {
      }, 2806: () => {
      }, 6449: () => {
      }, 2850: () => {
      }, 5381: () => {
      }, 685: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.registerBackend = void 0;
        const n = {}, r = [];
        t.registerBackend = (e2, t2, o) => {
          if (!t2 || "function" != typeof t2.init || "function" != typeof t2.createSessionHandler)
            throw new TypeError("not a valid backend");
          {
            const i = n[e2];
            if (void 0 === i)
              n[e2] = { backend: t2, priority: o };
            else {
              if (i.priority > o)
                return;
              if (i.priority === o && i.backend !== t2)
                throw new Error(`cannot register backend "${e2}" using priority ${o}`);
            }
            if (o >= 0) {
              const t3 = r.indexOf(e2);
              -1 !== t3 && r.splice(t3, 1);
              for (let t4 = 0; t4 < r.length; t4++)
                if (n[r[t4]].priority <= o)
                  return void r.splice(t4, 0, e2);
              r.push(e2);
            }
          }
        }, t.resolveBackend = async (e2) => {
          const t2 = 0 === e2.length ? r : e2, o = [];
          for (const e3 of t2) {
            const t3 = n[e3];
            if (t3) {
              if (t3.initialized)
                return t3.backend;
              if (t3.aborted)
                continue;
              const n2 = !!t3.initPromise;
              try {
                return n2 || (t3.initPromise = t3.backend.init()), await t3.initPromise, t3.initialized = true, t3.backend;
              } catch (r2) {
                n2 || o.push({ name: e3, err: r2 }), t3.aborted = true;
              } finally {
                delete t3.initPromise;
              }
            }
          }
          throw new Error(`no available backend found. ERR: ${o.map((e3) => `[${e3.name}] ${e3.err}`).join(", ")}`);
        };
      }, 4798: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.registerBackend = void 0;
        var r = n(685);
        Object.defineProperty(t, "registerBackend", { enumerable: true, get: function() {
          return r.registerBackend;
        } });
      }, 3121: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.env = void 0;
        const r = n(9104);
        let o = "warning";
        t.env = { wasm: {}, webgl: {}, webgpu: {}, versions: { common: r.version }, set logLevel(e2) {
          if (void 0 !== e2) {
            if ("string" != typeof e2 || -1 === ["verbose", "info", "warning", "error", "fatal"].indexOf(e2))
              throw new Error(`Unsupported logging level: ${e2}`);
            o = e2;
          }
        }, get logLevel() {
          return o;
        } }, Object.defineProperty(t.env, "logLevel", { enumerable: true });
      }, 2457: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.env = void 0;
        const r = n(3121);
        t.env = r.env;
      }, 2235: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__exportStar || function(e2, t2) {
          for (var n2 in e2)
            "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e2, n2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), o(n(4798), t), o(n(2457), t), o(n(3974), t), o(n(963), t), o(n(7852), t);
      }, 8036: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InferenceSession = void 0;
        const r = n(685), o = n(963);
        class i {
          constructor(e2) {
            this.handler = e2;
          }
          async run(e2, t2, n2) {
            const r2 = {};
            let i2 = {};
            if ("object" != typeof e2 || null === e2 || e2 instanceof o.Tensor || Array.isArray(e2))
              throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
            let a = true;
            if ("object" == typeof t2) {
              if (null === t2)
                throw new TypeError("Unexpected argument[1]: cannot be null.");
              if (t2 instanceof o.Tensor)
                throw new TypeError("'fetches' cannot be a Tensor");
              if (Array.isArray(t2)) {
                if (0 === t2.length)
                  throw new TypeError("'fetches' cannot be an empty array.");
                a = false;
                for (const e3 of t2) {
                  if ("string" != typeof e3)
                    throw new TypeError("'fetches' must be a string array or an object.");
                  if (-1 === this.outputNames.indexOf(e3))
                    throw new RangeError(`'fetches' contains invalid output name: ${e3}.`);
                  r2[e3] = null;
                }
                if ("object" == typeof n2 && null !== n2)
                  i2 = n2;
                else if (void 0 !== n2)
                  throw new TypeError("'options' must be an object.");
              } else {
                let e3 = false;
                const s2 = Object.getOwnPropertyNames(t2);
                for (const n3 of this.outputNames)
                  if (-1 !== s2.indexOf(n3)) {
                    const i3 = t2[n3];
                    (null === i3 || i3 instanceof o.Tensor) && (e3 = true, a = false, r2[n3] = i3);
                  }
                if (e3) {
                  if ("object" == typeof n2 && null !== n2)
                    i2 = n2;
                  else if (void 0 !== n2)
                    throw new TypeError("'options' must be an object.");
                } else
                  i2 = t2;
              }
            } else if (void 0 !== t2)
              throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
            for (const t3 of this.inputNames)
              if (void 0 === e2[t3])
                throw new Error(`input '${t3}' is missing in 'feeds'.`);
            if (a)
              for (const e3 of this.outputNames)
                r2[e3] = null;
            const s = await this.handler.run(e2, r2, i2), u = {};
            for (const e3 in s)
              Object.hasOwnProperty.call(s, e3) && (u[e3] = new o.Tensor(s[e3].type, s[e3].data, s[e3].dims));
            return u;
          }
          async release() {
            return this.handler.dispose();
          }
          static async create(e2, t2, n2, o2) {
            let a, s = {};
            if ("string" == typeof e2) {
              if (a = e2, "object" == typeof t2 && null !== t2)
                s = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else if (e2 instanceof Uint8Array) {
              if (a = e2, "object" == typeof t2 && null !== t2)
                s = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else {
              if (!(e2 instanceof ArrayBuffer || "undefined" != typeof SharedArrayBuffer && e2 instanceof SharedArrayBuffer))
                throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
              {
                const r2 = e2;
                let i2 = 0, u2 = e2.byteLength;
                if ("object" == typeof t2 && null !== t2)
                  s = t2;
                else if ("number" == typeof t2) {
                  if (i2 = t2, !Number.isSafeInteger(i2))
                    throw new RangeError("'byteOffset' must be an integer.");
                  if (i2 < 0 || i2 >= r2.byteLength)
                    throw new RangeError(`'byteOffset' is out of range [0, ${r2.byteLength}).`);
                  if (u2 = e2.byteLength - i2, "number" == typeof n2) {
                    if (u2 = n2, !Number.isSafeInteger(u2))
                      throw new RangeError("'byteLength' must be an integer.");
                    if (u2 <= 0 || i2 + u2 > r2.byteLength)
                      throw new RangeError(`'byteLength' is out of range (0, ${r2.byteLength - i2}].`);
                    if ("object" == typeof o2 && null !== o2)
                      s = o2;
                    else if (void 0 !== o2)
                      throw new TypeError("'options' must be an object.");
                  } else if (void 0 !== n2)
                    throw new TypeError("'byteLength' must be a number.");
                } else if (void 0 !== t2)
                  throw new TypeError("'options' must be an object.");
                a = new Uint8Array(r2, i2, u2);
              }
            }
            const u = (s.executionProviders || []).map((e3) => "string" == typeof e3 ? e3 : e3.name), l = await (0, r.resolveBackend)(u), c = await l.createSessionHandler(a, s);
            return new i(c);
          }
          startProfiling() {
            this.handler.startProfiling();
          }
          endProfiling() {
            this.handler.endProfiling();
          }
          get inputNames() {
            return this.handler.inputNames;
          }
          get outputNames() {
            return this.handler.outputNames;
          }
        }
        t.InferenceSession = i;
      }, 3974: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InferenceSession = void 0;
        const r = n(8036);
        t.InferenceSession = r.InferenceSession;
      }, 7852: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
      }, 2350: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorToImageData = t.tensorToDataURL = void 0, t.tensorToDataURL = (e2, t2) => {
          const n = document.createElement("canvas");
          n.width = e2.dims[3], n.height = e2.dims[2];
          const r = n.getContext("2d");
          if (null != r) {
            let o, i;
            void 0 !== (t2 == null ? void 0 : t2.tensorLayout) && "NHWC" === t2.tensorLayout ? (o = e2.dims[2], i = e2.dims[3]) : (o = e2.dims[3], i = e2.dims[2]);
            const a = void 0 !== (t2 == null ? void 0 : t2.format) ? t2.format : "RGB", s = t2 == null ? void 0 : t2.norm;
            let u, l;
            void 0 === s || void 0 === s.mean ? u = [255, 255, 255, 255] : "number" == typeof s.mean ? u = [s.mean, s.mean, s.mean, s.mean] : (u = [s.mean[0], s.mean[1], s.mean[2], 0], void 0 !== s.mean[3] && (u[3] = s.mean[3])), void 0 === s || void 0 === s.bias ? l = [0, 0, 0, 0] : "number" == typeof s.bias ? l = [s.bias, s.bias, s.bias, s.bias] : (l = [s.bias[0], s.bias[1], s.bias[2], 0], void 0 !== s.bias[3] && (l[3] = s.bias[3]));
            const c = i * o;
            let p = 0, d = c, f = 2 * c, h = -1;
            "RGBA" === a ? (p = 0, d = c, f = 2 * c, h = 3 * c) : "RGB" === a ? (p = 0, d = c, f = 2 * c) : "RBG" === a && (p = 0, f = c, d = 2 * c);
            for (let t3 = 0; t3 < i; t3++)
              for (let n2 = 0; n2 < o; n2++) {
                const o2 = (e2.data[p++] - l[0]) * u[0], i2 = (e2.data[d++] - l[1]) * u[1], a2 = (e2.data[f++] - l[2]) * u[2], s2 = -1 === h ? 255 : (e2.data[h++] - l[3]) * u[3];
                r.fillStyle = "rgba(" + o2 + "," + i2 + "," + a2 + "," + s2 + ")", r.fillRect(n2, t3, 1, 1);
              }
            return n.toDataURL();
          }
          throw new Error("Can not access image data");
        }, t.tensorToImageData = (e2, t2) => {
          const n = document.createElement("canvas").getContext("2d");
          let r;
          if (null == n)
            throw new Error("Can not access image data");
          {
            let o, i, a;
            void 0 !== (t2 == null ? void 0 : t2.tensorLayout) && "NHWC" === t2.tensorLayout ? (o = e2.dims[2], i = e2.dims[1], a = e2.dims[3]) : (o = e2.dims[3], i = e2.dims[2], a = e2.dims[1]);
            const s = void 0 !== t2 && void 0 !== t2.format ? t2.format : "RGB", u = t2 == null ? void 0 : t2.norm;
            let l, c;
            void 0 === u || void 0 === u.mean ? l = [255, 255, 255, 255] : "number" == typeof u.mean ? l = [u.mean, u.mean, u.mean, u.mean] : (l = [u.mean[0], u.mean[1], u.mean[2], 255], void 0 !== u.mean[3] && (l[3] = u.mean[3])), void 0 === u || void 0 === u.bias ? c = [0, 0, 0, 0] : "number" == typeof u.bias ? c = [u.bias, u.bias, u.bias, u.bias] : (c = [u.bias[0], u.bias[1], u.bias[2], 0], void 0 !== u.bias[3] && (c[3] = u.bias[3]));
            const p = i * o;
            if (void 0 !== t2 && (void 0 !== t2.format && 4 === a && "RGBA" !== t2.format || 3 === a && "RGB" !== t2.format && "BGR" !== t2.format))
              throw new Error("Tensor format doesn't match input tensor dims");
            const d = 4;
            let f = 0, h = 1, g = 2, b = 3, m = 0, y = p, v = 2 * p, _ = -1;
            "RGBA" === s ? (m = 0, y = p, v = 2 * p, _ = 3 * p) : "RGB" === s ? (m = 0, y = p, v = 2 * p) : "RBG" === s && (m = 0, v = p, y = 2 * p), r = n.createImageData(o, i);
            for (let t3 = 0; t3 < i * o; f += d, h += d, g += d, b += d, t3++)
              r.data[f] = (e2.data[m++] - c[0]) * l[0], r.data[h] = (e2.data[y++] - c[1]) * l[1], r.data[g] = (e2.data[v++] - c[2]) * l[2], r.data[b] = -1 === _ ? 255 : (e2.data[_++] - c[3]) * l[3];
          }
          return r;
        };
      }, 4866: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorFromImage = t.bufferToTensor = void 0;
        const r = n(963);
        t.bufferToTensor = (e2, t2) => {
          if (void 0 === e2)
            throw new Error("Image buffer must be defined");
          if (void 0 === t2.height || void 0 === t2.width)
            throw new Error("Image height and width must be defined");
          if ("NHWC" === t2.tensorLayout)
            throw new Error("NHWC Tensor layout is not supported yet");
          const { height: n2, width: o } = t2, i = t2.norm ?? { mean: 255, bias: 0 };
          let a, s;
          a = "number" == typeof i.mean ? [i.mean, i.mean, i.mean, i.mean] : [i.mean[0], i.mean[1], i.mean[2], i.mean[3] ?? 255], s = "number" == typeof i.bias ? [i.bias, i.bias, i.bias, i.bias] : [i.bias[0], i.bias[1], i.bias[2], i.bias[3] ?? 0];
          const u = void 0 !== t2.format ? t2.format : "RGBA", l = void 0 !== t2.tensorFormat && void 0 !== t2.tensorFormat ? t2.tensorFormat : "RGB", c = n2 * o, p = "RGBA" === l ? new Float32Array(4 * c) : new Float32Array(3 * c);
          let d = 4, f = 0, h = 1, g = 2, b = 3, m = 0, y = c, v = 2 * c, _ = -1;
          "RGB" === u && (d = 3, f = 0, h = 1, g = 2, b = -1), "RGBA" === l ? _ = 3 * c : "RBG" === l ? (m = 0, v = c, y = 2 * c) : "BGR" === l && (v = 0, y = c, m = 2 * c);
          for (let t3 = 0; t3 < c; t3++, f += d, g += d, h += d, b += d)
            p[m++] = (e2[f] + s[0]) / a[0], p[y++] = (e2[h] + s[1]) / a[1], p[v++] = (e2[g] + s[2]) / a[2], -1 !== _ && -1 !== b && (p[_++] = (e2[b] + s[3]) / a[3]);
          return "RGBA" === l ? new r.Tensor("float32", p, [1, 4, n2, o]) : new r.Tensor("float32", p, [1, 3, n2, o]);
        }, t.tensorFromImage = async (e2, n2) => {
          const r2 = "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement, o = "undefined" != typeof ImageData && e2 instanceof ImageData, i = "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap, a = "string" == typeof e2;
          let s, u = n2 ?? {};
          if (r2) {
            const t2 = document.createElement("canvas");
            t2.width = e2.width, t2.height = e2.height;
            const r3 = t2.getContext("2d");
            if (null == r3)
              throw new Error("Can not access image data");
            {
              let t3 = e2.height, o2 = e2.width;
              if (void 0 !== n2 && void 0 !== n2.resizedHeight && void 0 !== n2.resizedWidth && (t3 = n2.resizedHeight, o2 = n2.resizedWidth), void 0 !== n2) {
                if (u = n2, void 0 !== n2.tensorFormat)
                  throw new Error("Image input config format must be RGBA for HTMLImageElement");
                u.tensorFormat = "RGBA", u.height = t3, u.width = o2;
              } else
                u.tensorFormat = "RGBA", u.height = t3, u.width = o2;
              r3.drawImage(e2, 0, 0), s = r3.getImageData(0, 0, o2, t3).data;
            }
          } else {
            if (!o) {
              if (i) {
                if (void 0 === n2)
                  throw new Error("Please provide image config with format for Imagebitmap");
                const r3 = document.createElement("canvas");
                r3.width = e2.width, r3.height = e2.height;
                const o2 = r3.getContext("2d");
                if (null != o2) {
                  const n3 = e2.height, r4 = e2.width;
                  return o2.drawImage(e2, 0, 0, r4, n3), s = o2.getImageData(0, 0, r4, n3).data, u.height = n3, u.width = r4, (0, t.bufferToTensor)(s, u);
                }
                throw new Error("Can not access image data");
              }
              if (a)
                return new Promise((n3, r3) => {
                  const o2 = document.createElement("canvas"), i2 = o2.getContext("2d");
                  if (!e2 || !i2)
                    return r3();
                  const a2 = new Image();
                  a2.crossOrigin = "Anonymous", a2.src = e2, a2.onload = () => {
                    o2.width = a2.width, o2.height = a2.height, i2.drawImage(a2, 0, 0, o2.width, o2.height);
                    const e3 = i2.getImageData(0, 0, o2.width, o2.height);
                    u.height = o2.height, u.width = o2.width, n3((0, t.bufferToTensor)(e3.data, u));
                  };
                });
              throw new Error("Input data provided is not supported - aborted tensor creation");
            }
            {
              let t2, r3;
              if (void 0 !== n2 && void 0 !== n2.resizedWidth && void 0 !== n2.resizedHeight ? (t2 = n2.resizedHeight, r3 = n2.resizedWidth) : (t2 = e2.height, r3 = e2.width), void 0 !== n2 && (u = n2), u.format = "RGBA", u.height = t2, u.width = r3, void 0 !== n2) {
                const n3 = document.createElement("canvas");
                n3.width = r3, n3.height = t2;
                const o2 = n3.getContext("2d");
                if (null == o2)
                  throw new Error("Can not access image data");
                o2.putImageData(e2, 0, 0), s = o2.getImageData(0, 0, r3, t2).data;
              } else
                s = e2.data;
            }
          }
          if (void 0 !== s)
            return (0, t.bufferToTensor)(s, u);
          throw new Error("Input data provided is not supported - aborted tensor creation");
        };
      }, 5957: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const r = n(2350), o = n(4866), i = n(106), a = /* @__PURE__ */ new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["float16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), s = /* @__PURE__ */ new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]);
        let u = false;
        t.Tensor = class {
          constructor(e2, t2, n2) {
            let r2, o2, l;
            if ((() => {
              if (!u) {
                u = true;
                const e3 = "undefined" != typeof BigInt64Array && "function" == typeof BigInt64Array.from, t3 = "undefined" != typeof BigUint64Array && "function" == typeof BigUint64Array.from;
                e3 && (a.set("int64", BigInt64Array), s.set(BigInt64Array, "int64")), t3 && (a.set("uint64", BigUint64Array), s.set(BigUint64Array, "uint64"));
              }
            })(), "string" == typeof e2)
              if (r2 = e2, l = n2, "string" === e2) {
                if (!Array.isArray(t2))
                  throw new TypeError("A string tensor's data must be a string array.");
                o2 = t2;
              } else {
                const n3 = a.get(e2);
                if (void 0 === n3)
                  throw new TypeError(`Unsupported tensor type: ${e2}.`);
                if (Array.isArray(t2)) {
                  if ("float16" === e2)
                    throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                  o2 = "uint64" === e2 || "int64" === e2 ? n3.from(t2, BigInt) : n3.from(t2);
                } else {
                  if (!(t2 instanceof n3))
                    throw new TypeError(`A ${r2} tensor's data must be type of ${n3}`);
                  o2 = t2;
                }
              }
            else if (l = t2, Array.isArray(e2)) {
              if (0 === e2.length)
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              const t3 = typeof e2[0];
              if ("string" === t3)
                r2 = "string", o2 = e2;
              else {
                if ("boolean" !== t3)
                  throw new TypeError(`Invalid element type of data array: ${t3}.`);
                r2 = "bool", o2 = Uint8Array.from(e2);
              }
            } else {
              const t3 = s.get(e2.constructor);
              if (void 0 === t3)
                throw new TypeError(`Unsupported type for tensor data: ${e2.constructor}.`);
              r2 = t3, o2 = e2;
            }
            if (void 0 === l)
              l = [o2.length];
            else if (!Array.isArray(l))
              throw new TypeError("A tensor's dims must be a number array");
            const c = (0, i.calculateSize)(l);
            if (c !== o2.length)
              throw new Error(`Tensor's size(${c}) does not match data length(${o2.length}).`);
            this.dims = l, this.type = r2, this.data = o2, this.size = c;
          }
          static async fromImage(e2, t2) {
            return (0, o.tensorFromImage)(e2, t2);
          }
          toDataURL(e2) {
            return (0, r.tensorToDataURL)(this, e2);
          }
          toImageData(e2) {
            return (0, r.tensorToImageData)(this, e2);
          }
          reshape(e2) {
            return (0, i.tensorReshape)(this, e2);
          }
        };
      }, 106: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorReshape = t.calculateSize = void 0;
        const r = n(963);
        t.calculateSize = (e2) => {
          let t2 = 1;
          for (let n2 = 0; n2 < e2.length; n2++) {
            const r2 = e2[n2];
            if ("number" != typeof r2 || !Number.isSafeInteger(r2))
              throw new TypeError(`dims[${n2}] must be an integer, got: ${r2}`);
            if (r2 < 0)
              throw new RangeError(`dims[${n2}] must be a non-negative integer, got: ${r2}`);
            t2 *= r2;
          }
          return t2;
        }, t.tensorReshape = (e2, t2) => new r.Tensor(e2.type, e2.data, t2);
      }, 963: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const r = n(5957);
        t.Tensor = r.Tensor;
      }, 9104: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.version = void 0, t.version = "1.16.3";
      }, 1583: (e, t) => {
        var n, r = function(e2) {
          "use strict";
          Object.defineProperty(e2, "__esModule", { value: true }), e2.default = void 0;
          var t2 = null;
          try {
            t2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (e3) {
          }
          function n2(e3, t3, n3) {
            this.low = 0 | e3, this.high = 0 | t3, this.unsigned = !!n3;
          }
          function r2(e3) {
            return true === (e3 && e3.__isLong__);
          }
          function o(e3) {
            var t3 = Math.clz32(e3 & -e3);
            return e3 ? 31 - t3 : t3;
          }
          n2.prototype.__isLong__, Object.defineProperty(n2.prototype, "__isLong__", { value: true }), n2.isLong = r2;
          var i = {}, a = {};
          function s(e3, t3) {
            var n3, r3, o2;
            return t3 ? (o2 = 0 <= (e3 >>>= 0) && e3 < 256) && (r3 = a[e3]) ? r3 : (n3 = l(e3, 0, true), o2 && (a[e3] = n3), n3) : (o2 = -128 <= (e3 |= 0) && e3 < 128) && (r3 = i[e3]) ? r3 : (n3 = l(e3, e3 < 0 ? -1 : 0, false), o2 && (i[e3] = n3), n3);
          }
          function u(e3, t3) {
            if (isNaN(e3))
              return t3 ? y : m;
            if (t3) {
              if (e3 < 0)
                return y;
              if (e3 >= h)
                return x;
            } else {
              if (e3 <= -g)
                return O;
              if (e3 + 1 >= g)
                return T;
            }
            return e3 < 0 ? u(-e3, t3).neg() : l(e3 % f | 0, e3 / f | 0, t3);
          }
          function l(e3, t3, r3) {
            return new n2(e3, t3, r3);
          }
          n2.fromInt = s, n2.fromNumber = u, n2.fromBits = l;
          var c = Math.pow;
          function p(e3, t3, n3) {
            if (0 === e3.length)
              throw Error("empty string");
            if ("number" == typeof t3 ? (n3 = t3, t3 = false) : t3 = !!t3, "NaN" === e3 || "Infinity" === e3 || "+Infinity" === e3 || "-Infinity" === e3)
              return t3 ? y : m;
            if ((n3 = n3 || 10) < 2 || 36 < n3)
              throw RangeError("radix");
            var r3;
            if ((r3 = e3.indexOf("-")) > 0)
              throw Error("interior hyphen");
            if (0 === r3)
              return p(e3.substring(1), t3, n3).neg();
            for (var o2 = u(c(n3, 8)), i2 = m, a2 = 0; a2 < e3.length; a2 += 8) {
              var s2 = Math.min(8, e3.length - a2), l2 = parseInt(e3.substring(a2, a2 + s2), n3);
              if (s2 < 8) {
                var d2 = u(c(n3, s2));
                i2 = i2.mul(d2).add(u(l2));
              } else
                i2 = (i2 = i2.mul(o2)).add(u(l2));
            }
            return i2.unsigned = t3, i2;
          }
          function d(e3, t3) {
            return "number" == typeof e3 ? u(e3, t3) : "string" == typeof e3 ? p(e3, t3) : l(e3.low, e3.high, "boolean" == typeof t3 ? t3 : e3.unsigned);
          }
          n2.fromString = p, n2.fromValue = d;
          var f = 4294967296, h = f * f, g = h / 2, b = s(1 << 24), m = s(0);
          n2.ZERO = m;
          var y = s(0, true);
          n2.UZERO = y;
          var v = s(1);
          n2.ONE = v;
          var _ = s(1, true);
          n2.UONE = _;
          var w = s(-1);
          n2.NEG_ONE = w;
          var T = l(-1, 2147483647, false);
          n2.MAX_VALUE = T;
          var x = l(-1, -1, true);
          n2.MAX_UNSIGNED_VALUE = x;
          var O = l(0, -2147483648, false);
          n2.MIN_VALUE = O;
          var S = n2.prototype;
          S.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, S.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
          }, S.toString = function(e3) {
            if ((e3 = e3 || 10) < 2 || 36 < e3)
              throw RangeError("radix");
            if (this.isZero())
              return "0";
            if (this.isNegative()) {
              if (this.eq(O)) {
                var t3 = u(e3), n3 = this.div(t3), r3 = n3.mul(t3).sub(this);
                return n3.toString(e3) + r3.toInt().toString(e3);
              }
              return "-" + this.neg().toString(e3);
            }
            for (var o2 = u(c(e3, 6), this.unsigned), i2 = this, a2 = ""; ; ) {
              var s2 = i2.div(o2), l2 = (i2.sub(s2.mul(o2)).toInt() >>> 0).toString(e3);
              if ((i2 = s2).isZero())
                return l2 + a2;
              for (; l2.length < 6; )
                l2 = "0" + l2;
              a2 = "" + l2 + a2;
            }
          }, S.getHighBits = function() {
            return this.high;
          }, S.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, S.getLowBits = function() {
            return this.low;
          }, S.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, S.getNumBitsAbs = function() {
            if (this.isNegative())
              return this.eq(O) ? 64 : this.neg().getNumBitsAbs();
            for (var e3 = 0 != this.high ? this.high : this.low, t3 = 31; t3 > 0 && 0 == (e3 & 1 << t3); t3--)
              ;
            return 0 != this.high ? t3 + 33 : t3 + 1;
          }, S.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, S.eqz = S.isZero, S.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, S.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, S.isOdd = function() {
            return 1 == (1 & this.low);
          }, S.isEven = function() {
            return 0 == (1 & this.low);
          }, S.equals = function(e3) {
            return r2(e3) || (e3 = d(e3)), (this.unsigned === e3.unsigned || this.high >>> 31 != 1 || e3.high >>> 31 != 1) && this.high === e3.high && this.low === e3.low;
          }, S.eq = S.equals, S.notEquals = function(e3) {
            return !this.eq(e3);
          }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(e3) {
            return this.comp(e3) < 0;
          }, S.lt = S.lessThan, S.lessThanOrEqual = function(e3) {
            return this.comp(e3) <= 0;
          }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(e3) {
            return this.comp(e3) > 0;
          }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(e3) {
            return this.comp(e3) >= 0;
          }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(e3) {
            if (r2(e3) || (e3 = d(e3)), this.eq(e3))
              return 0;
            var t3 = this.isNegative(), n3 = e3.isNegative();
            return t3 && !n3 ? -1 : !t3 && n3 ? 1 : this.unsigned ? e3.high >>> 0 > this.high >>> 0 || e3.high === this.high && e3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e3).isNegative() ? -1 : 1;
          }, S.comp = S.compare, S.negate = function() {
            return !this.unsigned && this.eq(O) ? O : this.not().add(v);
          }, S.neg = S.negate, S.add = function(e3) {
            r2(e3) || (e3 = d(e3));
            var t3 = this.high >>> 16, n3 = 65535 & this.high, o2 = this.low >>> 16, i2 = 65535 & this.low, a2 = e3.high >>> 16, s2 = 65535 & e3.high, u2 = e3.low >>> 16, c2 = 0, p2 = 0, f2 = 0, h2 = 0;
            return f2 += (h2 += i2 + (65535 & e3.low)) >>> 16, p2 += (f2 += o2 + u2) >>> 16, c2 += (p2 += n3 + s2) >>> 16, c2 += t3 + a2, l((f2 &= 65535) << 16 | (h2 &= 65535), (c2 &= 65535) << 16 | (p2 &= 65535), this.unsigned);
          }, S.subtract = function(e3) {
            return r2(e3) || (e3 = d(e3)), this.add(e3.neg());
          }, S.sub = S.subtract, S.multiply = function(e3) {
            if (this.isZero())
              return this;
            if (r2(e3) || (e3 = d(e3)), t2)
              return l(t2.mul(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned);
            if (e3.isZero())
              return this.unsigned ? y : m;
            if (this.eq(O))
              return e3.isOdd() ? O : m;
            if (e3.eq(O))
              return this.isOdd() ? O : m;
            if (this.isNegative())
              return e3.isNegative() ? this.neg().mul(e3.neg()) : this.neg().mul(e3).neg();
            if (e3.isNegative())
              return this.mul(e3.neg()).neg();
            if (this.lt(b) && e3.lt(b))
              return u(this.toNumber() * e3.toNumber(), this.unsigned);
            var n3 = this.high >>> 16, o2 = 65535 & this.high, i2 = this.low >>> 16, a2 = 65535 & this.low, s2 = e3.high >>> 16, c2 = 65535 & e3.high, p2 = e3.low >>> 16, f2 = 65535 & e3.low, h2 = 0, g2 = 0, v2 = 0, _2 = 0;
            return v2 += (_2 += a2 * f2) >>> 16, g2 += (v2 += i2 * f2) >>> 16, v2 &= 65535, g2 += (v2 += a2 * p2) >>> 16, h2 += (g2 += o2 * f2) >>> 16, g2 &= 65535, h2 += (g2 += i2 * p2) >>> 16, g2 &= 65535, h2 += (g2 += a2 * c2) >>> 16, h2 += n3 * f2 + o2 * p2 + i2 * c2 + a2 * s2, l((v2 &= 65535) << 16 | (_2 &= 65535), (h2 &= 65535) << 16 | (g2 &= 65535), this.unsigned);
          }, S.mul = S.multiply, S.divide = function(e3) {
            if (r2(e3) || (e3 = d(e3)), e3.isZero())
              throw Error("division by zero");
            var n3, o2, i2;
            if (t2)
              return this.unsigned || -2147483648 !== this.high || -1 !== e3.low || -1 !== e3.high ? l((this.unsigned ? t2.div_u : t2.div_s)(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned) : this;
            if (this.isZero())
              return this.unsigned ? y : m;
            if (this.unsigned) {
              if (e3.unsigned || (e3 = e3.toUnsigned()), e3.gt(this))
                return y;
              if (e3.gt(this.shru(1)))
                return _;
              i2 = y;
            } else {
              if (this.eq(O))
                return e3.eq(v) || e3.eq(w) ? O : e3.eq(O) ? v : (n3 = this.shr(1).div(e3).shl(1)).eq(m) ? e3.isNegative() ? v : w : (o2 = this.sub(e3.mul(n3)), i2 = n3.add(o2.div(e3)));
              if (e3.eq(O))
                return this.unsigned ? y : m;
              if (this.isNegative())
                return e3.isNegative() ? this.neg().div(e3.neg()) : this.neg().div(e3).neg();
              if (e3.isNegative())
                return this.div(e3.neg()).neg();
              i2 = m;
            }
            for (o2 = this; o2.gte(e3); ) {
              n3 = Math.max(1, Math.floor(o2.toNumber() / e3.toNumber()));
              for (var a2 = Math.ceil(Math.log(n3) / Math.LN2), s2 = a2 <= 48 ? 1 : c(2, a2 - 48), p2 = u(n3), f2 = p2.mul(e3); f2.isNegative() || f2.gt(o2); )
                f2 = (p2 = u(n3 -= s2, this.unsigned)).mul(e3);
              p2.isZero() && (p2 = v), i2 = i2.add(p2), o2 = o2.sub(f2);
            }
            return i2;
          }, S.div = S.divide, S.modulo = function(e3) {
            return r2(e3) || (e3 = d(e3)), t2 ? l((this.unsigned ? t2.rem_u : t2.rem_s)(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned) : this.sub(this.div(e3).mul(e3));
          }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
            return l(~this.low, ~this.high, this.unsigned);
          }, S.countLeadingZeros = function() {
            return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
          }, S.clz = S.countLeadingZeros, S.countTrailingZeros = function() {
            return this.low ? o(this.low) : o(this.high) + 32;
          }, S.ctz = S.countTrailingZeros, S.and = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low & e3.low, this.high & e3.high, this.unsigned);
          }, S.or = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low | e3.low, this.high | e3.high, this.unsigned);
          }, S.xor = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low ^ e3.low, this.high ^ e3.high, this.unsigned);
          }, S.shiftLeft = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low << e3, this.high << e3 | this.low >>> 32 - e3, this.unsigned) : l(0, this.low << e3 - 32, this.unsigned);
          }, S.shl = S.shiftLeft, S.shiftRight = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >> e3, this.unsigned) : l(this.high >> e3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >>> e3, this.unsigned) : l(32 === e3 ? this.high : this.high >>> e3 - 32, 0, this.unsigned);
          }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.rotateLeft = function(e3) {
            var t3;
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : 32 === e3 ? l(this.high, this.low, this.unsigned) : e3 < 32 ? (t3 = 32 - e3, l(this.low << e3 | this.high >>> t3, this.high << e3 | this.low >>> t3, this.unsigned)) : (t3 = 32 - (e3 -= 32), l(this.high << e3 | this.low >>> t3, this.low << e3 | this.high >>> t3, this.unsigned));
          }, S.rotl = S.rotateLeft, S.rotateRight = function(e3) {
            var t3;
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : 32 === e3 ? l(this.high, this.low, this.unsigned) : e3 < 32 ? (t3 = 32 - e3, l(this.high << t3 | this.low >>> e3, this.low << t3 | this.high >>> e3, this.unsigned)) : (t3 = 32 - (e3 -= 32), l(this.low << t3 | this.high >>> e3, this.high << t3 | this.low >>> e3, this.unsigned));
          }, S.rotr = S.rotateRight, S.toSigned = function() {
            return this.unsigned ? l(this.low, this.high, false) : this;
          }, S.toUnsigned = function() {
            return this.unsigned ? this : l(this.low, this.high, true);
          }, S.toBytes = function(e3) {
            return e3 ? this.toBytesLE() : this.toBytesBE();
          }, S.toBytesLE = function() {
            var e3 = this.high, t3 = this.low;
            return [255 & t3, t3 >>> 8 & 255, t3 >>> 16 & 255, t3 >>> 24, 255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24];
          }, S.toBytesBE = function() {
            var e3 = this.high, t3 = this.low;
            return [e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3, t3 >>> 24, t3 >>> 16 & 255, t3 >>> 8 & 255, 255 & t3];
          }, n2.fromBytes = function(e3, t3, r3) {
            return r3 ? n2.fromBytesLE(e3, t3) : n2.fromBytesBE(e3, t3);
          }, n2.fromBytesLE = function(e3, t3) {
            return new n2(e3[0] | e3[1] << 8 | e3[2] << 16 | e3[3] << 24, e3[4] | e3[5] << 8 | e3[6] << 16 | e3[7] << 24, t3);
          }, n2.fromBytesBE = function(e3, t3) {
            return new n2(e3[4] << 24 | e3[5] << 16 | e3[6] << 8 | e3[7], e3[0] << 24 | e3[1] << 16 | e3[2] << 8 | e3[3], t3);
          };
          var A = n2;
          return e2.default = A, "default" in e2 ? e2.default : e2;
        }({});
        void 0 === (n = (function() {
          return r;
        }).apply(t, [])) || (e.exports = n);
      }, 5686: (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { flatbuffers: () => r });
        var r = {};
        r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(e2, t2) {
          this.low = 0 | e2, this.high = 0 | t2;
        }, r.Long.create = function(e2, t2) {
          return 0 == e2 && 0 == t2 ? r.Long.ZERO : new r.Long(e2, t2);
        }, r.Long.prototype.toFloat64 = function() {
          return (this.low >>> 0) + 4294967296 * this.high;
        }, r.Long.prototype.equals = function(e2) {
          return this.low == e2.low && this.high == e2.high;
        }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(e2) {
          if (e2)
            t2 = e2;
          else
            var t2 = 1024;
          this.bb = r.ByteBuffer.allocate(t2), this.space = t2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        }, r.Builder.prototype.clear = function() {
          this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        }, r.Builder.prototype.forceDefaults = function(e2) {
          this.force_defaults = e2;
        }, r.Builder.prototype.dataBuffer = function() {
          return this.bb;
        }, r.Builder.prototype.asUint8Array = function() {
          return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
        }, r.Builder.prototype.prep = function(e2, t2) {
          e2 > this.minalign && (this.minalign = e2);
          for (var n2 = 1 + ~(this.bb.capacity() - this.space + t2) & e2 - 1; this.space < n2 + e2 + t2; ) {
            var o = this.bb.capacity();
            this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - o;
          }
          this.pad(n2);
        }, r.Builder.prototype.pad = function(e2) {
          for (var t2 = 0; t2 < e2; t2++)
            this.bb.writeInt8(--this.space, 0);
        }, r.Builder.prototype.writeInt8 = function(e2) {
          this.bb.writeInt8(this.space -= 1, e2);
        }, r.Builder.prototype.writeInt16 = function(e2) {
          this.bb.writeInt16(this.space -= 2, e2);
        }, r.Builder.prototype.writeInt32 = function(e2) {
          this.bb.writeInt32(this.space -= 4, e2);
        }, r.Builder.prototype.writeInt64 = function(e2) {
          this.bb.writeInt64(this.space -= 8, e2);
        }, r.Builder.prototype.writeFloat32 = function(e2) {
          this.bb.writeFloat32(this.space -= 4, e2);
        }, r.Builder.prototype.writeFloat64 = function(e2) {
          this.bb.writeFloat64(this.space -= 8, e2);
        }, r.Builder.prototype.addInt8 = function(e2) {
          this.prep(1, 0), this.writeInt8(e2);
        }, r.Builder.prototype.addInt16 = function(e2) {
          this.prep(2, 0), this.writeInt16(e2);
        }, r.Builder.prototype.addInt32 = function(e2) {
          this.prep(4, 0), this.writeInt32(e2);
        }, r.Builder.prototype.addInt64 = function(e2) {
          this.prep(8, 0), this.writeInt64(e2);
        }, r.Builder.prototype.addFloat32 = function(e2) {
          this.prep(4, 0), this.writeFloat32(e2);
        }, r.Builder.prototype.addFloat64 = function(e2) {
          this.prep(8, 0), this.writeFloat64(e2);
        }, r.Builder.prototype.addFieldInt8 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt8(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt16 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt16(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt32 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt32(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt64 = function(e2, t2, n2) {
          !this.force_defaults && t2.equals(n2) || (this.addInt64(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldFloat32 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addFloat32(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldFloat64 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addFloat64(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldOffset = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addOffset(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldStruct = function(e2, t2, n2) {
          t2 != n2 && (this.nested(t2), this.slot(e2));
        }, r.Builder.prototype.nested = function(e2) {
          if (e2 != this.offset())
            throw new Error("FlatBuffers: struct must be serialized inline.");
        }, r.Builder.prototype.notNested = function() {
          if (this.isNested)
            throw new Error("FlatBuffers: object serialization must not be nested.");
        }, r.Builder.prototype.slot = function(e2) {
          this.vtable[e2] = this.offset();
        }, r.Builder.prototype.offset = function() {
          return this.bb.capacity() - this.space;
        }, r.Builder.growByteBuffer = function(e2) {
          var t2 = e2.capacity();
          if (3221225472 & t2)
            throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
          var n2 = t2 << 1, o = r.ByteBuffer.allocate(n2);
          return o.setPosition(n2 - t2), o.bytes().set(e2.bytes(), n2 - t2), o;
        }, r.Builder.prototype.addOffset = function(e2) {
          this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - e2 + r.SIZEOF_INT);
        }, r.Builder.prototype.startObject = function(e2) {
          this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e2;
          for (var t2 = 0; t2 < e2; t2++)
            this.vtable[t2] = 0;
          this.isNested = true, this.object_start = this.offset();
        }, r.Builder.prototype.endObject = function() {
          if (null == this.vtable || !this.isNested)
            throw new Error("FlatBuffers: endObject called without startObject");
          this.addInt32(0);
          for (var e2 = this.offset(), t2 = this.vtable_in_use - 1; t2 >= 0 && 0 == this.vtable[t2]; t2--)
            ;
          for (var n2 = t2 + 1; t2 >= 0; t2--)
            this.addInt16(0 != this.vtable[t2] ? e2 - this.vtable[t2] : 0);
          this.addInt16(e2 - this.object_start);
          var o = (n2 + 2) * r.SIZEOF_SHORT;
          this.addInt16(o);
          var i = 0, a = this.space;
          e:
            for (t2 = 0; t2 < this.vtables.length; t2++) {
              var s = this.bb.capacity() - this.vtables[t2];
              if (o == this.bb.readInt16(s)) {
                for (var u = r.SIZEOF_SHORT; u < o; u += r.SIZEOF_SHORT)
                  if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u))
                    continue e;
                i = this.vtables[t2];
                break;
              }
            }
          return i ? (this.space = this.bb.capacity() - e2, this.bb.writeInt32(this.space, i - e2)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e2, this.offset() - e2)), this.isNested = false, e2;
        }, r.Builder.prototype.finish = function(e2, t2, n2) {
          var o = n2 ? r.SIZE_PREFIX_LENGTH : 0;
          if (t2) {
            var i = t2;
            if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + o), i.length != r.FILE_IDENTIFIER_LENGTH)
              throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
            for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--)
              this.writeInt8(i.charCodeAt(a));
          }
          this.prep(this.minalign, r.SIZEOF_INT + o), this.addOffset(e2), o && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
        }, r.Builder.prototype.finishSizePrefixed = function(e2, t2) {
          this.finish(e2, t2, true);
        }, r.Builder.prototype.requiredField = function(e2, t2) {
          var n2 = this.bb.capacity() - e2, r2 = n2 - this.bb.readInt32(n2);
          if (0 == this.bb.readInt16(r2 + t2))
            throw new Error("FlatBuffers: field " + t2 + " must be set");
        }, r.Builder.prototype.startVector = function(e2, t2, n2) {
          this.notNested(), this.vector_num_elems = t2, this.prep(r.SIZEOF_INT, e2 * t2), this.prep(n2, e2 * t2);
        }, r.Builder.prototype.endVector = function() {
          return this.writeInt32(this.vector_num_elems), this.offset();
        }, r.Builder.prototype.createString = function(e2) {
          if (e2 instanceof Uint8Array)
            var t2 = e2;
          else {
            t2 = [];
            for (var n2 = 0; n2 < e2.length; ) {
              var r2, o = e2.charCodeAt(n2++);
              (r2 = o < 55296 || o >= 56320 ? o : (o << 10) + e2.charCodeAt(n2++) + -56613888) < 128 ? t2.push(r2) : (r2 < 2048 ? t2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? t2.push(r2 >> 12 & 15 | 224) : t2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), t2.push(r2 >> 6 & 63 | 128)), t2.push(63 & r2 | 128));
            }
          }
          this.addInt8(0), this.startVector(1, t2.length, 1), this.bb.setPosition(this.space -= t2.length), n2 = 0;
          for (var i = this.space, a = this.bb.bytes(); n2 < t2.length; n2++)
            a[i++] = t2[n2];
          return this.endVector();
        }, r.Builder.prototype.createLong = function(e2, t2) {
          return r.Long.create(e2, t2);
        }, r.ByteBuffer = function(e2) {
          this.bytes_ = e2, this.position_ = 0;
        }, r.ByteBuffer.allocate = function(e2) {
          return new r.ByteBuffer(new Uint8Array(e2));
        }, r.ByteBuffer.prototype.clear = function() {
          this.position_ = 0;
        }, r.ByteBuffer.prototype.bytes = function() {
          return this.bytes_;
        }, r.ByteBuffer.prototype.position = function() {
          return this.position_;
        }, r.ByteBuffer.prototype.setPosition = function(e2) {
          this.position_ = e2;
        }, r.ByteBuffer.prototype.capacity = function() {
          return this.bytes_.length;
        }, r.ByteBuffer.prototype.readInt8 = function(e2) {
          return this.readUint8(e2) << 24 >> 24;
        }, r.ByteBuffer.prototype.readUint8 = function(e2) {
          return this.bytes_[e2];
        }, r.ByteBuffer.prototype.readInt16 = function(e2) {
          return this.readUint16(e2) << 16 >> 16;
        }, r.ByteBuffer.prototype.readUint16 = function(e2) {
          return this.bytes_[e2] | this.bytes_[e2 + 1] << 8;
        }, r.ByteBuffer.prototype.readInt32 = function(e2) {
          return this.bytes_[e2] | this.bytes_[e2 + 1] << 8 | this.bytes_[e2 + 2] << 16 | this.bytes_[e2 + 3] << 24;
        }, r.ByteBuffer.prototype.readUint32 = function(e2) {
          return this.readInt32(e2) >>> 0;
        }, r.ByteBuffer.prototype.readInt64 = function(e2) {
          return new r.Long(this.readInt32(e2), this.readInt32(e2 + 4));
        }, r.ByteBuffer.prototype.readUint64 = function(e2) {
          return new r.Long(this.readUint32(e2), this.readUint32(e2 + 4));
        }, r.ByteBuffer.prototype.readFloat32 = function(e2) {
          return r.int32[0] = this.readInt32(e2), r.float32[0];
        }, r.ByteBuffer.prototype.readFloat64 = function(e2) {
          return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(e2), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(e2 + 4), r.float64[0];
        }, r.ByteBuffer.prototype.writeInt8 = function(e2, t2) {
          this.bytes_[e2] = t2;
        }, r.ByteBuffer.prototype.writeUint8 = function(e2, t2) {
          this.bytes_[e2] = t2;
        }, r.ByteBuffer.prototype.writeInt16 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8;
        }, r.ByteBuffer.prototype.writeUint16 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8;
        }, r.ByteBuffer.prototype.writeInt32 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8, this.bytes_[e2 + 2] = t2 >> 16, this.bytes_[e2 + 3] = t2 >> 24;
        }, r.ByteBuffer.prototype.writeUint32 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8, this.bytes_[e2 + 2] = t2 >> 16, this.bytes_[e2 + 3] = t2 >> 24;
        }, r.ByteBuffer.prototype.writeInt64 = function(e2, t2) {
          this.writeInt32(e2, t2.low), this.writeInt32(e2 + 4, t2.high);
        }, r.ByteBuffer.prototype.writeUint64 = function(e2, t2) {
          this.writeUint32(e2, t2.low), this.writeUint32(e2 + 4, t2.high);
        }, r.ByteBuffer.prototype.writeFloat32 = function(e2, t2) {
          r.float32[0] = t2, this.writeInt32(e2, r.int32[0]);
        }, r.ByteBuffer.prototype.writeFloat64 = function(e2, t2) {
          r.float64[0] = t2, this.writeInt32(e2, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(e2 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
        }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
          if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
          for (var e2 = "", t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++)
            e2 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + t2));
          return e2;
        }, r.ByteBuffer.prototype.__offset = function(e2, t2) {
          var n2 = e2 - this.readInt32(e2);
          return t2 < this.readInt16(n2) ? this.readInt16(n2 + t2) : 0;
        }, r.ByteBuffer.prototype.__union = function(e2, t2) {
          return e2.bb_pos = t2 + this.readInt32(t2), e2.bb = this, e2;
        }, r.ByteBuffer.prototype.__string = function(e2, t2) {
          e2 += this.readInt32(e2);
          var n2 = this.readInt32(e2), o = "", i = 0;
          if (e2 += r.SIZEOF_INT, t2 === r.Encoding.UTF8_BYTES)
            return this.bytes_.subarray(e2, e2 + n2);
          for (; i < n2; ) {
            var a, s = this.readUint8(e2 + i++);
            if (s < 192)
              a = s;
            else {
              var u = this.readUint8(e2 + i++);
              if (s < 224)
                a = (31 & s) << 6 | 63 & u;
              else {
                var l = this.readUint8(e2 + i++);
                a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & l : (7 & s) << 18 | (63 & u) << 12 | (63 & l) << 6 | 63 & this.readUint8(e2 + i++);
              }
            }
            a < 65536 ? o += String.fromCharCode(a) : (a -= 65536, o += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
          }
          return o;
        }, r.ByteBuffer.prototype.__indirect = function(e2) {
          return e2 + this.readInt32(e2);
        }, r.ByteBuffer.prototype.__vector = function(e2) {
          return e2 + this.readInt32(e2) + r.SIZEOF_INT;
        }, r.ByteBuffer.prototype.__vector_len = function(e2) {
          return this.readInt32(e2 + this.readInt32(e2));
        }, r.ByteBuffer.prototype.__has_identifier = function(e2) {
          if (e2.length != r.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
          for (var t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++)
            if (e2.charCodeAt(t2) != this.readInt8(this.position_ + r.SIZEOF_INT + t2))
              return false;
          return true;
        }, r.ByteBuffer.prototype.createLong = function(e2, t2) {
          return r.Long.create(e2, t2);
        };
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t)
          return t.exports;
        var n = __webpack_module_cache__[e] = { exports: {} };
        return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.exports;
      }
      __webpack_require__.n = (e) => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return __webpack_require__.d(t, { a: t }), t;
      }, __webpack_require__.d = (e, t) => {
        for (var n in t)
          __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, { enumerable: true, get: t[n] });
      }, __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = (e) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: true });
      };
      var __webpack_exports__ = __webpack_require__(1057);
      return __webpack_exports__;
    })());
  }
});

// node_modules/@imgly/background-removal/dist/index.mjs
var import_lodash = __toESM(require_lodash(), 1);
var import_ndarray = __toESM(require_ndarray(), 1);
var import_ndarray2 = __toESM(require_ndarray(), 1);
var import_ndarray3 = __toESM(require_ndarray(), 1);
var import_ndarray4 = __toESM(require_ndarray(), 1);
var ort = __toESM(require_ort_min(), 1);

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@imgly/background-removal/dist/index.mjs
var import_ndarray5 = __toESM(require_ndarray(), 1);
async function imageDecode(blob) {
  const imageBitmap = await createImageBitmap(blob);
  const imageData = imageBitmapToImageData(imageBitmap);
  return (0, import_ndarray3.default)(imageData.data, [imageData.height, imageData.width, 4]);
}
async function imageEncode(imageTensor, quality = 0.8, format = "image/png") {
  const [height, width, channels] = imageTensor.shape;
  switch (format) {
    case "image/x-r8":
      return new Blob([imageTensor.data], { type: "image/x-alpha8" });
    case "image/x-rgba8":
      return new Blob([imageTensor.data], { type: "image/x-rgba8" });
    case `image/png`:
    case `image/jpeg`:
    case `image/webp`:
      const imageData = new ImageData(
        new Uint8ClampedArray(imageTensor.data),
        width,
        height
      );
      var canvas = new OffscreenCanvas(imageData.width, imageData.height);
      var ctx = canvas.getContext("2d");
      ctx.putImageData(imageData, 0, 0);
      return canvas.convertToBlob({ quality, type: format });
    default:
      throw new Error(`Invalid format: ${format}`);
  }
}
function isAbsoluteURI(url) {
  const regExp = new RegExp("^(?:[a-z+]+:)?//", "i");
  return regExp.test(url);
}
function ensureAbsoluteURI(url, baseUrl) {
  if (isAbsoluteURI(url)) {
    return url;
  } else {
    return new URL(url, baseUrl).href;
  }
}
function imageBitmapToImageData(imageBitmap) {
  var canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
  var ctx = canvas.getContext("2d");
  ctx.drawImage(imageBitmap, 0, 0);
  return ctx.getImageData(0, 0, canvas.width, canvas.height);
}
function tensorResizeBilinear(imageTensor, newWidth, newHeight) {
  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;
  const scaleX = srcWidth / newWidth;
  const scaleY = srcHeight / newHeight;
  const resizedImageData = (0, import_ndarray2.default)(
    new Uint8Array(srcChannels * newWidth * newHeight),
    [newHeight, newWidth, srcChannels]
  );
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      const srcX = x * scaleX;
      const srcY = y * scaleY;
      const x1 = Math.max(Math.floor(srcX), 0);
      const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);
      const y1 = Math.max(Math.floor(srcY), 0);
      const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);
      const dx = srcX - x1;
      const dy = srcY - y1;
      for (let c = 0; c < srcChannels; c++) {
        const p1 = imageTensor.get(y1, x1, c);
        const p2 = imageTensor.get(y1, x2, c);
        const p3 = imageTensor.get(y2, x1, c);
        const p4 = imageTensor.get(y2, x2, c);
        const interpolatedValue = (1 - dx) * (1 - dy) * p1 + dx * (1 - dy) * p2 + (1 - dx) * dy * p3 + dx * dy * p4;
        resizedImageData.set(y, x, c, Math.round(interpolatedValue));
      }
    }
  }
  return resizedImageData;
}
function tensorHWCtoBCHW(imageTensor, mean = [128, 128, 128], std = [256, 256, 256]) {
  var imageBufferData = imageTensor.data;
  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;
  const stride = srcHeight * srcWidth;
  const float32Data = new Float32Array(3 * stride);
  for (let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1) {
    float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];
    float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];
    float32Data[j + stride + stride] = (imageBufferData[i + 2] - mean[2]) / std[2];
  }
  return (0, import_ndarray2.default)(float32Data, [1, 3, srcHeight, srcWidth]);
}
async function imageSourceToImageData(image, config) {
  if (typeof image === "string") {
    image = ensureAbsoluteURI(image, config.publicPath);
    image = new URL(image);
  }
  if (image instanceof URL) {
    const response = await fetch(image, {});
    image = await response.blob();
  }
  if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {
    image = new Blob([image]);
  }
  if (image instanceof Blob) {
    image = await imageDecode(image);
  }
  return image;
}
function convertFloat32ToUint8(float32Array) {
  const uint8Array = new Uint8Array(float32Array.data.length);
  for (let i = 0; i < float32Array.data.length; i++) {
    uint8Array[i] = float32Array.data[i] * 255;
  }
  return (0, import_ndarray2.default)(uint8Array, float32Array.shape);
}
async function preload(config) {
  const resourceUrl = new URL("resources.json", config.publicPath);
  const resourceResponse = await fetch(resourceUrl);
  if (!resourceResponse.ok) {
    throw new Error(
      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`
    );
  }
  const resourceMap = await resourceResponse.json();
  const keys = Object.keys(resourceMap);
  await Promise.all(
    keys.map(async (key) => {
      return loadAsBlob(key, config);
    })
  );
}
async function loadAsUrl(url, config) {
  return URL.createObjectURL(await loadAsBlob(url, config));
}
async function loadAsBlob(key, config) {
  const resourceUrl = new URL("resources.json", config.publicPath);
  const resourceResponse = await fetch(resourceUrl);
  if (!resourceResponse.ok) {
    throw new Error(
      `Resource metadata not found. Ensure that the config.publicPath is configured correctly.`
    );
  }
  const resourceMap = await resourceResponse.json();
  const entry = resourceMap[key];
  if (!entry) {
    throw new Error(
      `Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`
    );
  }
  const chunks = entry.chunks;
  let downloadedSize = 0;
  const responses = chunks.map(async (chunk) => {
    const url = config.publicPath ? new URL(chunk.hash, config.publicPath).toString() : chunk.hash;
    const response = await fetch(url, config.fetchArgs);
    const blob = await response.blob();
    if (chunk.size !== blob.size) {
      throw new Error(
        `Failed to fetch ${key} with size ${chunk.size} but got ${blob.size}`
      );
    }
    if (config.progress) {
      downloadedSize += chunk.size;
      config.progress(`fetch:${key}`, downloadedSize, entry.size);
    }
    return blob;
  });
  const allChunkData = await Promise.all(responses);
  const data = new Blob(allChunkData, { type: entry.mime });
  if (data.size !== entry.size) {
    throw new Error(
      `Failed to fetch ${key} with size ${entry.size} but got ${data.size}`
    );
  }
  return data;
}
var simd = async () => WebAssembly.validate(
  new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    5,
    1,
    96,
    0,
    1,
    123,
    3,
    2,
    1,
    0,
    10,
    10,
    1,
    8,
    0,
    65,
    0,
    253,
    15,
    253,
    98,
    11
  ])
);
var threads = () => (async (e) => {
  try {
    return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
  } catch (e2) {
    return false;
  }
})(
  new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    2,
    1,
    0,
    5,
    4,
    1,
    3,
    1,
    1,
    10,
    11,
    1,
    9,
    0,
    65,
    0,
    254,
    16,
    2,
    0,
    26,
    11
  ])
);
async function createOnnxSession(model, config) {
  const capabilities = {
    simd: await simd(),
    threads: await threads(),
    numThreads: navigator.hardwareConcurrency ?? 4,
    // @ts-ignore
    webgpu: navigator.gpu !== void 0
  };
  if (config.debug) {
    console.debug("Capabilities:", capabilities);
    ort.env.debug = true;
    ort.env.logLevel = "verbose";
  }
  ort.env.wasm.numThreads = capabilities.numThreads;
  ort.env.wasm.simd = capabilities.simd;
  ort.env.wasm.proxy = config.proxyToWorker;
  ort.env.wasm.wasmPaths = {
    "ort-wasm-simd-threaded.wasm": capabilities.simd && capabilities.threads ? await loadAsUrl(
      "/onnxruntime-web/ort-wasm-simd-threaded.wasm",
      config
    ) : void 0,
    "ort-wasm-simd.wasm": capabilities.simd && !capabilities.threads ? await loadAsUrl("/onnxruntime-web/ort-wasm-simd.wasm", config) : void 0,
    "ort-wasm-threaded.wasm": !capabilities.simd && capabilities.threads ? await loadAsUrl("/onnxruntime-web/ort-wasm-threaded.wasm", config) : void 0,
    "ort-wasm.wasm": !capabilities.simd && !capabilities.threads ? await loadAsUrl("/onnxruntime-web/ort-wasm.wasm", config) : void 0
  };
  if (config.debug) {
    console.debug("ort.env.wasm:", ort.env.wasm);
  }
  const ort_config = {
    executionProviders: ["wasm"],
    graphOptimizationLevel: "all",
    executionMode: "parallel",
    enableCpuMemArena: true
  };
  const session = await ort.InferenceSession.create(model, ort_config).catch(
    (e) => {
      throw new Error(
        `Failed to create session: ${e}. Please check if the publicPath is set correctly.`
      );
    }
  );
  return session;
}
async function runOnnxSession(session, inputs, outputs) {
  const feeds = {};
  for (const [key, tensor] of inputs) {
    feeds[key] = new ort.Tensor(
      "float32",
      new Float32Array(tensor.data),
      tensor.shape
    );
  }
  const outputData = await session.run(feeds, {});
  const outputKVPairs = [];
  for (const key of outputs) {
    const output = outputData[key];
    const shape = output.dims;
    const data = output.data;
    const tensor = (0, import_ndarray4.default)(data, shape);
    outputKVPairs.push(tensor);
  }
  return outputKVPairs;
}
var package_default = {
  name: "@imgly/background-removal",
  version: "1.3.0",
  description: "Background Removal in the Browser",
  keywords: [
    "background-removal",
    "client-side",
    "data-privacy",
    "image-segmentation",
    "image-matting",
    "onnx"
  ],
  repository: {
    type: "git",
    url: "git+https://github.com/imgly/background-removal-js.git"
  },
  license: "SEE LICENSE IN LICENSE.md",
  author: {
    name: "IMG.LY GmbH",
    email: "support@img.ly",
    url: "https://img.ly"
  },
  bugs: {
    email: "support@img.ly"
  },
  source: "./src/index.ts",
  main: "./dist/index.cjs",
  module: "./dist/index.mjs",
  types: "./dist/index.d.ts",
  exports: {
    ".": {
      require: "./dist/index.cjs",
      import: "./dist/index.mjs",
      types: "./dist/index.d.ts"
    }
  },
  homepage: "https://img.ly/showcases/cesdk/web/background-removal",
  files: [
    "LICENSE.md",
    "README.md",
    "CHANGELOG.md",
    "dist/",
    "bin/"
  ],
  scripts: {
    start: "npm run watch",
    clean: "npx rimraf dist",
    test: "true",
    resources: "node ../../scripts/package-resources.mjs",
    "changelog:create": "node ../../scripts/changelog/create.mjs",
    "changelog:generate": "node ../../scripts/changelog/generate.mjs",
    build: "npm run clean && npm run resources && npm run changelog:generate && node scripts/build.mjs",
    watch: "npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs",
    publish: "npm run build && npm publish --access public",
    lint: "npx prettier --write ."
  },
  dependencies: {
    "@types/lodash": "^4.14.195",
    "@types/node": "^20.3.1",
    lodash: "^4.17.21",
    ndarray: "^1.0.19",
    "onnxruntime-web": "^1.16.3",
    zod: "^3.21.4"
  },
  devDependencies: {
    assert: "^2.0.0",
    esbuild: "^0.18.18",
    glob: "^10.3.3",
    "npm-dts": "^1.3.12",
    process: "^0.11.10",
    "ts-loader": "^9.4.3",
    tslib: "^2.5.3",
    typescript: "^5.1.3",
    util: "^0.12.5",
    webpack: "^5.85.1",
    "webpack-cli": "^5.1.4"
  }
};
var ConfigSchema = z.object({
  publicPath: z.string().optional().describe("The public path to the wasm files and the onnx model.").default("https://unpkg.com/${PACKAGE_NAME}@${PACKAGE_VERSION}/dist/").transform((val) => {
    return val.replace("${PACKAGE_NAME}", package_default.name).replace("${PACKAGE_VERSION}", package_default.version);
  }),
  debug: z.boolean().default(false).describe("Whether to enable debug logging."),
  proxyToWorker: z.boolean().default(true).describe("Whether to proxy inference to a web worker."),
  fetchArgs: z.any().default({}).describe("Arguments to pass to fetch when loading the model."),
  progress: z.function().args(z.string(), z.number(), z.number()).returns(z.void()).describe("Progress callback.").optional(),
  model: z.enum(["small", "medium"]).default("medium"),
  output: z.object({
    format: z.enum([
      "image/png",
      "image/jpeg",
      "image/webp",
      "image/x-rgba8",
      "image/x-alpha8"
    ]).default("image/png"),
    quality: z.number().default(0.8)
  }).default({})
}).default({});
function validateConfig(configuration) {
  const config = ConfigSchema.parse(configuration ?? {});
  if (config.debug)
    console.log("Config:", config);
  if (config.debug && !config.progress) {
    config.progress = config.progress ?? ((key, current, total) => {
      console.debug(`Downloading ${key}: ${current} of ${total}`);
    });
    if (!crossOriginIsolated) {
      console.debug(
        "Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer."
      );
    }
  }
  return config;
}
async function initInference(config) {
  config = validateConfig(config);
  if (config.debug)
    console.debug("Loading model...");
  const model = config.model;
  const blob = await loadAsBlob(`/models/${model}`, config);
  const arrayBuffer = await blob.arrayBuffer();
  const session = await createOnnxSession(arrayBuffer, config);
  return { config, session };
}
async function runInference(imageTensor, config, session) {
  if (config.progress)
    config.progress("compute:inference", 0, 1);
  const resolution = 1024;
  const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;
  let tensorImage = tensorResizeBilinear(imageTensor, resolution, resolution);
  const inputTensor = tensorHWCtoBCHW(tensorImage);
  const predictionsDict = await runOnnxSession(
    session,
    [["input", inputTensor]],
    ["output"]
  );
  let alphamask = (0, import_ndarray5.default)(predictionsDict[0].data, [resolution, resolution, 1]);
  alphamask = convertFloat32ToUint8(alphamask);
  alphamask = tensorResizeBilinear(alphamask, srcWidth, srcHeight);
  if (config.progress)
    config.progress("compute:inference", 1, 1);
  return alphamask;
}
var src_default = removeBackground;
var init = (0, import_lodash.memoize)(initInference, (config) => JSON.stringify(config));
async function preload2(configuration) {
  const config = validateConfig(configuration);
  await preload(config);
  return;
}
async function removeBackground(image, configuration) {
  const { config, session } = await init(configuration);
  const imageTensor = await imageSourceToImageData(image, config);
  const [width, height, channels] = imageTensor.shape;
  const alphamask = await runInference(imageTensor, config, session);
  const stride = width * height;
  const outImageTensor = imageTensor;
  for (let i = 0; i < stride; i += 1) {
    outImageTensor.data[4 * i + 3] = alphamask.data[i];
  }
  const outImage = await imageEncode(
    outImageTensor,
    config.output.quality,
    config.output.format
  );
  return outImage;
}
async function removeForeground(image, configuration) {
  const { config, session } = await init(configuration);
  const imageTensor = await imageSourceToImageData(image, config);
  const [width, height, channels] = imageTensor.shape;
  const alphamask = await runInference(imageTensor, config, session);
  const stride = width * height;
  const outImageTensor = imageTensor;
  for (let i = 0; i < stride; i += 1) {
    outImageTensor.data[4 * i + 3] = 255 - alphamask.data[i];
  }
  const outImage = await imageEncode(
    outImageTensor,
    config.output.quality,
    config.output.format
  );
  return outImage;
}
async function segmentForeground(image, configuration) {
  const { config, session } = await init(configuration);
  const imageTensor = await imageSourceToImageData(image, config);
  const [height, width, channels] = imageTensor.shape;
  const alphamask = await runInference(imageTensor, config, session);
  const stride = width * height;
  if (config.output.format === "image/x-alpha8") {
    const outImage = await imageEncode(
      alphamask,
      config.output.quality,
      config.output.format
    );
    return outImage;
  } else {
    const outImageTensor = (0, import_ndarray.default)(new Uint8Array(channels * stride), [
      height,
      width,
      channels
    ]);
    for (let i = 0; i < stride; i += 1) {
      const index = 4 * i + 3;
      outImageTensor.data[index] = alphamask.data[i];
      outImageTensor.data[index + 1] = alphamask.data[i];
      outImageTensor.data[index + 2] = alphamask.data[i];
      outImageTensor.data[index + 3] = 255;
    }
    const outImage = await imageEncode(
      outImageTensor,
      config.output.quality,
      config.output.format
    );
    return outImage;
  }
}
export {
  src_default as default,
  preload2 as preload,
  removeBackground,
  removeForeground,
  segmentForeground
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

onnxruntime-web/dist/ort.min.js:
  (*!
  * ONNX Runtime Web v1.16.3
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  *)
*/
//# sourceMappingURL=@imgly_background-removal.js.map
